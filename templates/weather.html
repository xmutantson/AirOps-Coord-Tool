{% extends "base.html" %}
{% block title %}Weather{% endblock %}
{% block content %}
<h2>Weather</h2>

<div class="wx-toolbar">
  <button id="wx-refresh" type="button">Refresh list</button>
  <div class="wx-reqbox">
    <strong>Request updates:</strong>
    <label class="wx-inline">
      {% set wl_ok = winlink_job_active|default(False) %}
      <input type="radio" name="wxMode" value="pat"
             {% if wl_ok %}checked{% else %}disabled{% endif %}> via PAT
      {% if not wl_ok %}
        <span class="muted" style="margin-left:.25rem;"
              title="Start WinLink polling from the Radio page">requires WinLink polling</span>
      {% endif %}
    </label>
    <label class="wx-inline">
      <input type="radio" name="wxMode" value="preview" {% if not wl_ok %}checked{% endif %}> manual compose
    </label>
    <!-- keep split in DOM but hard-hidden/disabled so we can re-enable later -->
    <label class="wx-inline hidden" title="Send one message per product (recommended)"
           aria-hidden="true" style="display:none">
      <input type="checkbox" id="wx-split"> split
    </label>
    <button id="wx-request" type="button">Go</button>
  </div>
  <span id="wx-request-status" class="wx-status"></span>
  <!-- Right-justified SAME toggle -->
  <button id="same-toggle" type="button" class="button" style="margin-left:auto">
    SAME Alerts <span id="same-badge" style="display:none;margin-left:.35rem;border-radius:9px;padding:.05rem .4rem;font-size:.8em;background:#b00020;color:#fff;">NEW</span>
  </button>
</div>

<!-- Collapsible SAME panel (pushes maps down when opened) -->
<div id="same-panel" style="display:none; margin:.5rem 0 1rem;">
  <!-- content injected by script below -->
  <div id="same-panel-body"></div>
  <hr>
</div>

<div id="wx-cards" class="wx-cards"></div>

<!-- Manual Compose Modal -->
<div id="wx-compose-backdrop" class="modal" style="display:none;">
  <div class="modal-window" role="dialog" aria-modal="true" aria-labelledby="wx-compose-title">
    <h3 id="wx-compose-title">Manual compose (copy into Winlink)</h3>
    <p class="muted">Prepared messages (To, Subject, Body). Copy/paste into Winlink.</p>
    <div id="wx-preview-body" class="wx-preview-body"></div>
    <div class="actions">
      <button type="button" id="wx-compose-close" class="button">Close</button>
    </div>
  </div>
</div>

<script>
(async function(){
  const $ = s => document.querySelector(s);

  const refreshBtn = $('#wx-refresh');
  const requestBtn = $('#wx-request');
  const requestStatus = $('#wx-request-status');

  const splitBox = $('#wx-split');           // retained for future use
  if (splitBox){
    splitBox.checked = false;                // force OFF
    splitBox.disabled = true;                // cannot be toggled
  }

  const root = document.getElementById("wx-cards");

  // Flicker control: keep DOM/card & signature maps so we only update what changed
  const cardEls = new Map();   // key -> card element
  const sigMap  = new Map();   // key -> "mime|etag|received_at"

  // Modal bits
  const composeBackdrop = $('#wx-compose-backdrop');
  const composeClose    = $('#wx-compose-close');
  const previewBody     = $('#wx-preview-body');

  const csrf = (document.querySelector('meta[name="csrf-token"]')?.content) || '';

  // ---------- modal helpers ----------
  function openCompose(){ composeBackdrop.style.display = 'flex'; }
  function closeCompose(){ composeBackdrop.style.display = 'none'; previewBody.innerHTML = ''; }
  composeClose?.addEventListener('click', closeCompose);
  composeBackdrop?.addEventListener('click', (e)=>{ if (e.target === composeBackdrop) closeCompose(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && composeBackdrop.style.display !== 'none') closeCompose(); });

  async function loadCatalog(){
    const r = await fetch("/api/weather/catalog");
    return await r.json();
  }

  function buildCard(p){
    const k = p.key, name = p.display_name || k;
    const isImage = p.mime && p.mime.startsWith("image/");
    const el = document.createElement('div');
    el.className = isImage ? 'wx-card wx-card--image' : 'wx-card wx-card--text';
    el.dataset.key = k;
    el.innerHTML = `
      <div class="wx-card__meta">
        <div class="wx-name"></div>
        <div class="wx-sub"></div>
      </div>
      <div data-body></div>
      <form data-wx-upload="1" action="/api/weather/upload" method="POST" enctype="multipart/form-data" class="wx-upload">
        <input type="hidden" name="csrf_token" value="${csrf}">
        <input type="hidden" name="key" value="${k}">
        <input type="file" name="file" required>
        <button type="submit">Upload to “${name}”</button>
      </form>
    `;
    el.querySelector('.wx-name').textContent = name;
    el.querySelector('.wx-sub').textContent = p.received_at_utc ? ("Last received: " + p.received_at_utc) : "No data yet";

    const body = el.querySelector('[data-body]');
    if (isImage){
      const a = document.createElement('a');
      a.target = '_blank'; a.rel = 'noopener';
      const img = document.createElement('img');
      img.decoding = 'async'; img.loading = 'lazy';
      a.appendChild(img); body.appendChild(a);
    } else {
      const pre = document.createElement('pre');
      pre.className = 'wx-textbody';
      body.appendChild(pre);
    }
    return el;
  }

  function sortForLayout(list){
    // Images first (fill first row), then text (e.g., WA_FOR_WA) which spans full row.
    return list.slice().sort((a,b)=>{
      const ai = a.mime && a.mime.startsWith('image/');
      const bi = b.mime && b.mime.startsWith('image/');
      if (ai === bi) return 0;
      return ai ? -1 : 1;
    });
  }

  function updateCardDOM(p){
    let el = cardEls.get(p.key);
    const isImage = p.mime && p.mime.startsWith('image/');
    const sig = `${p.mime}|${p.etag||''}|${p.received_at_utc||''}`;
    const prev = sigMap.get(p.key);

    if (!el){
      el = buildCard(p);
      cardEls.set(p.key, el);
    }

    // If nothing changed, bail (prevents flicker)
    if (prev === sig) return el;

    // Update meta
    el.querySelector('.wx-name').textContent = p.display_name || p.key;
    el.querySelector('.wx-sub').textContent  = p.received_at_utc ? ("Last received: " + p.received_at_utc) : "No data yet";

    const body = el.querySelector('[data-body]');
    if (isImage){
      let a = body.querySelector('a');
      let img = a?.querySelector('img');
      if (!a){ a = document.createElement('a'); a.target = '_blank'; a.rel = 'noopener'; }
      if (!img){ img = document.createElement('img'); img.decoding='async'; img.loading='lazy'; a.appendChild(img); }
      if (prev == null || (prev.split('|')[1] !== (p.etag||''))){
        const v = p.etag ? ("&v=" + encodeURIComponent(p.etag)) : "";
        const href = `/api/weather/blob/${encodeURIComponent(p.key)}?${v}`;
        a.href = href;
        Promise.resolve().then(()=> { img.src = href; }); // microtask to avoid flash
      }
      if (!a.parentNode) body.appendChild(a);
      el.className = 'wx-card wx-card--image';
    } else {
      let pre = body.querySelector('pre.wx-textbody');
      if (!pre){ pre = document.createElement('pre'); pre.className = 'wx-textbody'; body.innerHTML=''; body.appendChild(pre); }
      fetch(`/api/weather/text/${encodeURIComponent(p.key)}`)
        .then(r => r.ok ? r.text() : '')
        .then(t => { pre.textContent = t || ''; })
        .catch(()=> { pre.textContent = ''; });
      el.className = 'wx-card wx-card--text';
    }

    sigMap.set(p.key, sig);
    return el;
  }

  function reconcileOrder(sorted){
    const frag = document.createDocumentFragment();
    for (const p of sorted){
      const el = cardEls.get(p.key) || updateCardDOM(p);
      frag.appendChild(el);
    }
    // Remove any stale cards that are no longer in the catalog
    for (const [k, el] of Array.from(cardEls.entries())){
      if (!sorted.find(p => p.key === k)){
        el.remove(); cardEls.delete(k); sigMap.delete(k);
      }
    }
    root.appendChild(frag);
  }

  async function syncCatalog(){
    const catalog = await loadCatalog();
    const sorted = sortForLayout(catalog);
    for (const p of sorted){ updateCardDOM(p); }
    reconcileOrder(sorted);
  }

  await syncCatalog();

  // Manual refresh
  refreshBtn?.addEventListener('click', async ()=>{
    try { await syncCatalog(); } catch(_){}
  });

  // Copy helper for modal (with feedback)
  function wireCopy(container){
    container.querySelectorAll('[data-copy]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const target = btn.closest('.wx-msg')?.querySelector(btn.dataset.copy);
        if (!target) return;
        if (target.select) target.select();
        try { document.execCommand('copy'); } catch(_) {}
        const old = btn.textContent;
        btn.textContent = 'Copied';
        setTimeout(()=> btn.textContent = old, 800);
      });
    });
  }

  function renderPreview(list){
    if (!Array.isArray(list) || !list.length){
      closeCompose();
      return;
    }
    // To + Subject on one line with individual copy buttons; Body with copy below.
    previewBody.innerHTML = list.map((m,i)=>`
      <div class="wx-msg">
        <div class="wx-msg__title">Message ${i+1}</div>

        <div class="wx-row two">
          <label class="wx-field">
            <span>To</span>
            <div class="wx-inline-row">
              <input class="wx-to" value="${m.to}">
              <button type="button" class="button small" data-copy=".wx-to">Copy</button>
            </div>
          </label>

          <label class="wx-field">
            <span>Subject</span>
            <div class="wx-inline-row">
              <input class="wx-subject" value="${m.subject}">
              <button type="button" class="button small" data-copy=".wx-subject">Copy</button>
            </div>
          </label>
        </div>

        <label class="wx-field">
          <span>Body</span>
          <textarea class="wx-body" rows="8">${m.body}</textarea>
          <div class="wx-actions">
            <button type="button" class="button small" data-copy=".wx-body">Copy Body</button>
          </div>
        </label>
      </div>
    `).join('');
    wireCopy(previewBody);
    openCompose();
  }

  // Request updates → POST /api/weather/request (pat or preview)
  requestBtn?.addEventListener('click', async ()=>{
    requestBtn.disabled = true;
    requestStatus.textContent = 'requesting…';
    const mode = (document.querySelector('input[name="wxMode"]:checked')?.value || 'pat');

    // Force split OFF regardless of hidden checkbox state
    const payload = { mode, split: false, async: true };

    try{
      const r = await fetch('/api/weather/request', {
        method:'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });
      const j = await r.json();
      if (mode === 'preview'){
        if (j.ok){
          renderPreview(j.messages||[]);
          requestStatus.textContent = `prepared ${j.count||0} message(s)`;
        }else{
          requestStatus.textContent = `error: ${j.error||'failed'}`;
        }
      }else{
        if (j.ok && j.mode === 'pat_async'){
          requestStatus.textContent = `queued ${j.enqueued||0} message(s) at ${j.requested_at||''}`;
        } else if (j.ok){
          const ok = (j.results||[]).filter(x=>x.ok).length;
          requestStatus.textContent = `sent ${ok}/${j.count||0} at ${j.requested_at||''}`;
        } else {
          requestStatus.textContent = `error: ${j.error||'failed'}`;
        }
      }
    }catch(e){
      requestStatus.textContent = 'error';
    }finally{
      requestBtn.disabled = false;
    }
  });

  // Auto-refresh every 15s; incremental updates avoid flicker
  setInterval(async ()=>{
    try { await syncCatalog(); } catch(_) {}
  }, 15000);

  // Intercept uploads → POST via fetch and refresh cards
  root.addEventListener('submit', async (e)=>{
    const form = e.target;
    if (!form.matches('form[data-wx-upload="1"]')) return;
    e.preventDefault();
    try{
      const fd = new FormData(form);
      const r = await fetch(form.action, {
        method: 'POST',
        body: fd,
        headers: csrf ? {'X-CSRFToken': csrf} : undefined
      });
      const j = await r.json().catch(()=> ({}));
      if (j && j.ok){
        await syncCatalog();
      }else{
        console.warn('Upload failed', j);
      }
    }catch(err){
      console.error('Upload error', err);
    }
  });
})();
</script>

<script>
(function(){
  // Pick best stream format that the browser can play; fall back to WAV.
  function detectStreamFmt(){
    const a = document.createElement('audio');
    if (a && typeof a.canPlayType === 'function') {
      if (a.canPlayType('audio/ogg; codecs="opus"')) return 'ogg';
      if (a.canPlayType('audio/webm; codecs=opus')) return 'webm';
    }
    return 'wav';
  }
  const $ = s => document.querySelector(s);
  const panel = $('#same-panel');
  const panelBody = $('#same-panel-body');
  const toggleBtn = $('#same-toggle');
  const badge = $('#same-badge');
  const STORAGE_SEEN = 'same_last_seen';
  let showHidden = false;
  const STREAM_FMT = detectStreamFmt();  // 'ogg' | 'webm' | 'wav'

  function renderPanelShell(){
    panelBody.innerHTML = `
      <div class="wx-toolbar" style="gap:.5rem; flex-wrap:wrap;">
        <div>
          <button id="same-start" type="button">Start SAME</button>
          <button id="same-stop"  type="button">Stop SAME</button>
          <span id="same-status" class="wx-status"></span>
          <button id="same-refresh" type="button" style="margin-left:.5rem;">Refresh</button>
        </div>
        <div style="margin-left:auto; display:flex; align-items:center; gap:.75rem;">
          <label class="wx-inline"><input id="same-show-hidden" type="checkbox"> show hidden</label>
          <button id="same-mark-read" type="button" title="Mark newest as seen">Mark read</button>
        </div>
      </div>

      <!-- Live Monitor -->
      <div class="wx-toolbar" style="gap:.5rem; flex-wrap:wrap;">
        <div id="same-mon-chans"></div>
        <div style="margin-left:auto; display:flex; gap:.5rem;">
          <button id="same-audio-start" type="button">Start audio</button>
          <button id="same-mon-stop" type="button">Stop audio</button>
        </div>
      </div>
      <audio id="same-audio" controls preload="none" style="width:100%;max-width:520px;display:block;margin:.25rem 0 1rem;"></audio>

      <table id="same-table" class="table">
        <thead>
          <tr><th>Received (UTC)</th><th>Freq</th><th>Event</th><th>Areas</th><th>Header</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
    `;

    // Wire buttons
    const status = $('#same-status');
    const tBody = $('#same-table tbody');
    const btnStart = $('#same-start');
    const btnStop  = $('#same-stop');
    const btnRef   = $('#same-refresh');
    const btnMark  = $('#same-mark-read');
    const chkHidden= $('#same-show-hidden');
    const audio    = $('#same-audio');
    const monList  = $('#same-mon-chans');
    const monStop  = $('#same-mon-stop');

    async function loadAlerts(){
      const r = await fetch(`/api/weather/alerts?n=50&include_hidden=${showHidden?1:0}`);
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      const run = j.status?.running ? 'listening' : 'stopped';
      const mode = j.status?.mode || '';
      status.textContent = `${run} (${mode})`;
      const rows = (j.alerts||[]).map(a=>{
        const d = a.decoded || {};
        const event = d.event || d.EEE || (d.text||'');
        const areas = Array.isArray(d?.areas) ? d.areas.join(',') :
                      (Array.isArray(d?.FIPS) ? d.FIPS.join(',') : '');
        const mhz = (a.frequency_mhz!=null)? a.frequency_mhz.toFixed(3) : '';
        const action = a.is_hidden
          ? `<button data-unhide="${a.id}" class="button small">Restore</button>`
          : `<button data-hide="${a.id}" class="button small">Hide</button>`;
        const muted = a.is_hidden ? ' style="opacity:.5;"' : '';
        return `<tr${muted}>
          <td>${a.received_at_utc||''}</td>
          <td>${mhz}</td>
          <td>${event}</td>
          <td>${areas}</td>
          <td><code style="font-size:.85em">${a.header}</code></td>
          <td>${action}</td>
        </tr>`;
      }).join('');
      tBody.innerHTML = rows || `<tr><td colspan="6" class="muted">no alerts yet</td></tr>`;

      // NEW badge logic
      const latest = j.latest_utc || '';
      const lastSeen = localStorage.getItem(STORAGE_SEEN) || '';
      if (latest && (!lastSeen || latest > lastSeen)){
        badge.style.display = 'inline-block';
      } else {
        badge.style.display = 'none';
      }
      // Expose to base template (navbar) to clear red state when marked
      window.__sameLatest = latest;
    }

    // Hide/unhide actions
    tBody.addEventListener('click', async (e)=>{
      const btn = e.target.closest('button');
      if (!btn) return;
      if (btn.dataset.hide || btn.dataset.unhide){
        const id = parseInt(btn.dataset.hide || btn.dataset.unhide, 10);
        const hide = !!btn.dataset.hide;
        await fetch('/api/weather/alerts/hide', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({id, hide})
        });
        loadAlerts();
      }
    });

    // Monitor UI
    async function loadChans(){
      const r = await fetch('/api/weather/same/channels');
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      monList.innerHTML = '';
      (j.channels||[]).forEach((c)=>{
        const b = document.createElement('button');
        b.type='button';
        b.textContent = `${c.freq_mhz.toFixed(3)} MHz`;
        b.addEventListener('click', ()=>{
          // Ensure clean handoff to new stream to avoid UA aborts
          try { audio.pause(); } catch(_) {}
          try { audio.removeAttribute('src'); audio.load(); } catch(_) {}
          // cache-bust so the browser doesn’t reuse a half-open connection
          const ts = Date.now();
          audio.src = `/api/weather/same/stream?ch=${c.ch}&fmt=${STREAM_FMT}&ts=${ts}`;
          audio.play().catch(()=>{ /* ignore autoplay/gesture errors */ });
        });
        monList.appendChild(b);
      });
    }
    monStop.addEventListener('click', ()=>{
      audio.pause(); audio.removeAttribute('src'); audio.load();
    });
    loadChans();

    // Manual "Start audio" button (satisfies autoplay policies & helps testing)
    const btnAudioStart = $('#same-audio-start');
    btnAudioStart?.addEventListener('click', ()=>{
      try { audio.muted = false; } catch(_) {}
      try { audio.volume = 1; } catch(_) {}
      if (!audio.src) {
        const ts = Date.now();
        audio.src = `/api/weather/same/stream?ch=0&fmt=${STREAM_FMT}&ts=${ts}`;
      }
      audio.play().catch(()=>{
        // On failure (e.g., libopus missing or UA quirk), try WAV once.
        if (!/fmt=wav/.test(audio.src)) {
          try { audio.pause(); } catch(_) {}
          try { audio.removeAttribute('src'); audio.load(); } catch(_) {}
          const ts2 = Date.now();
          audio.src = `/api/weather/same/stream?ch=0&fmt=wav&ts=${ts2}`;
          audio.play().catch(()=>{});
        }
      });
    });

    // Panel controls
    btnStart?.addEventListener('click', async ()=>{ await fetch('/api/weather/same/start', {method:'POST'}); loadAlerts(); });
    btnStop ?.addEventListener('click', async ()=>{ await fetch('/api/weather/same/stop',  {method:'POST'}); loadAlerts(); });
    btnRef  ?.addEventListener('click', loadAlerts);
    chkHidden?.addEventListener('change', ()=>{ showHidden = !!chkHidden.checked; loadAlerts(); });
    btnMark ?.addEventListener('click', ()=>{
      const ts = window.__sameLatest || new Date().toISOString();
      localStorage.setItem(STORAGE_SEEN, ts);
      badge.style.display = 'none';
      if (typeof window.__sameMarkSeen === 'function') window.__sameMarkSeen(ts);
    });

    loadAlerts();
    // Keep updating while panel is open
    panel._sameTimer && clearInterval(panel._sameTimer);
    panel._sameTimer = setInterval(loadAlerts, 10000);
  }

  // Toggle handler
  toggleBtn.addEventListener('click', ()=>{
    const open = panel.style.display !== 'none';
    if (open){
      panel.style.display = 'none';
      if (panel._sameTimer) { clearInterval(panel._sameTimer); panel._sameTimer = null; }
    }else{
      panel.style.display = 'block';
      renderPanelShell();
      // mark seen immediately on open (UX: you saw the panel)
      const ts = window.__sameLatest || new Date().toISOString();
      localStorage.setItem(STORAGE_SEEN, ts);
      badge.style.display = 'none';
      if (typeof window.__sameMarkSeen === 'function') window.__sameMarkSeen(ts);
    }
  });

  // Background poll to update NEW badge while collapsed
  async function pollHead(){
    try{
      const r = await fetch('/api/weather/alerts/head');
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      const latest = j.latest || '';
      window.__sameLatest = latest;
      const lastSeen = localStorage.getItem(STORAGE_SEEN) || '';
      badge.style.display = (latest && (!lastSeen || latest > lastSeen)) ? 'inline-block' : 'none';
    }catch(_){}
  }
  setInterval(pollHead, 20000);
})();
</script>
{% endblock %}

