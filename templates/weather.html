{% extends "base.html" %}
{% block title %}Weather{% endblock %}
{% block content %}
<h2>Weather</h2>

<div class="wx-toolbar">
  <button id="wx-refresh" type="button">Refresh list</button>
  <div class="wx-reqbox">
    <strong>Request updates:</strong>
    <label class="wx-inline">
      {% set wl_ok = winlink_job_active|default(False) %}
      <input type="radio" name="wxMode" value="pat"
             {% if wl_ok %}checked{% else %}disabled{% endif %}> via PAT
      {% if not wl_ok %}
        <span class="muted" style="margin-left:.25rem;"
              title="Start WinLink polling from the Radio page">requires WinLink polling</span>
      {% endif %}
    </label>
    <span id="winlink-poll-wrap" class="muted" style="margin-left:.5rem; font-size:.85em; display:none;"
          title="Time until next Winlink inbox check">
      Next poll in <strong><span id="winlink-poll-secs">0</span></strong>s
    </span>
    <label class="wx-inline">
      <input type="radio" name="wxMode" value="preview" {% if not wl_ok %}checked{% endif %}> manual compose
    </label>
    <!-- keep split in DOM but hard-hidden/disabled so we can re-enable later -->
    <label class="wx-inline hidden" title="Send one message per product (recommended)"
           aria-hidden="true" style="display:none">
      <input type="checkbox" id="wx-split"> split
    </label>
    <button id="wx-request" type="button">Go</button>
  </div>
  <span id="wx-request-status" class="wx-status"></span>

  <!-- Right-justified controls -->
  <button id="metar-toggle" type="button" class="button" style="margin-left:auto">METAR/TAF Request</button>
  <button id="same-toggle" type="button" class="button" style="margin-left:.5rem">
    SAME Alerts <span id="same-badge" style="display:none;margin-left:.35rem;border-radius:9px;padding:.05rem .4rem;font-size:.8em;background:#b00020;color:#fff;">NEW</span>
  </button>
</div>

<!-- Collapsible METAR/TAF panel (hidden by default; full width; entries render as a single-column table) -->
<div id="metar-panel" style="display:none; margin:.5rem 0 1rem;">
  <div class="card" style="padding:.75rem;">
    <div style="display:flex; gap:.5rem; flex-wrap:wrap; align-items:flex-end;">
      <label class="wx-field" style="min-width:260px;">
        <span>ICAO IDs (comma/space separated)</span>
        <input id="metar-ids" class="force-upper" placeholder="e.g. KSEA CYVR">
      </label>
      <div class="wx-inline-row" style="gap:.5rem;">
        <button id="metar-fetch" type="button" class="button">Fetch via Internet</button>
        <button id="metar-compose" type="button" class="button" title="Prepare Winlink messages (one per ICAO)">Prepare via Winlink</button>
        <button id="metar-paste-toggle" type="button" class="button">Paste response</button>
      </div>
      <!-- Force decoded ON; hide the toggle from the UI -->
      <label class="wx-inline hidden" style="margin-left:auto;display:none;">
        <input id="metar-show-decoded" type="checkbox" checked> Show decoded (plain English)
      </label>
      <span id="metar-status" class="wx-status" style="margin-left:.5rem;"></span>
    </div>

    <!-- Paste flow (manual Winlink) -->
    <form id="metar-paste-form" style="display:none; margin-top:.75rem;">
      <label class="wx-field">
        <span>Raw METAR/TAF text</span>
        <textarea id="metar-paste-text" rows="6" placeholder="Paste the raw report you received via Winlink…"></textarea>
      </label>
      <div style="display:flex;justify-content:flex-end;margin-top:.5rem;">
        <button id="metar-paste-save" type="submit" class="button">Save pasted result</button>
      </div>
    </form>

    <hr>
    <div style="display:flex; align-items:center; gap:.5rem;">
      <strong>Request History</strong>
      <label class="wx-inline" style="margin-left:auto;">
        <select id="metar-view-scope">
          <option value="last">Show last 4</option>
          <option value="all">Show all</option>
        </select>
      </label>
      <button id="metar-hide-expired" type="button" class="button" title="Hide all expired METAR reports">Hide expired</button>
      <button id="metar-unhide-all" type="button" class="button" title="Clear local hides">Unhide all</button>
    </div>

    <!-- Single-column table to keep width constrained -->
    <div id="metar-list" style="margin-top:.5rem;">
      <table id="metar-table" class="table" style="width:100%;">
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<!-- Collapsible SAME panel (pushes maps down when opened) -->
<div id="same-panel" style="display:none; margin:.5rem 0 1rem;">
  <!-- content injected by script below -->
  <div id="same-panel-body"></div>
  <hr>
</div>

<div id="wx-cards" class="wx-cards"></div>

<!-- Manual Compose Modal -->
<div id="wx-compose-backdrop" class="modal" style="display:none;">
  <div class="modal-window" role="dialog" aria-modal="true" aria-labelledby="wx-compose-title">
    <h3 id="wx-compose-title">Manual compose (copy into Winlink)</h3>
    <p class="muted">Prepared messages (To, Subject, Body). Copy/paste into Winlink.</p>
    <div id="wx-preview-body" class="wx-preview-body"></div>
    <div class="actions">
      <button type="button" id="wx-compose-close" class="button">Close</button>
    </div>
  </div>
</div>

<script>
(async function(){
  const $ = s => document.querySelector(s);

  const refreshBtn = $('#wx-refresh');
  const requestBtn = $('#wx-request');
  const requestStatus = $('#wx-request-status');

  const splitBox = $('#wx-split');           // retained for future use
  if (splitBox){
    splitBox.checked = false;                // force OFF
    splitBox.disabled = true;                // cannot be toggled
  }

  const root = document.getElementById("wx-cards");

  // Flicker control: keep DOM/card & signature maps so we only update what changed
  const cardEls = new Map();   // key -> card element
  const sigMap  = new Map();   // key -> "mime|etag|received_at"

  // Modal bits
  const composeBackdrop = $('#wx-compose-backdrop');
  const composeClose    = $('#wx-compose-close');
  const previewBody     = $('#wx-preview-body');

  const csrf = (document.querySelector('meta[name="csrf-token"]')?.content) || '';

  // ---------- modal helpers ----------
  function openCompose(){ composeBackdrop.style.display = 'flex'; }
  function closeCompose(){ composeBackdrop.style.display = 'none'; previewBody.innerHTML = ''; }
  composeClose?.addEventListener('click', closeCompose);
  composeBackdrop?.addEventListener('click', (e)=>{ if (e.target === composeBackdrop) closeCompose(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && composeBackdrop.style.display !== 'none') closeCompose(); });

  async function loadCatalog(){
    const r = await fetch("/api/weather/catalog");
    return await r.json();
  }

  function buildCard(p){
    const k = p.key, name = p.display_name || k;
    const isImage = p.mime && p.mime.startsWith("image/");
    const el = document.createElement('div');
    el.className = isImage ? 'wx-card wx-card--image' : 'wx-card wx-card--text';
    el.dataset.key = k;
    el.innerHTML = `
      <div class="wx-card__meta">
        <div class="wx-name"></div>
        <div class="wx-sub"></div>
      </div>
      <div data-body></div>
      <form data-wx-upload="1" action="/api/weather/upload" method="POST" enctype="multipart/form-data" class="wx-upload">
        <input type="hidden" name="csrf_token" value="${csrf}">
        <input type="hidden" name="key" value="${k}">
        <input type="file" name="file" required>
        <button type="submit">Upload to “${name}”</button>
      </form>
    `;
    el.querySelector('.wx-name').textContent = name;
    el.querySelector('.wx-sub').textContent = p.received_at_utc ? ("Last received: " + p.received_at_utc) : "No data yet";

    const body = el.querySelector('[data-body]');
    if (isImage){
      const a = document.createElement('a');
      a.target = '_blank'; a.rel = 'noopener';
      const img = document.createElement('img');
      img.decoding = 'async'; img.loading = 'lazy';
      a.appendChild(img); body.appendChild(a);
    } else {
      const pre = document.createElement('pre');
      pre.className = 'wx-textbody';
      body.appendChild(pre);
    }
    return el;
  }

  function sortForLayout(list){
    // Images first (fill first row), then text (e.g., WA_FOR_WA) which spans full row.
    return list.slice().sort((a,b)=>{
      const ai = a.mime && a.mime.startsWith('image/');
      const bi = b.mime && b.mime.startsWith('image/');
      if (ai === bi) return 0;
      return ai ? -1 : 1;
    });
  }

  function updateCardDOM(p){
    let el = cardEls.get(p.key);
    const isImage = p.mime && p.mime.startsWith('image/');
    const sig = `${p.mime}|${p.etag||''}|${p.received_at_utc||''}`;
    const prev = sigMap.get(p.key);

    if (!el){
      el = buildCard(p);
      cardEls.set(p.key, el);
    }

    // If nothing changed, bail (prevents flicker)
    if (prev === sig) return el;

    // Update meta
    el.querySelector('.wx-name').textContent = p.display_name || p.key;
    el.querySelector('.wx-sub').textContent  = p.received_at_utc ? ("Last received: " + p.received_at_utc) : "No data yet";

    const body = el.querySelector('[data-body]');
    if (isImage){
      let a = body.querySelector('a');
      let img = a?.querySelector('img');
      if (!a){ a = document.createElement('a'); a.target = '_blank'; a.rel = 'noopener'; }
      if (!img){ img = document.createElement('img'); img.decoding='async'; img.loading='lazy'; a.appendChild(img); }
      if (prev == null || (prev.split('|')[1] !== (p.etag||''))){
        const v = p.etag ? ("&v=" + encodeURIComponent(p.etag)) : "";
        const href = `/api/weather/blob/${encodeURIComponent(p.key)}?${v}`;
        a.href = href;
        Promise.resolve().then(()=> { img.src = href; }); // microtask to avoid flash
      }
      if (!a.parentNode) body.appendChild(a);
      el.className = 'wx-card wx-card--image';
    } else {
      let pre = body.querySelector('pre.wx-textbody');
      if (!pre){ pre = document.createElement('pre'); pre.className = 'wx-textbody'; body.innerHTML=''; body.appendChild(pre); }
      fetch(`/api/weather/text/${encodeURIComponent(p.key)}`)
        .then(r => r.ok ? r.text() : '')
        .then(t => { pre.textContent = t || ''; })
        .catch(()=> { pre.textContent = ''; });
      el.className = 'wx-card wx-card--text';
    }

    sigMap.set(p.key, sig);
    return el;
  }

  function reconcileOrder(sorted){
    const frag = document.createDocumentFragment();
    for (const p of sorted){
      const el = cardEls.get(p.key) || updateCardDOM(p);
      frag.appendChild(el);
    }
    // Remove any stale cards that are no longer in the catalog
    for (const [k, el] of Array.from(cardEls.entries())){
      if (!sorted.find(p => p.key === k)){
        el.remove(); cardEls.delete(k); sigMap.delete(k);
      }
    }
    root.appendChild(frag);
  }

  async function syncCatalog(){
    const catalog = await loadCatalog();
    const sorted = sortForLayout(catalog);
    for (const p of sorted){ updateCardDOM(p); }
    reconcileOrder(sorted);
  }

  await syncCatalog();

  // Manual refresh
  refreshBtn?.addEventListener('click', async ()=>{
    try { await syncCatalog(); } catch(_){}
  });

  // Copy helper for modal (with feedback)
  function wireCopy(container){
    container.querySelectorAll('[data-copy]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const target = btn.closest('.wx-msg')?.querySelector(btn.dataset.copy);
        if (!target) return;
        if (target.select) target.select();
        try { document.execCommand('copy'); } catch(_) {}
        const old = btn.textContent;
        btn.textContent = 'Copied';
        setTimeout(()=> btn.textContent = old, 800);
      });
    });
  }

  function renderPreview(list){
    if (!Array.isArray(list) || !list.length){
      closeCompose();
      return;
    }
    // To + Subject on one line with individual copy buttons; Body with copy below.
    previewBody.innerHTML = list.map((m,i)=>`
      <div class="wx-msg">
        <div class="wx-msg__title">Message ${i+1}</div>

        <div class="wx-row two">
          <label class="wx-field">
            <span>To</span>
            <div class="wx-inline-row">
              <input class="wx-to" value="${m.to}">
              <button type="button" class="button small" data-copy=".wx-to">Copy</button>
            </div>
          </label>

          <label class="wx-field">
            <span>Subject</span>
            <div class="wx-inline-row">
              <input class="wx-subject" value="${m.subject}">
              <button type="button" class="button small" data-copy=".wx-subject">Copy</button>
            </div>
          </label>
        </div>

        <label class="wx-field">
          <span>Body</span>
          <textarea class="wx-body" rows="3">${m.body}</textarea>
          <div class="wx-actions">
            <button type="button" class="button small" data-copy=".wx-body">Copy Body</button>
          </div>
        </label>
      </div>
    `).join('');
    wireCopy(previewBody);
    openCompose();
  }

  // Request updates → POST /api/weather/request (pat or preview)
  requestBtn?.addEventListener('click', async ()=>{
    requestBtn.disabled = true;
    requestStatus.textContent = 'requesting…';
    const mode = (document.querySelector('input[name="wxMode"]:checked')?.value || 'pat');

    // Force split OFF regardless of hidden checkbox state
    const payload = { mode, split: false, async: true };

    try{
      const r = await fetch('/api/weather/request', {
        method:'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });
      const j = await r.json();
      if (mode === 'preview'){
        if (j.ok){
          renderPreview(j.messages||[]);
          requestStatus.textContent = `prepared ${j.count||0} message(s)`;
        }else{
          requestStatus.textContent = `error: ${j.error||'failed'}`;
        }
      }else{
        if (j.ok && j.mode === 'pat_async'){
          requestStatus.textContent = `queued ${j.enqueued||0} message(s) at ${j.requested_at||''}`;
        } else if (j.ok){
          const ok = (j.results||[]).filter(x=>x.ok).length;
          requestStatus.textContent = `sent ${ok}/${j.count||0} at ${j.requested_at||''}`;
        } else {
          requestStatus.textContent = `error: ${j.error||'failed'}`;
        }
      }
    }catch(e){
      requestStatus.textContent = 'error';
    }finally{
      requestBtn.disabled = false;
    }
  });

  // -------------------- METAR/TAF panel logic --------------------
  const metarToggle = $('#metar-toggle');
  const metarPanel  = $('#metar-panel');
  const metarIds    = $('#metar-ids');
  const metarFetch  = $('#metar-fetch');
  const metarCompose= $('#metar-compose');
  const metarPasteToggle = $('#metar-paste-toggle');
  const metarPasteForm   = $('#metar-paste-form');
  const metarPasteText   = $('#metar-paste-text');
  const metarPasteSave   = $('#metar-paste-save');
  const metarStatus      = $('#metar-status');
  const metarList        = $('#metar-list');
  const metarTableBody   = document.querySelector('#metar-table tbody');
  const metarViewScope   = $('#metar-view-scope');
  const metarShowDecoded = $('#metar-show-decoded');
  const metarUnhideAll   = $('#metar-unhide-all');
  const metarHideExpired = $('#metar-hide-expired');

  const STORAGE_HIDE = 'metar_taf_hidden';
  const METAR_EXPIRE_MIN = 60;

  function getHiddenSet(){
    try{ return new Set(JSON.parse(localStorage.getItem(STORAGE_HIDE) || '[]')); }catch(_){ return new Set(); }
  }
  function setHiddenSet(s){
    try{ localStorage.setItem(STORAGE_HIDE, JSON.stringify(Array.from(s))); }catch(_){}
  }

  function normIds(text){
    return (text||'')
      .toUpperCase()
      .split(/[^A-Z0-9]+/)
      .map(s=>s.trim())
      .filter(s=>/^[A-Z0-9]{3,4}$/.test(s));
  }

  // Extract all (ICAO, tmsUTC) pairs from METAR lines within a raw payload
  // anchorDateStr: optional ISO8601 string (e.g., fetched_at_utc) to anchor month/year inference
  function extractMetarTimes(raw, anchorDateStr){
    if (!raw) return [];
    const out = [];
    // e.g. "METAR KPSC 260553Z ..."
    const re = /^(?:METAR|SPECI)\s+([A-Z0-9]{3,4})\s+(\d{2})(\d{2})(\d{2})Z/mg;
    let m;
    while ((m = re.exec(raw)) !== null){
      const icao = m[1];
      const dd = parseInt(m[2],10), hh = parseInt(m[3],10), mm = parseInt(m[4],10);
      const tms = anchorDayToUtc(dd, hh, mm, anchorDateStr);
      if (tms != null) out.push({icao, tms});
    }
    return out;
  }

  // Convert DD,HH,MM (Zulu) to epoch ms anchored to a reference date's UTC month/year (with wrap near month edges)
  // anchorDateStr: optional ISO8601 string to use as reference instead of "now"
  function anchorDayToUtc(dd, hh, mm, anchorDateStr){
    // Use the provided anchor date or fall back to now
    let anchor;
    if (anchorDateStr) {
      anchor = new Date(anchorDateStr);
      if (isNaN(anchor.getTime())) anchor = new Date();
    } else {
      anchor = new Date();
    }
    const y = anchor.getUTCFullYear(), mon = anchor.getUTCMonth(), anchorDay = anchor.getUTCDate();
    let y2 = y, mon2 = mon;
    if ((dd - anchorDay) > 15){           // likely previous month
      if (mon2 === 0){ mon2 = 11; y2 = y - 1; } else { mon2 -= 1; }
    } else if ((anchorDay - dd) > 15){    // likely next month
      if (mon2 === 11){ mon2 = 0; y2 = y + 1; } else { mon2 += 1; }
    }
    // Guard DD in [1..31]
    if (!(dd >= 1 && dd <= 31)) return null;
    return Date.UTC(y2, mon2, dd, hh, mm, 0, 0);
  }

  // Build a map of latest METAR time per ICAO across a set of rows
  function latestMapForRows(rows){
    const latest = new Map();
    (rows||[]).forEach(rec=>{
      // Use the record's fetch time as anchor for proper month/year inference
      const pairs = extractMetarTimes(rec.raw_text||"", rec.fetched_at_utc);
      for (const {icao, tms} of pairs){
        const prev = latest.get(icao) || 0;
        if (tms > prev) latest.set(icao, tms);
      }
    });
    return latest;
  }

  // A record is expired if EVERY METAR inside it is >60 min old OR older than the newest seen for that ICAO.
  function recordExpired(rec, latestMap){
    // Use the record's fetch time as anchor for proper month/year inference
    const pairs = extractMetarTimes(rec.raw_text||"", rec.fetched_at_utc);
    if (!pairs.length) return false; // no METAR time → do not mark expired
    const nowMs = Date.now();
    let anyFresh = false;
    for (const {icao, tms} of pairs){
      const ageMin = (nowMs - tms) / 60000;
      const newer = (latestMap.get(icao)||0) > tms;
      const expired = (ageMin > METAR_EXPIRE_MIN) || newer;
      if (!expired){ anyFresh = true; break; }
    }
    return !anyFresh;
  }

  let _metarRowsCache = [];  // keep last full set for "Hide expired"

  async function loadMetarList(){
    // Always include plain-English (we'll keep the checkbox in UI for now)
    const r = await fetch(`/api/weather/metar_taf/list?decode=1`);
    const j = await r.json().catch(()=>({ok:false}));
    if (!j.ok){ return; }
    const hidden = getHiddenSet();
    const rows = j.items || [];
    _metarRowsCache = rows.slice(); // cache for Hide-expired action
    const last = rows.slice(0,4);

    function renderRow(rec){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      tr.dataset.id = rec.id;
      td.style.padding = '8px 10px';
      td.style.verticalAlign = 'top';

      // Header bar
      const hdr = document.createElement('div');
      hdr.className = 'wx-row two';
      hdr.style.alignItems = 'center';

      const meta = document.createElement('div');
      meta.className = 'muted';
      const idsStr = Array.isArray(rec.ids) ? rec.ids.join(', ') : '';
      const method = String(rec.method||'').toUpperCase();
      // Expired badge
      const latestMap = latestMapForRows(_metarRowsCache);
      const expired = recordExpired(rec, latestMap);
      meta.innerHTML = `#${rec.id} • ${rec.fetched_at_utc} • ${method} • ${idsStr}` +
        (expired ? ` • <span class="wx-expired">EXPIRED</span>` : ``);

      const actions = document.createElement('div');
      actions.className = 'wx-inline-row';
      actions.style.justifyContent = 'flex-end';
      actions.style.gap = '.5rem';
      const btnTog = document.createElement('button');
      btnTog.type='button'; btnTog.className='button small'; btnTog.dataset.toggle = String(rec.id); btnTog.textContent='Expand';
      const btnHide = document.createElement('button');
      btnHide.type='button'; btnHide.className='button small'; btnHide.dataset.hide = String(rec.id); btnHide.textContent = 'Hide';
      actions.append(btnTog, btnHide);
      hdr.append(meta, actions);

      // Body block (raw + optional plain-English)
      const pre = document.createElement('pre');
      pre.className = 'metar-pre';
      pre.style.display = 'none';
      pre.style.margin = '.5rem 0 0';
      pre.style.whiteSpace = 'pre-wrap';
      pre.style.overflowWrap = 'anywhere';
      pre.textContent = rec.raw_text || '';

      const plain = (rec.plain||'').trim();
      if (plain){
        const det = document.createElement('details');
        det.open = true; // expanded by default
        det.style.marginTop = '.5rem';
        const sum = document.createElement('summary');
        sum.textContent = 'Plain-English';
        const pre2 = document.createElement('pre');
        pre2.style.whiteSpace = 'pre-wrap';
        pre2.style.overflowWrap = 'anywhere';
        pre2.textContent = plain;
        det.append(sum, pre2);
        pre.appendChild(det);
      }

      td.append(hdr, pre);
      tr.appendChild(td);
      return tr;
    }

    const scope = metarViewScope?.value || 'last';
    // Filter hidden completely out of the list
    const base = (scope === 'last') ? last : rows;
    const list = base.filter(rec => !hidden.has(rec.id));

    metarTableBody.innerHTML = '';
    if (!list.length){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.className = 'muted';
      td.textContent = 'no requests yet';
      tr.appendChild(td);
      metarTableBody.appendChild(tr);
      return;
    }
    list.forEach(rec => metarTableBody.appendChild(renderRow(rec)));
  }

  metarList.addEventListener('click', (e)=>{
    const btn = e.target.closest('button'); if (!btn) return;
    if (btn.dataset.toggle){
      const id = btn.dataset.toggle;
      const row = metarTableBody.querySelector(`tr[data-id="${id}"]`);
      const pre = row?.querySelector('.metar-pre');
      if (!pre) return;
      const open = pre.style.display !== 'none';
      pre.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Expand' : 'Collapse';
    } else if (btn.dataset.hide){
      const id = parseInt(btn.dataset.hide, 10);
      const hidden = getHiddenSet();
      hidden.add(id);
      setHiddenSet(hidden);
      // Remove immediately without a full reload
      const row = metarTableBody.querySelector(`tr[data-id="${id}"]`);
      row?.remove();
      if (!metarTableBody.children.length) loadMetarList();
    }
  });

  metarUnhideAll?.addEventListener('click', ()=>{
    setHiddenSet(new Set());
    loadMetarList();
  });

  metarHideExpired?.addEventListener('click', ()=>{
    const hidden = getHiddenSet();
    const latest = latestMapForRows(_metarRowsCache);
    (_metarRowsCache||[]).forEach(rec => {
      if (recordExpired(rec, latest)) hidden.add(rec.id);
    });
    setHiddenSet(hidden);
    loadMetarList();
  });

  metarViewScope?.addEventListener('change', loadMetarList);
  metarShowDecoded?.addEventListener('change', loadMetarList);

  metarToggle?.addEventListener('click', ()=>{
    const open = metarPanel.style.display !== 'none';
    if (open){
      metarPanel.style.display = 'none';
    } else {
      metarPanel.style.display = 'block';
      loadMetarList();
    }
  });

  metarPasteToggle?.addEventListener('click', ()=>{
    metarPasteForm.style.display = (metarPasteForm.style.display === 'none') ? 'block' : 'none';
  });

  metarPasteForm?.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const raw = metarPasteText.value || '';
    if (!raw.trim()){
      window.showToast?.('Nothing to save', 'error', 2500);
      return;
    }
    metarPasteSave.disabled = true;
    metarStatus.textContent = 'saving…';
    try{
      const r = await fetch('/api/weather/metar_taf/store', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        // IDs are auto-extracted on the server
        body: JSON.stringify({ raw_text: raw })
      });
      const j = await r.json();
      if (j.ok){
        metarStatus.textContent = `saved #${j.id}`;
        metarPasteText.value = '';
        loadMetarList();
      } else {
        window.showToast?.(`Error: ${j.error||'failed'}`, 'error', 3500);
        metarStatus.textContent = `error`;
      }
    }catch(_){ metarStatus.textContent = 'error'; }
    finally{ metarPasteSave.disabled = false; setTimeout(()=> metarStatus.textContent='', 1500); }
  });

  metarFetch?.addEventListener('click', async ()=>{
    const ids = normIds(metarIds.value);
    if (!ids.length){
      window.showToast?.('Enter at least one ICAO (e.g., KPSC)', 'error', 3000);
      metarIds?.focus();
      return;
    }
    metarFetch.disabled = true; metarStatus.textContent = 'fetching…';
    try{
      const r = await fetch('/api/weather/metar_taf/fetch', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ ids })
      });
      const j = await r.json();
      if (j.ok){
        metarStatus.textContent = `saved #${j.id}`;
        loadMetarList();
      } else {
        window.showToast?.(`Error: ${j.error||'failed'}`, 'error', 3500);
        metarStatus.textContent = `error`;
      }
    }catch(_){ metarStatus.textContent = 'error'; }
    finally{ metarFetch.disabled = false; setTimeout(()=> metarStatus.textContent='', 1500); }
  });

  // Prepare via Winlink → one message per ICAO, each body has a single URL
  metarCompose?.addEventListener('click', ()=>{
    const ids = normIds(metarIds.value);
    if (!ids.length){
      window.showToast?.('Enter at least one ICAO (e.g., KPSC)', 'error', 3000);
      metarIds?.focus();
      return;
    }
    const base = 'https://aviationweather.gov/api/data/metar';
    const msgs = ids.map(id=>{
      const params = new URLSearchParams({ ids: id, hours: '0', sep: 'true', taf: 'true' });
      return { to:'INQUIRY', subject:'REQUEST', body: `${base}?${params.toString()}` };
    });
    renderPreview(msgs);
  });

  // Auto-refresh every 15s; incremental updates avoid flicker
  setInterval(async ()=>{
    try { await syncCatalog(); } catch(_) {}
  }, 15000);

  // Intercept uploads → POST via fetch and refresh cards
  root.addEventListener('submit', async (e)=>{
    const form = e.target;
    if (!form.matches('form[data-wx-upload="1"]')) return;
    e.preventDefault();
    try{
      const fd = new FormData(form);
      const r = await fetch(form.action, {
        method: 'POST',
        body: fd,
        headers: csrf ? {'X-CSRFToken': csrf} : undefined
      });
      const j = await r.json().catch(()=> ({}));
      if (j && j.ok){
        await syncCatalog();
      }else{
        console.warn('Upload failed', j);
      }
    }catch(err){
      console.error('Upload error', err);
    }
  });

  // -------------------- Winlink Poll Timer --------------------
  // Same pattern as radio.html: /winlink/poller_status
  const pollWrap = $('#winlink-poll-wrap');
  const pollSecs = $('#winlink-poll-secs');
  let pollSecondsRemaining = null;

  function tick() {
    if (!pollWrap || !pollSecs) return;
    if (pollSecondsRemaining == null) {
      pollWrap.style.display = 'none';
      return;
    }
    if (pollSecondsRemaining > 0) {
      pollSecondsRemaining -= 1;
      pollSecs.textContent = String(pollSecondsRemaining);
      pollWrap.style.display = 'inline';
    } else {
      // Poll likely just fired — resync to get the next window
      syncPollStatus();
    }
  }

  async function syncPollStatus() {
    try {
      const r = await fetch('/winlink/poller_status', { cache: 'no-store' });
      if (!r.ok) return;
      const j = await r.json();
      if (j.running && typeof j.seconds === 'number') {
        pollSecondsRemaining = j.seconds;
        if (pollSecs) pollSecs.textContent = String(pollSecondsRemaining);
        if (pollWrap) pollWrap.style.display = 'inline';
      } else {
        pollSecondsRemaining = null;
        if (pollWrap) pollWrap.style.display = 'none';
      }
    } catch (_) {
      pollSecondsRemaining = null;
    }
  }

  // Same pattern as radio.html: sync every 10s, tick every 1s
  syncPollStatus();
  setInterval(tick, 1000);
  setInterval(syncPollStatus, 10000);
})();
</script>

<script>
(function(){
  // Pick best stream format that the browser can play; fall back to WAV.
  function detectStreamFmt(){
    const a = document.createElement('audio');
    if (a && typeof a.canPlayType === 'function') {
      if (a.canPlayType('audio/ogg; codecs="opus"')) return 'ogg';
      if (a.canPlayType('audio/webm; codecs=opus')) return 'webm';
    }
    return 'wav';
  }
  const $ = s => document.querySelector(s);
  const panel = $('#same-panel');
  const panelBody = $('#same-panel-body');
  const toggleBtn = $('#same-toggle');
  const badge = $('#same-badge');
  const STORAGE_SEEN = 'same_last_seen';
  let showHidden = false;
  const STREAM_FMT = detectStreamFmt();  // 'ogg' | 'webm' | 'wav'

  function renderPanelShell(){
    panelBody.innerHTML = `
      <div class="wx-toolbar" style="gap:.5rem; flex-wrap:wrap;">
        <div>
          <button id="same-start" type="button">Start SAME</button>
          <button id="same-stop"  type="button">Stop SAME</button>
          <span id="same-status" class="wx-status"></span>
          <button id="same-refresh" type="button" style="margin-left:.5rem;">Refresh</button>
        </div>
        <div style="margin-left:auto; display:flex; align-items:center; gap:.75rem;">
          <label class="wx-inline"><input id="same-show-hidden" type="checkbox"> show hidden</label>
          <button id="same-mark-read" type="button" title="Mark newest as seen">Mark read</button>
        </div>
      </div>

      <!-- Live Monitor -->
      <div class="wx-toolbar" style="gap:.5rem; flex-wrap:wrap;">
        <div id="same-mon-chans"></div>
        <div style="margin-left:auto; display:flex; gap:.5rem;">
          <button id="same-audio-start" type="button">Start audio</button>
          <button id="same-mon-stop" type="button">Stop audio</button>
        </div>
      </div>
      <audio id="same-audio" controls preload="none" style="width:100%;max-width:520px;display:block;margin:.25rem 0 1rem;"></audio>

      <table id="same-table" class="table">
        <thead>
          <tr><th>Received (UTC)</th><th>Freq</th><th>Event</th><th>Areas</th><th>Header</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
    `;

    // Wire buttons
    const status = $('#same-status');
    const tBody = $('#same-table tbody');
    const btnStart = $('#same-start');
    const btnStop  = $('#same-stop');
    const btnRef   = $('#same-refresh');
    const btnMark  = $('#same-mark-read');
    const chkHidden= $('#same-show-hidden');
    const audio    = $('#same-audio');
    const monList  = $('#same-mon-chans');
    const monStop  = $('#same-mon-stop');

    async function loadAlerts(){
      const r = await fetch(`/api/weather/alerts?n=50&include_hidden=${showHidden?1:0}`);
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      const run = j.status?.running ? 'listening' : 'stopped';
      const mode = j.status?.mode || '';
      status.textContent = `${run} (${mode})`;
      const rows = (j.alerts||[]).map(a=>{
        const d = a.decoded || {};
        const event = d.event || d.EEE || (d.text||'');
        const areas = Array.isArray(d?.areas) ? d.areas.join(',') :
                      (Array.isArray(d?.FIPS) ? d.FIPS.join(',') : '');
        const mhz = (a.frequency_mhz!=null)? a.frequency_mhz.toFixed(3) : '';
        const action = a.is_hidden
          ? `<button data-unhide="${a.id}" class="button small">Restore</button>`
          : `<button data-hide="${a.id}" class="button small">Hide</button>`;
        const muted = a.is_hidden ? ' style="opacity:.5;"' : '';
        return `<tr${muted}>
          <td>${a.received_at_utc||''}</td>
          <td>${mhz}</td>
          <td>${event}</td>
          <td>${areas}</td>
          <td><code style="font-size:.85em">${a.header}</code></td>
          <td>${action}</td>
        </tr>`;
      }).join('');
      tBody.innerHTML = rows || `<tr><td colspan="6" class="muted">no alerts yet</td></tr>`;

      // NEW badge logic
      const latest = j.latest_utc || '';
      const lastSeen = localStorage.getItem(STORAGE_SEEN) || '';
      if (latest && (!lastSeen || latest > lastSeen)){
        badge.style.display = 'inline-block';
      } else {
        badge.style.display = 'none';
      }
      // Expose to base template (navbar) to clear red state when marked
      window.__sameLatest = latest;
    }

    // Hide/unhide actions
    tBody.addEventListener('click', async (e)=>{
      const btn = e.target.closest('button');
      if (!btn) return;
      if (btn.dataset.hide || btn.dataset.unhide){
        const id = parseInt(btn.dataset.hide || btn.dataset.unhide, 10);
        const hide = !!btn.dataset.hide;
        await fetch('/api/weather/alerts/hide', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({id, hide})
        });
        loadAlerts();
      }
    });

    // Monitor UI
    async function loadChans(){
      const r = await fetch('/api/weather/same/channels');
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      monList.innerHTML = '';
      (j.channels||[]).forEach((c)=>{
        const b = document.createElement('button');
        b.type='button';
        b.textContent = `${c.freq_mhz.toFixed(3)} MHz`;
        b.addEventListener('click', ()=>{
          // Ensure clean handoff to new stream to avoid UA aborts
          try { audio.pause(); } catch(_) {}
          try { audio.removeAttribute('src'); audio.load(); } catch(_) {}
          // cache-bust so the browser doesn’t reuse a half-open connection
          const ts = Date.now();
          audio.src = `/api/weather/same/stream?ch=${c.ch}&fmt=${STREAM_FMT}&ts=${ts}`;
          audio.play().catch(()=>{ /* ignore autoplay/gesture errors */ });
        });
        monList.appendChild(b);
      });
    }
    monStop.addEventListener('click', ()=>{
      audio.pause(); audio.removeAttribute('src'); audio.load();
    });
    loadChans();

    // Manual "Start audio" button (satisfies autoplay policies & helps testing)
    const btnAudioStart = $('#same-audio-start');
    btnAudioStart?.addEventListener('click', ()=>{
      try { audio.muted = false; } catch(_) {}
      try { audio.volume = 1; } catch(_) {}
      if (!audio.src) {
        const ts = Date.now();
        audio.src = `/api/weather/same/stream?ch=0&fmt=${STREAM_FMT}&ts=${ts}`;
      }
      audio.play().catch(()=>{
        // On failure (e.g., libopus missing or UA quirk), try WAV once.
        if (!/fmt=wav/.test(audio.src)) {
          try { audio.pause(); } catch(_) {}
          try { audio.removeAttribute('src'); audio.load(); } catch(_) {}
          const ts2 = Date.now();
          audio.src = `/api/weather/same/stream?ch=0&fmt=wav&ts=${ts2}`;
          audio.play().catch(()=>{});
        }
      });
    });

    // Panel controls
    btnStart?.addEventListener('click', async ()=>{ await fetch('/api/weather/same/start', {method:'POST'}); loadAlerts(); });
    btnStop ?.addEventListener('click', async ()=>{ await fetch('/api/weather/same/stop',  {method:'POST'}); loadAlerts(); });
    btnRef  ?.addEventListener('click', loadAlerts);
    chkHidden?.addEventListener('change', ()=>{ showHidden = !!chkHidden.checked; loadAlerts(); });
    btnMark ?.addEventListener('click', ()=>{
      const ts = window.__sameLatest || new Date().toISOString();
      localStorage.setItem(STORAGE_SEEN, ts);
      badge.style.display = 'none';
      if (typeof window.__sameMarkSeen === 'function') window.__sameMarkSeen(ts);
    });

    loadAlerts();
    // Keep updating while panel is open
    panel._sameTimer && clearInterval(panel._sameTimer);
    panel._sameTimer = setInterval(loadAlerts, 10000);
  }

  // Toggle handler
  toggleBtn.addEventListener('click', ()=>{
    const open = panel.style.display !== 'none';
    if (open){
      panel.style.display = 'none';
      if (panel._sameTimer) { clearInterval(panel._sameTimer); panel._sameTimer = null; }
    }else{
      panel.style.display = 'block';
      renderPanelShell();
      // mark seen immediately on open (UX: you saw the panel)
      const ts = window.__sameLatest || new Date().toISOString();
      localStorage.setItem(STORAGE_SEEN, ts);
      badge.style.display = 'none';
      if (typeof window.__sameMarkSeen === 'function') window.__sameMarkSeen(ts);
    }
  });

  // Background poll to update NEW badge while collapsed
  async function pollHead(){
    try{
      const r = await fetch('/api/weather/alerts/head');
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      const latest = j.latest || '';
      window.__sameLatest = latest;
      const lastSeen = localStorage.getItem(STORAGE_SEEN) || '';
      badge.style.display = (latest && (!lastSeen || latest > lastSeen)) ? 'inline-block' : 'none';
    }catch(_){}
  }
  setInterval(pollHead, 20000);
})();
</script>
{% endblock %}
