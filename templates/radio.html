{% extends "base.html" %}
{% block title %}Radio Operator Out-box – Aircraft Ops{% endblock %}

{% block content %}

<div class="page-header-bar">
  <span class="page-title">
    Radio Operator Outbox
    (Hosted at: http://ops.lan — fallback http://192.168.8.2:5150)
  </span>
  <span id="clock" class="clock">00:00:00</span>
</div>

{# ── WinLink controls ─────────────────────────────────────────── #}
<div class="winlink-controls" style="display:flex; gap:0.5rem; align-items:center; margin:1rem 0;">
  <form method="POST"
        id="winlink-poll-form"
        action="{{ url_for('winlink.winlink_start') if not winlink_job_active else url_for('winlink.winlink_stop') }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <button type="submit"
            class="btn btn-{{ 'success' if not winlink_job_active else 'danger' }}">
      {{ 'Start WinLink Polling' if not winlink_job_active else 'Stop WinLink Polling' }}
    </button>
  </form>

  <form method="POST"
        action="{{ url_for('winlink.winlink_auto_start') if not winlink_auto_active else url_for('winlink.winlink_auto_stop') }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <button type="submit"
            class="btn btn-{{ 'success' if not winlink_auto_active else 'danger' }}">
      {{ 'Start Auto-WinLink-Send' if not winlink_auto_active else 'Stop Auto-WinLink-Send' }}
    </button>
  </form>

   <a href="{{ url_for('winlink.winlink_inbox') }}" class="btn btn-secondary">
     📥 WinLink Inbox
     <span id="wl-unread-badge" class="wl-unread-badge" style="display:none;">
       UNREAD EMAILS: 0
     </span>
   </a>

   {# Poller countdown (visible only when poller job is active) #}
   <span id="wl-poll-eta"
         class="muted"
         style="margin-left:.5rem; display: {{ 'inline-block' if winlink_job_active else 'none' }};">
     Next poll in
     <strong><span id="wl-poll-remaining">
       {{ winlink_poll_seconds if winlink_job_active and winlink_poll_seconds is not none else '' }}
     </span></strong>s
   </span>
</div>

<div id="radio-table">
  {# initial table render #}
{% include 'partials/_radio_table.html' %}
</div>

<p style="margin-top:12px; font-size:0.9em;">
  <small>* ETA (open outbound)</small>
</p>

<h3>Log Incoming Winlink Message</h3>
<form method="POST" id="incoming-form">
  <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
  <label>Subject Line:</label>
  <input
    type="text"
    name="subject"
    style="width:100%;"
    placeholder="Paste subject here (e.g. Air Ops: N12345 | KSBP to KLAX | took off HHMM | ETA HHMM)…"
    required>
  <label style="margin-top:12px">Message Body:</label>
  <textarea
    name="body"
    style="width:100%;"
    placeholder="Paste full message body here…"></textarea>
  <button type="submit" style="margin-top:8px">Submit Incoming</button>
</form>

<div id="incoming-feedback-container"></div>

<!-- AOCT Reply modal (hidden by default) -->
<div id="aoct-modal" class="modal" style="display:none;">
  <div class="modal-window">
    <button type="button" class="close-modal" id="aoct-close" title="Close">×</button>
    <h3 style="margin:0 0 .5rem;">AOCT reply ready</h3>
    <div class="radio-content-box" style="margin-top:.5rem;">
      <label class="muted">Subject</label>
      <textarea id="aoct-subj" rows="2" style="width:100%;"></textarea>
    </div>
    <button type="button" id="aoct-copy-subj">Copy Subject</button>
    <span id="aoct-fb-subj" class="copy-feedback"></span>

    <div class="radio-content-box" style="margin-top:1rem;">
      <label class="muted">Body</label>
      <textarea id="aoct-body" rows="10" style="width:100%;"></textarea>
    </div>
    <button type="button" id="aoct-copy-body">Copy Body</button>
    <span id="aoct-fb-body" class="copy-feedback"></span>

    <div class="lookup-row" style="gap:.5rem; align-items:center; margin-top:1rem;">
      <label for="aoct-to" style="min-width:2rem;">To:</label>
      <input id="aoct-to" type="text"
             placeholder="W7WEK, K7ABC; N0CALL"
             title="Separate multiple with commas, spaces, or semicolons"
             style="flex:1;"
             oninput="this.value=this.value.toUpperCase()">
      <button id="aoct-send" class="btn btn-secondary" title="Send via PAT">Send via PAT</button>
    </div>
  </div>
</div>

<script>
function normalizeHHMM(t){
  if (!t) return '';
  const digits = String(t).replace(/[^0-9]/g, '');
  return digits ? digits.padStart(4,'0').slice(-4) : 'TBD';
}
</script>

<script>
// Strip the standard DART footer if it was accidentally captured as remarks
function stripDartFooter(s){
  if (!s) return s;
  // Truncate at the footer line (don't just delete the line).
  const lines = String(s).split(/\r?\n/);
  const out = [];
  const re = /^\s*\{DART\s+Aircraft\s+Takeoff\s+Report[^}]*\}\s*$/i;
  for (const ln of lines){
    if (re.test(ln)) break;
    out.push(ln);
  }
  return out.join('\n').trim();
}
</script>

<script>
  // Base URL for Remote Airports page (WinLink route renders the same template)
  const REMOTE_AIRPORTS_BASE = "{{ url_for('inventory.remote_airports') }}";
</script>

<script>
  // 1) Every 30s, re-fetch only the radio table
  setInterval(async () => {
    const resp = await fetch('{{ url_for("radio.radio_table_partial") }}');
    if (!resp.ok) return;
    document.getElementById('radio-table').innerHTML = await resp.text();
  }, 30000);

  // 2) Incoming-form handling (now colours by server-supplied “action”)
  const incomingForm = document.getElementById('incoming-form');
  const feedbackBox  = document.getElementById('incoming-feedback-container');

  incomingForm.addEventListener('submit', async e => {
    e.preventDefault();
    const formData = new FormData(incomingForm);

    // POST to server
    const resp = await fetch(window.location.href, {
      method: incomingForm.method,
      headers: { 'X-Requested-With':'XMLHttpRequest' },
      body: formData
    });
    if (!resp.ok) return alert('Failed to log incoming.');
    const srvJson = await resp.json();          // contains .action and .id

    // AOCT: if server prepared a reply for a QUERY, show copy-ready fields (and optional PAT send)
    if (srvJson?.action === 'aoct_query_reply') {
      // Populate modal fields
      const subj = srvJson.subject || 'AOCT cargo reply';
      const body = srvJson.body || '';
      const toHint = (srvJson.to_hint || '').toUpperCase();
      const canSend = !!srvJson.can_send;
      document.getElementById('aoct-subj').value = subj;
      document.getElementById('aoct-body').value = body;
      document.getElementById('aoct-to').value   = toHint;
      const sendBtn = document.getElementById('aoct-send');
      sendBtn.disabled = !canSend;
      if (!canSend) sendBtn.title = 'PAT not configured';

      // Open modal
      const modal = document.getElementById('aoct-modal');
      modal.style.display = 'flex';

      // Wire close actions (X, ESC, backdrop)
      const close = ()=>{ modal.style.display='none'; };
      document.getElementById('aoct-close').onclick = close;
      modal.addEventListener('click', (ev)=>{ if (ev.target === modal) close(); });
      document.addEventListener('keydown', function onEsc(ev){
        if (ev.key === 'Escape'){ close(); document.removeEventListener('keydown', onEsc); }
      });

      // Harmonized copy behavior (same UX as Send Flight page)
      function copyFrom(elId, fbId){
        const el = document.getElementById(elId);
        const text = (el?.value ?? el?.innerText ?? el?.textContent ?? '').toString();
        const fb = document.getElementById(fbId);
        const showCheck = () => {
          fb.textContent = '✔ Copied!';
          fb.classList.add('visible');
          setTimeout(()=> fb.classList.remove('visible'), 1200);
        };
        // Guard: navigator.clipboard may be undefined on non-secure origins
        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          navigator.clipboard.writeText(text).then(showCheck).catch(()=> fallbackCopy(text, showCheck));
        } else {
          fallbackCopy(text, showCheck);
        }
      }
      function fallbackCopy(text, cb){
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        try { document.execCommand('copy'); } catch(_){}
        document.body.removeChild(ta);
        cb();
      }
      document.getElementById('aoct-copy-subj').onclick = ()=> copyFrom('aoct-subj','aoct-fb-subj');
      document.getElementById('aoct-copy-body').onclick = ()=> copyFrom('aoct-body','aoct-fb-body');

      // Send via PAT (ad-hoc)
      sendBtn.onclick = async ()=>{
        const to = document.getElementById('aoct-to').value.trim().toUpperCase();
        if (!to){ alert('Enter a destination callsign.'); return; }
        const fd = new URLSearchParams({
          to,
          subject: document.getElementById('aoct-subj').value,
          body:    document.getElementById('aoct-body').value
        });
        const r = await fetch('{{ url_for("radio.aoct_send") }}', {
          method: 'POST',
          headers: {'Content-Type':'application/x-www-form-urlencoded'},
          body: fd
        });
        const j = await r.json().catch(()=>({ok:false}));
        if (!r.ok || !j.ok){
          alert(j.message || 'PAT send failed.');
        } else {
          alert('AOCT reply sent via PAT.');
          close();
        }
      };

      incomingForm.reset();
      return;
    }

    // AOCT: if server ingested a remote snapshot, show a compact banner and stop.
    if (srvJson && typeof srvJson.action === 'string' && srvJson.action.startsWith('aoct_')) {
      if (srvJson.action === 'aoct_ingested') {
        const ap   = srvJson.airport || '';
        const rows = srvJson.rows ?? 0;
        const tot  = srvJson.total_lb ?? 0;
        feedbackBox.innerHTML = `
          <div class="radio-content-box">
            <strong>AOCT snapshot ingested</strong><br>
            Airport: ${ap || '(unknown)'} • Rows: ${rows} • Total: ${tot} lb<br>
            <a class="btn btn-secondary" href="${REMOTE_AIRPORTS_BASE}?airport=${encodeURIComponent(ap)}">
              Open Remote Airports
            </a>
          </div>`;
        setTimeout(() => { feedbackBox.innerHTML = ''; }, 15000);
      } else if (srvJson.action === 'aoct_flight_ingested') {
        const tail = srvJson.tail || '';
        const ap   = srvJson.airport || '';
        const ts   = srvJson.ts || '';
        feedbackBox.innerHTML = `
          <div class="radio-content-box" style="border:1px solid #9bd3ae; background:#f2fbf5;">
            <strong>AOCT flight reply ingested</strong><br>
            Tail: ${tail} • From: ${ap} • Sample: ${ts}<br>
            <a class="btn btn-secondary" href="/locates?tail=${encodeURIComponent(tail)}">Open Map</a>
          </div>`;
        setTimeout(() => { feedbackBox.innerHTML = ''; }, 15000);
      } else if (srvJson.action === 'aoct_flight_failed') {
        feedbackBox.innerHTML = `
          <div class="radio-content-box" style="border:1px solid #f0b7b7; background:#fff6f6;">
            <strong>AOCT flight reply could not be parsed.</strong>
          </div>`;
        setTimeout(() => { feedbackBox.innerHTML = ''; }, 12000);
      } else if (srvJson.action === 'aoct_query_ignored') {
        feedbackBox.innerHTML = `
          <div class="radio-content-box">
            AOCT query received. Paste the <em>AOCT cargo reply</em> or <em>AOCT cargo status</em> to ingest.
          </div>`;
        setTimeout(() => { feedbackBox.innerHTML = ''; }, 8000);
      } else {
        alert('AOCT message could not be ingested.');
      }
      incomingForm.reset();
      return; // don’t run the Air Ops parsing/feedback UI
    }

    // --- locally parse subject/body -----------------------------------
    /*--------------------------------------------------------------
      Normalise subject line before regex parsing
        • remove any number of leading
            "RE", "Re", "ack", "ACK", … optionally followed by ":"
          e.g.  "Re: RE ACK Air Ops: …"  →  "Air Ops: …"
    --------------------------------------------------------------*/
    const subjRaw = formData.get('subject').trim();
    const subj    = subjRaw
                      .replace(/^(?:\s*(?:RE|ACK)\s*:?\s*)+/i, '')   // strip once or many
                      .trim();
    const sm = new RegExp(
      String.raw`Air Ops:\s*([^|]+?)\s*\|\s*([^|]+?)\s*to\s*([^|]+?)\s*\|\s*` +
      String.raw`(?:` +
      String.raw`(?:took off|takeoff\s+estimate)\s*(\d{1,2}:?\d{2})\s*\|\s*ETA\s*(\d{1,2}:?\d{2})` +
      String.raw`|(?:took off|takeoff\s+estimate)\s*(\d{1,2}:?\d{2})\s*\|\s*landed\s*(\d{1,2}:?\d{2})` +
      String.raw`|landed\s*(\d{1,2}:?\d{2}))`,
      'i'
    );
    const bare = /Air Ops:\s*(\S+)\s*\|\s*landed\b/i.exec(subj);
    const body = formData.get('body');
    const ct   = /Cargo Type\(s\).*?\.{3,}\s*(.*)/i.exec(body);
    const cw   = /Total Weight of the Cargo.*?\.{3,}\s*(.*)/i.exec(body);

    const p = {
      tail_number:      sm?.[1]?.trim() || bare?.[1] || 'TBD',
      airfield_takeoff: sm?.[2]?.trim() || 'TBD',
      airfield_landing: sm?.[3]?.trim() || 'TBD',
      takeoff_time:     sm?.[4]?.trim().padStart(4,'0') || 'TBD',
      eta:              sm?.[5]?.trim().padStart(4,'0') || 'TBD',
      cargo_type:       ct?.[1]?.trim() || 'TBD',
      cargo_weight:     cw?.[1]?.trim() || 'TBD'
    };


    /* same post-clean as back-end */
    const clean = t => {
      if (!t) return '';
      let u = t.toUpperCase().trim();
      if (/^UNK(?:N|KNOWN)?$/.test(u)) return 'TBD';
      return u.replace(/\b(?:L|LOCAL)$/i, '').trim();
    };
    p.takeoff_time = normalizeHHMM(clean(p.takeoff_time));
    p.eta          = normalizeHHMM(clean(p.eta));

    // lookup existing flight for id/pilot/pax/remarks
    let id    = '—', pilot = '—', pax = '—', rem = '';
        prior = null;   // ← will hold the JSON row if it exists
    try {
      const lookup = await fetch(`/api/lookup_tail/${encodeURIComponent(p.tail_number)}`);
      if (lookup.ok) {
        prior = await lookup.json();
        id    = prior.id           ?? id;
        pilot = prior.pilot_name   || pilot;
        pax   = prior.pax_count    || pax;
        rem   = prior.remarks      || '';
      }
    } catch {}

    // detect landing vs in-flight
    const isLanding     = /\blanded\b/i.test(subj);
    const landMatch     = /\blanded\s*(\d{1,2}:?\d{2})/i.exec(subj);  // hhmm OR hh:mm
    const displayStatus = isLanding ? '🛬 Landed' : '✈️ In-Flight';
    const displayEta    = isLanding
                         ? (landMatch?.[1].padStart(4,'0') || 'TBD')
                         : (p.eta + '*');

    /* -----------------------------------------------------------
       Pick highlight purely from what the server tells us.
         new            → green
         updated        → blue
         update_ignored → grey
         anything else  → red   (parse-failure / nothing useful)
    ----------------------------------------------------------- */
    let rowClass = 'red-border';
    if      (srvJson.action === 'new')            rowClass = 'green-border';
    else if (srvJson.action === 'updated')        rowClass = 'blue-border';
    else if (srvJson.action === 'update_ignored') rowClass = 'grey-border';

    /* -----------------------------------------------------------
       Prefer the fresh row that just came back from the server
       (it has authoritative values), fall back to local parse.
       ── Field names match those used in the table below ──
    ----------------------------------------------------------- */
    const row = {
      id:               srvJson.id               ?? id,
      tail_number:      srvJson.tail_number      ?? p.tail_number,
      pilot_name:       srvJson.pilot_name       ?? pilot,
      pax_count:        srvJson.pax_count        ?? pax,
      airfield_takeoff: srvJson.airfield_takeoff ?? p.airfield_takeoff,
      takeoff_time:     srvJson.takeoff_time     ?? p.takeoff_time,
      airfield_landing: srvJson.airfield_landing ?? p.airfield_landing,
      eta:              srvJson.eta              ?? displayEta,
      cargo_type:       srvJson.cargo_type       ?? p.cargo_type,
      cargo_weight:     srvJson.cargo_weight     ?? p.cargo_weight,
      remarks:          stripDartFooter(srvJson.remarks ?? rem)
    };

    /* ── fallback: if everything important is blank/TBD, force RED ── */
    const allBlank = [
      row.tail_number,
      row.airfield_takeoff,
      row.airfield_landing,
      row.takeoff_time,
      row.eta,
      row.cargo_type,
      row.cargo_weight
    ].every(v => !v || v === 'TBD');
    if (allBlank) {
      rowClass = 'red-border';
      // If this is the first failure, open correction modal.
      if (!window._corrPending) {
        if (window.openCorrectionExamples) window.openCorrectionExamples();
      } else {
        // Second failure after a manual correction attempt — alert and clear fields.
        try {
          alert('Message failed to parse after manual correction. Clearing input.');
          const sEl = document.querySelector('#incoming-form input[name="subject"]');
          const bEl = document.querySelector('#incoming-form textarea[name="body"]');
          if (sEl) sEl.value = '';
          if (bEl) { bEl.value = ''; bEl.dispatchEvent(new Event('input', {bubbles:true})); }
        } catch (_) {}
        window._corrPending = false;
      }
    } else {
      // Parsed successfully — clear any pending correction flag so the next failure re-opens the modal.
      if (window._corrPending) window._corrPending = false;
    }

    feedbackBox.innerHTML = `
      <table id="incoming-feedback">
        <thead>
          <tr>
            <th>#</th><th class="status">Status</th><th>Tail #</th>
            <th>Pilot</th><th>PAX #</th><th>Origin</th>
            <th>Departure<br>HHMM</th><th>Destination</th>
            <th>ETA* / Arr HHMM</th><th>Cargo Type</th>
            <th>Cargo Wt</th><th>Remarks</th>
          </tr>
        </thead>
        <tbody>
          <tr class="${rowClass}">
            <td>${row.id           ?? id}</td>
            <td class="status">${displayStatus}</td>
            <td>${row.tail_number  ?? p.tail_number}</td>
            <td>${row.pilot_name   ?? pilot}</td>
            <td>${row.pax_count    ?? pax}</td>
            <td>${row.airfield_takeoff}</td>
            <td>${row.takeoff_time}</td>
            <td>${row.airfield_landing}</td>
            <td>${row.eta}</td>
            <td>${row.cargo_type   ?? p.cargo_type}</td>
            <td>${row.cargo_weight ?? p.cargo_weight}</td>
            <td>${row.remarks      ?? rem}</td>
          </tr>
        </tbody>
      </table>
    `;
    const fb = document.getElementById('incoming-feedback');
    setTimeout(() => fb.classList.add('show'),    20);
    setTimeout(() => fb.classList.remove('show'), 30200);
    setTimeout(() => feedbackBox.innerHTML = '',   30600);

    incomingForm.reset();
  });
</script>

<script>
  // clock updater
  function updateClock(){
    const now = new Date();
    const hh = String(now.getHours()).padStart(2,'0');
    const mm = String(now.getMinutes()).padStart(2,'0');
    const ss = String(now.getSeconds()).padStart(2,'0');
    document.getElementById('clock').textContent = `${hh}:${mm}:${ss}`;
  }
  setInterval(updateClock, 1000);
  updateClock();
</script>

<script>
  // auto-resize the body textarea
  (()=>{
    const ta = document.querySelector('#incoming-form textarea[name="body"]');
    if (!ta) return;
    const autoResize = e => {
      e.target.style.height = 'auto';
      e.target.style.height = e.target.scrollHeight + 'px';
    };
    ta.addEventListener('input', autoResize);
    autoResize({ target: ta });
  })();
</script>

<script>
// Intercept WinLink polling form for one-time poll/parse on start
const pollForm = document.getElementById('winlink-poll-form');
if (pollForm) {
  pollForm.addEventListener('submit', async function(e){
    // Only intercept on "Start" (not "Stop")
    if (pollForm.action.endsWith('{{ url_for("winlink.winlink_start") }}')) {
      e.preventDefault();
      // Fire one-time poll_now route with CSRF
      const CSRF_TOKEN = '{{ csrf_token() }}';
      await fetch('/winlink/poll_now', {
        method: 'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: new URLSearchParams({'csrf_token': CSRF_TOKEN})
      });
      // Actually submit form to start normal polling
      pollForm.submit();
    }
    // otherwise (stopping), let normal form submit happen
  });
}
</script>

<script>
// --- Unread badge updater (every 30s) — read cookie directly ---
// Cookie name shared with WinLink Inbox page
const WL_COOKIE = 'winlink_emails_read';

function getCookie(name){
  const m = document.cookie.match(new RegExp('(?:^|;\\s*)' + name.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\$&') + '=([^;]*)'));
  return m ? decodeURIComponent(m[1]) : '';
}
function mergeRanges(ranges){
  if (!ranges.length) return [];
  ranges.sort((a,b)=> (a[0]-b[0]) || (a[1]-b[1]));
  const out=[ranges[0].slice()];
  for (let i=1;i<ranges.length;i++){
    const [s,e]=ranges[i], last=out[out.length-1];
    if (s<=last[1]+1) last[1]=Math.max(last[1],e);
    else out.push([s,e]);
  }
  return out;
}
function parseRanges(str){
  if (!str) return [];
  const parts=str.split(',').map(s=>s.trim()).filter(Boolean);
  const ranges=[];
  for(const p of parts){
    if (/^\d+$/.test(p)){ const v=+p; ranges.push([v,v]); }
    else{
      const m=p.match(/^(\d+)-(\d+)$/);
      if (m){ const a=+m[1], b=+m[2]; ranges.push([Math.min(a,b), Math.max(a,b)]); }
    }
  }
  return mergeRanges(ranges);
}
function contains(ranges, id){
  id = +id; return ranges.some(([s,e]) => id>=s && id<=e);
}

async function refreshUnreadBadge(){
  try{
    // 1) fetch current inbox (IDs only are all we need; using existing endpoint)
    const resp = await fetch('{{ url_for("winlink.winlink_inbox_json") }}', { cache:'no-store' });
    if (!resp.ok) return;
    const msgs = await resp.json();
    const ids  = Array.isArray(msgs) ? msgs.map(m => +m.id).filter(Number.isFinite) : [];

    // 2) read and parse the read-ranges cookie
    const ranges = parseRanges(getCookie(WL_COOKIE) || '');

    // 3) compute unread = ids not contained in ranges
    let unread = 0;
    for (const id of ids){
      if (!contains(ranges, id)) unread++;
    }

    // 4) update badge
    const badge = document.getElementById('wl-unread-badge');
    if (!badge) return;
    if (unread > 0){
      badge.textContent = 'Unread messages: ' + unread;
      badge.style.display = 'inline-block';
    } else {
      badge.style.display = 'none';
    }
  } catch (_) {
    /* ignore */
  }
}
refreshUnreadBadge();
setInterval(refreshUnreadBadge, 30000);
</script>

<!-- WinLink poller countdown (kept in sync with server every 10s) -->
<script>
(function(){
  const wrap = document.getElementById('wl-poll-eta');
  const num  = document.getElementById('wl-poll-remaining');
  let secs   = (num && /^\d+$/.test(num.textContent.trim())) ? parseInt(num.textContent.trim(), 10) : null;

  async function sync(){
    try{
      const r = await fetch('{{ url_for("radio.winlink_poller_status") }}', { cache: 'no-store' });
      if (!r.ok) return;
      const j = await r.json();
      if (j.running){
        if (wrap) wrap.style.display = 'inline-block';
        if (typeof j.seconds === 'number'){
          secs = j.seconds;
          if (num) num.textContent = String(secs);
        }
      } else {
        if (wrap) wrap.style.display = 'none';
        secs = null;
      }
    } catch (_){}
  }

  function tick(){
    if (!wrap || wrap.style.display === 'none') return;
    if (secs == null){ sync(); return; }
    if (secs > 0){
      secs -= 1;
      if (num) num.textContent = String(secs);
    } else {
      // Poll likely just fired — resync to get the next window
      sync();
    }
  }

  // Kick off
  sync();
  setInterval(tick, 1000);
  setInterval(sync, 10000);
})();
</script>

{# Manual-correction modal + client script #}
{% include 'partials/_correction_modal.html' %}
<script src="{{ url_for('static', filename='js/radio_correction.js') }}"></script>

<!-- WinLink controls: disable when no internet and show a toast if clicked -->
<script>
(function(){
  const scope = document.querySelector('.winlink-controls');
  if (!scope) return;

  const buttons = Array.from(scope.querySelectorAll('button'));
  const DISABLED_MSG = 'No internet detected — WinLink jobs disabled';

  function setEnabled(on){
    buttons.forEach(btn => {
      btn.disabled = !on;
      btn.title = on ? '' : DISABLED_MSG;
      btn.classList.toggle('btn-disabled', !on);
    });
  }

  // initialize from global if already known
  if (typeof window.__INET_ONLINE === 'boolean') {
    setEnabled(window.__INET_ONLINE);
  }

  // react to base.html heartbeat transitions
  window.addEventListener('inet-status', ev => {
    setEnabled(!!ev.detail?.online);
  });

  // intercept any clicks on disabled buttons to show a message
  scope.addEventListener('click', function(ev){
    const btn = ev.target.closest('button');
    if (!btn) return;
    if (btn.disabled){
      ev.preventDefault(); ev.stopPropagation();
      if (window.showToast) window.showToast(DISABLED_MSG, 'warning', 2500);
      else alert(DISABLED_MSG);
    }
  }, true);
})();
</script>

{% endblock %}
