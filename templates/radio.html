{% extends "base.html" %}
{% block title %}Radio Operator Out-box â€“ Aircraft Ops{% endblock %}

{% block content %}

<div class="page-header-bar">
  <span class="page-title">
    Radio Operator Outbox
    (Hosted at: {{ mdns_host_label }} â€” fallback {{ mdns_fallback_label }})
  </span>
  <span id="clock" class="clock">00:00:00</span>
</div>

{# â”€â”€ WinLink controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ #}
<div class="winlink-controls" style="display:flex; gap:0.5rem; align-items:center; margin:1rem 0;">
  <form method="POST"
        id="winlink-poll-form"
        action="{{ url_for('winlink.winlink_start') if not winlink_job_active else url_for('winlink.winlink_stop') }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <button type="submit"
            class="btn btn-{{ 'success' if not winlink_job_active else 'danger' }}">
      {{ 'Start WinLink Polling' if not winlink_job_active else 'Stop WinLink Polling' }}
    </button>
  </form>

  <form method="POST"
        action="{{ url_for('winlink.winlink_auto_start') if not winlink_auto_active else url_for('winlink.winlink_auto_stop') }}">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <button type="submit"
            class="btn btn-{{ 'success' if not winlink_auto_active else 'danger' }}">
      {{ 'Start Auto-WinLink-Send' if not winlink_auto_active else 'Stop Auto-WinLink-Send' }}
    </button>
  </form>

   <a href="{{ url_for('winlink.winlink_inbox') }}" class="btn btn-secondary">
     ðŸ“¥ WinLink Inbox
     <span id="wl-unread-badge" class="wl-unread-badge" style="display:none;">
       UNREAD EMAILS: 0
     </span>
   </a>
</div>

<div id="radio-table">
  {# initial table render #}
{% include 'partials/_radio_table.html' %}
</div>

<p style="margin-top:12px; font-size:0.9em;">
  <small>* ETA (open outbound)</small>
</p>

<h3>Log Incoming Winlink Message</h3>
<form method="POST" id="incoming-form">
  <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
  <label>Subject Line:</label>
  <input
    type="text"
    name="subject"
    style="width:100%;"
    placeholder="Paste subject here (e.g. Air Ops: N12345 | KSBP to KLAX | took off HHMM | ETA HHMM)â€¦"
    required>
  <label style="margin-top:12px">Message Body:</label>
  <textarea
    name="body"
    style="width:100%;"
    placeholder="Paste full message body hereâ€¦"></textarea>
  <button type="submit" style="margin-top:8px">Submit Incoming</button>
</form>

<div id="incoming-feedback-container"></div>

<script>
function normalizeHHMM(t){
  if (!t) return '';
  const digits = String(t).replace(/[^0-9]/g, '');
  return digits ? digits.padStart(4,'0').slice(-4) : 'TBD';
}
</script>

<script>
  // 1) Every 30s, re-fetch only the radio table
  setInterval(async () => {
    const resp = await fetch('{{ url_for("radio.radio_table_partial") }}');
    if (!resp.ok) return;
    document.getElementById('radio-table').innerHTML = await resp.text();
  }, 30000);

  // 2) Incoming-form handling (now colours by server-supplied â€œactionâ€)
  const incomingForm = document.getElementById('incoming-form');
  const feedbackBox  = document.getElementById('incoming-feedback-container');

  incomingForm.addEventListener('submit', async e => {
    e.preventDefault();
    const formData = new FormData(incomingForm);

    // POST to server
    const resp = await fetch(window.location.href, {
      method: incomingForm.method,
      headers: { 'X-Requested-With':'XMLHttpRequest' },
      body: formData
    });
    if (!resp.ok) return alert('Failed to log incoming.');
    const srvJson = await resp.json();          // contains .action and .id

    // --- locally parse subject/body -----------------------------------
    /*--------------------------------------------------------------
      Normalise subject line before regex parsing
        â€¢ remove any number of leading
            "RE", "Re", "ack", "ACK", â€¦ optionally followed by ":"
          e.g.  "Re: RE ACK Air Ops: â€¦"  â†’  "Air Ops: â€¦"
    --------------------------------------------------------------*/
    const subjRaw = formData.get('subject').trim();
    const subj    = subjRaw
                      .replace(/^(?:\s*(?:RE|ACK)\s*:?\s*)+/i, '')   // strip once or many
                      .trim();
    const sm = new RegExp(
      String.raw`Air Ops:\s*([^|]+?)\s*\|\s*([^|]+?)\s*to\s*([^|]+?)\s*\|\s*` +
      String.raw`(?:` +
      String.raw`(?:took off|takeoff\s+estimate)\s*(\d{1,2}:?\d{2})\s*\|\s*ETA\s*(\d{1,2}:?\d{2})` +
      String.raw`|(?:took off|takeoff\s+estimate)\s*(\d{1,2}:?\d{2})\s*\|\s*landed\s*(\d{1,2}:?\d{2})` +
      String.raw`|landed\s*(\d{1,2}:?\d{2}))`,
      'i'
    );
    const bare = /Air Ops:\s*(\S+)\s*\|\s*landed\b/i.exec(subj);
    const body = formData.get('body');
    const ct   = /Cargo Type\(s\).*?\.{3,}\s*(.*)/i.exec(body);
    const cw   = /Total Weight of the Cargo.*?\.{3,}\s*(.*)/i.exec(body);

    const p = {
      tail_number:      sm?.[1]?.trim() || bare?.[1] || 'TBD',
      airfield_takeoff: sm?.[2]?.trim() || 'TBD',
      airfield_landing: sm?.[3]?.trim() || 'TBD',
      takeoff_time:     sm?.[4]?.trim().padStart(4,'0') || 'TBD',
      eta:              sm?.[5]?.trim().padStart(4,'0') || 'TBD',
      cargo_type:       ct?.[1]?.trim() || 'TBD',
      cargo_weight:     cw?.[1]?.trim() || 'TBD'
    };


    /* same post-clean as back-end */
    const clean = t => {
      if (!t) return '';
      let u = t.toUpperCase().trim();
      if (/^UNK(?:N|KNOWN)?$/.test(u)) return 'TBD';
      return u.replace(/\b(?:L|LOCAL)$/i, '').trim();
    };
    p.takeoff_time = normalizeHHMM(clean(p.takeoff_time));
    p.eta          = normalizeHHMM(clean(p.eta));

    // lookup existing flight for id/pilot/pax/remarks
    let id    = 'â€”', pilot = 'â€”', pax = 'â€”', rem = '';
        prior = null;   // â† will hold the JSON row if it exists
    try {
      const lookup = await fetch(`/api/lookup_tail/${encodeURIComponent(p.tail_number)}`);
      if (lookup.ok) {
        prior = await lookup.json();
        id    = prior.id           ?? id;
        pilot = prior.pilot_name   || pilot;
        pax   = prior.pax_count    || pax;
        rem   = prior.remarks      || '';
      }
    } catch {}

    // detect landing vs in-flight
    const isLanding     = /\blanded\b/i.test(subj);
    const landMatch     = /\blanded\s*(\d{1,2}:?\d{2})/i.exec(subj);  // hhmm OR hh:mm
    const displayStatus = isLanding ? 'ðŸ›¬ Landed' : 'âœˆï¸ In-Flight';
    const displayEta    = isLanding
                         ? (landMatch?.[1].padStart(4,'0') || 'TBD')
                         : (p.eta + '*');

    /* -----------------------------------------------------------
       Pick highlight purely from what the server tells us.
         new            â†’ green
         updated        â†’ blue
         update_ignored â†’ grey
         anything else  â†’ red   (parse-failure / nothing useful)
    ----------------------------------------------------------- */
    let rowClass = 'red-border';
    if      (srvJson.action === 'new')            rowClass = 'green-border';
    else if (srvJson.action === 'updated')        rowClass = 'blue-border';
    else if (srvJson.action === 'update_ignored') rowClass = 'grey-border';

    /* -----------------------------------------------------------
       Prefer the fresh row that just came back from the server
       (it has authoritative values), fall back to local parse.
       â”€â”€ Field names match those used in the table below â”€â”€
    ----------------------------------------------------------- */
    const row = {
      id:               srvJson.id               ?? id,
      tail_number:      srvJson.tail_number      ?? p.tail_number,
      pilot_name:       srvJson.pilot_name       ?? pilot,
      pax_count:        srvJson.pax_count        ?? pax,
      airfield_takeoff: srvJson.airfield_takeoff ?? p.airfield_takeoff,
      takeoff_time:     srvJson.takeoff_time     ?? p.takeoff_time,
      airfield_landing: srvJson.airfield_landing ?? p.airfield_landing,
      eta:              srvJson.eta              ?? displayEta,
      cargo_type:       srvJson.cargo_type       ?? p.cargo_type,
      cargo_weight:     srvJson.cargo_weight     ?? p.cargo_weight,
      remarks:          srvJson.remarks          ?? rem
    };

    /* â”€â”€ fallback: if everything important is blank/TBD, force RED â”€â”€ */
    const allBlank = [
      row.tail_number,
      row.airfield_takeoff,
      row.airfield_landing,
      row.takeoff_time,
      row.eta,
      row.cargo_type,
      row.cargo_weight
    ].every(v => !v || v === 'TBD');
    if (allBlank) rowClass = 'red-border';

    feedbackBox.innerHTML = `
      <table id="incoming-feedback">
        <thead>
          <tr>
            <th>#</th><th class="status">Status</th><th>Tail #</th>
            <th>Pilot</th><th>PAX #</th><th>Origin</th>
            <th>Departure<br>HHMM</th><th>Destination</th>
            <th>ETA* / Arr HHMM</th><th>Cargo Type</th>
            <th>Cargo Wt</th><th>Remarks</th>
          </tr>
        </thead>
        <tbody>
          <tr class="${rowClass}">
            <td>${row.id           ?? id}</td>
            <td class="status">${displayStatus}</td>
            <td>${row.tail_number  ?? p.tail_number}</td>
            <td>${row.pilot_name   ?? pilot}</td>
            <td>${row.pax_count    ?? pax}</td>
            <td>${row.airfield_takeoff}</td>
            <td>${row.takeoff_time}</td>
            <td>${row.airfield_landing}</td>
            <td>${row.eta}</td>
            <td>${row.cargo_type   ?? p.cargo_type}</td>
            <td>${row.cargo_weight ?? p.cargo_weight}</td>
            <td>${row.remarks      ?? rem}</td>
          </tr>
        </tbody>
      </table>
    `;
    const fb = document.getElementById('incoming-feedback');
    setTimeout(() => fb.classList.add('show'),    20);
    setTimeout(() => fb.classList.remove('show'), 30200);
    setTimeout(() => feedbackBox.innerHTML = '',   30600);

    incomingForm.reset();
  });
</script>

<script>
  // clock updater
  function updateClock(){
    const now = new Date();
    const hh = String(now.getHours()).padStart(2,'0');
    const mm = String(now.getMinutes()).padStart(2,'0');
    const ss = String(now.getSeconds()).padStart(2,'0');
    document.getElementById('clock').textContent = `${hh}:${mm}:${ss}`;
  }
  setInterval(updateClock, 1000);
  updateClock();
</script>

<script>
  // auto-resize the body textarea
  (()=>{
    const ta = document.querySelector('#incoming-form textarea[name="body"]');
    if (!ta) return;
    const autoResize = e => {
      e.target.style.height = 'auto';
      e.target.style.height = e.target.scrollHeight + 'px';
    };
    ta.addEventListener('input', autoResize);
    autoResize({ target: ta });
  })();
</script>

<script>
// Intercept WinLink polling form for one-time poll/parse on start
const pollForm = document.getElementById('winlink-poll-form');
if (pollForm) {
  pollForm.addEventListener('submit', async function(e){
    // Only intercept on "Start" (not "Stop")
    if (pollForm.action.endsWith('{{ url_for("winlink.winlink_start") }}')) {
      e.preventDefault();
      // Fire one-time poll_now route with CSRF
      const CSRF_TOKEN = '{{ csrf_token() }}';
      await fetch('/winlink/poll_now', {
        method: 'POST',
        headers: {'Content-Type':'application/x-www-form-urlencoded'},
        body: new URLSearchParams({'csrf_token': CSRF_TOKEN})
      });
      // Actually submit form to start normal polling
      pollForm.submit();
    }
    // otherwise (stopping), let normal form submit happen
  });
}
</script>

<script>
// --- Unread badge updater (every 30s) â€” read cookie directly ---
// Cookie name shared with WinLink Inbox page
const WL_COOKIE = 'winlink_emails_read';

function getCookie(name){
  const m = document.cookie.match(new RegExp('(?:^|;\\s*)' + name.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\$&') + '=([^;]*)'));
  return m ? decodeURIComponent(m[1]) : '';
}
function mergeRanges(ranges){
  if (!ranges.length) return [];
  ranges.sort((a,b)=> (a[0]-b[0]) || (a[1]-b[1]));
  const out=[ranges[0].slice()];
  for (let i=1;i<ranges.length;i++){
    const [s,e]=ranges[i], last=out[out.length-1];
    if (s<=last[1]+1) last[1]=Math.max(last[1],e);
    else out.push([s,e]);
  }
  return out;
}
function parseRanges(str){
  if (!str) return [];
  const parts=str.split(',').map(s=>s.trim()).filter(Boolean);
  const ranges=[];
  for(const p of parts){
    if (/^\d+$/.test(p)){ const v=+p; ranges.push([v,v]); }
    else{
      const m=p.match(/^(\d+)-(\d+)$/);
      if (m){ const a=+m[1], b=+m[2]; ranges.push([Math.min(a,b), Math.max(a,b)]); }
    }
  }
  return mergeRanges(ranges);
}
function contains(ranges, id){
  id = +id; return ranges.some(([s,e]) => id>=s && id<=e);
}

async function refreshUnreadBadge(){
  try{
    // 1) fetch current inbox (IDs only are all we need; using existing endpoint)
    const resp = await fetch('{{ url_for("winlink.winlink_inbox_json") }}', { cache:'no-store' });
    if (!resp.ok) return;
    const msgs = await resp.json();
    const ids  = Array.isArray(msgs) ? msgs.map(m => +m.id).filter(Number.isFinite) : [];

    // 2) read and parse the read-ranges cookie
    const ranges = parseRanges(getCookie(WL_COOKIE) || '');

    // 3) compute unread = ids not contained in ranges
    let unread = 0;
    for (const id of ids){
      if (!contains(ranges, id)) unread++;
    }

    // 4) update badge
    const badge = document.getElementById('wl-unread-badge');
    if (!badge) return;
    if (unread > 0){
      badge.textContent = 'Unread messages: ' + unread;
      badge.style.display = 'inline-block';
    } else {
      badge.style.display = 'none';
    }
  } catch (_) {
    /* ignore */
  }
}
refreshUnreadBadge();
setInterval(refreshUnreadBadge, 30000);
</script>

{% endblock %}
