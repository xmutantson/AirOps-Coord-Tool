<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- prevent mobile auto-zoom & make layout responsive -->
  <meta name="viewport"
        content="width=device-width,
                 initial-scale=1,
                 maximum-scale=1,
                 user-scalable=no">
  <title>{% block title %}{% endblock %}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <meta name="csrf-token" content="{{ csrf_token() }}">

    <!-- Auto‑reload on CSRF expiry: any fetch that returns 401 → full page reload -->
    <script>
    (function(){
      const _origFetch = window.fetch;
      window.fetch = function(...args){
        return _origFetch.apply(this,args).then(resp => {
          if (resp.status === 401) {
            // CSRF token expired or invalid → reload to get a fresh one
            window.location.reload();
            return new Promise(()=>{});  // never resolve downstream
          }
          return resp;
        });
      };
    })();
    </script>
{# Auto-refresh only on Wargame dashboards #}
{# auto-refresh for Wargame pages is JS-driven so we can pause while modals are open #}
</head>

<body class="{{ active }}{% if wargame_mode %} wargame{% endif %}">

{# collect all flashes exactly once #}
{% set _all_flashes = get_flashed_messages(with_categories=true) %}

<div id="toast-container">
  {% for category, msg in _all_flashes %}
    {# always show non-debug; show debug only if the admin toggle is on #}
    {% if category != 'debug' or show_debug %}
      <div class="toast {{ category }}">{{ msg }}</div>
    {% endif %}
  {% endfor %}
</div>

{% if active not in ['login','setup'] %}
  <header>
    <nav class="main-nav">
      <a href="{{ url_for('dashboard') }}"
         class="{% if active=='dashboard' %}active{% endif %}">Dashboard</a>
      <a href="{{ url_for('radio') }}"
         class="{% if active=='radio' %}active{% endif %}">Radio</a>
      <a href="{{ url_for('ramp_boss') }}"
         class="{% if active=='ramp_boss' %}active{% endif %}">Ramp Boss</a>
      <a href="{{ url_for('inventory.inventory_overview') }}"
         class="{% if active=='inventory' %}active{% endif %}">Inventory</a>
      <a href="{{ url_for('preferences') }}"
         class="{% if active=='preferences' %}active{% endif %}">Preferences</a>
      {% if embedded_name and embedded_url %}
        <a href="{{ url_for('embedded') }}"
           class="{% if active=='embedded' %}active{% endif %}">{{ embedded_name }}</a>
      {% endif %}
      {# Show Wargame tab only when training mode is on #}
      {% if wargame_mode %}
        <a href="{{ url_for('wargame_index') }}"
           class="{% if active=='wargame' %}active{% endif %}">Wargame</a>
      {% endif %}
      {% if admin_unlocked %}
        <a href="{{ url_for('admin') }}"
           class="{% if active=='admin' %}active{% endif %}">Admin</a>
      {% endif %}
    </nav>
  </header>
{% endif %}

<main class="container">
  {% block content %}{% endblock %}
</main>

<footer>
  © {{ current_year }} Kameron Markham (KG7VSN)
</footer>

<!-- ── 30 s heartbeat: paint body.red when server unreachable ── -->
<script>
(()=>{               /* IIFE keeps global scope clean */
  const CHECK_EVERY = 38_000;          // 30 s
  const TIMEOUT_MS  = 5_000;           // abort after 5 s

  async function beat(){
    const ctrl = new AbortController();
    const tid  = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
    try{
      const r = await fetch("{{ url_for('ping') }}", { signal: ctrl.signal, cache: "no-store" });

      // always toggle offline highlight
      document.body.classList.toggle('offline', !r.ok);

      // but only auto-redirect stale sessions when *not* on login or setup
      const onAuthPage =
        document.body.classList.contains('login') ||
        document.body.classList.contains('setup');

      if (!onAuthPage && r.redirected) {
        window.location.href = r.url;
        return;
      }
    }catch(_){
      document.body.classList.add('offline');
    }finally{
      clearTimeout(tid);
    }
  }
  beat();                              // run once at page-load
  setInterval(beat, CHECK_EVERY);      // …then every interval
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  const toasts = Array.from(document.querySelectorAll('.toast'));
  toasts.forEach((toast, i) => {
    // entrance
    requestAnimationFrame(()=> toast.classList.add('show'));
    // schedule hide
    setTimeout(()=> toast.classList.add('hide'), 3000 + i * 200);
    // remove from DOM after transition
    toast.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && toast.classList.contains('hide')) {
        toast.remove();
      }
    });
  });
});
</script>

<!-- on‑demand toast helper (pages may call window.showToast) -->
<script>
if (typeof window.showToast !== 'function') {
  window.showToast = function (msg, type = 'info', ms = 3000) {
    const wrap = document.getElementById('toast-container');
    if (!wrap) { alert(msg); return; }

    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.textContent = msg;
    wrap.appendChild(t);

    requestAnimationFrame(() => t.classList.add('show'));
    setTimeout(() => t.classList.add('hide'), ms);
    t.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && t.classList.contains('hide')) {
        t.remove();
      }
    });
  };
}
</script>

{# NOTE: We intentionally exclude the Inventory Wargame dashboard from the global auto-reload,
   because it uses SSE to refresh precisely on changes. #}
{% if wargame_mode and request.endpoint in [
      'wargame_radio_dashboard',
      'wargame_ramp_dashboard',
      'wargame_super_dashboard'
    ] %}
<script>
(function(){
  var blocked  = false;
  var pending  = false;
  var INTERVAL = 30000; // 30s

  // Public API for pages/components (e.g., Radio modal)
  window.blockRefresh = function(on){ blocked = !!on; };
  window.requestRefreshIfPending = function(){
    if (pending && !blocked) { pending = false; location.reload(); }
  };

  function wantPause(){
    // Also respect a page setting a global flag (defensive fallback)
    var modalOpen = !!window.__wgModalOpen;
    // Don't reload in background tabs; queue a pending refresh instead.
    var hidden = (document.visibilityState !== 'visible');
    return blocked || modalOpen || hidden;
  }

  function schedule(){
    setTimeout(function(){
      if (wantPause()){
        pending = true;
        schedule();
        return;
      }
      location.reload();
    }, INTERVAL);
  }

  // When the tab becomes visible, perform the pending refresh (if unblocked).
  document.addEventListener('visibilitychange', function(){
    if (document.visibilityState === 'visible') {
      window.requestRefreshIfPending();
    }
  });

  schedule();
})();
</script>
{% endif %}

<!-- Automatically attach CSRF header to non-GET fetch() calls -->
<script>
(function(){
  const el = document.querySelector('meta[name="csrf-token"]');
  const token = el ? el.getAttribute('content') : null;
  if (!token) return;
  const _fetch = window.fetch;
  window.fetch = function(resource, init) {
    init = init || {};
    const method = (init.method || 'GET').toUpperCase();
    if (method !== 'GET' && method !== 'HEAD') {
      init.headers = new Headers(init.headers || {});
      if (!init.headers.has('X-CSRFToken') && !init.headers.has('X-CSRF-Token')) {
        init.headers.set('X-CSRFToken', token);
      }
    }
    return _fetch(resource, init);
  };
})();
</script>

<script>
  // Auto‐expand all <details> for printing, then collapse afterwards.
  function _togglePrintDetails(open) {
    document.querySelectorAll('details').forEach(d => d.open = open);
  }
  window.matchMedia('print').addEventListener('change', e => {
    _togglePrintDetails(e.matches);
  });
  window.onbeforeprint = () => _togglePrintDetails(true);
  window.onafterprint  = () => _togglePrintDetails(false);
</script>

{% block scripts %}{% endblock %}
</body>
</html>
