<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- prevent mobile auto-zoom & make layout responsive -->
  <meta name="viewport"
        content="width=device-width,
                 initial-scale=1,
                 maximum-scale=1,
                 user-scalable=no">
  <!-- Favicons: lean .ico for legacy probes, sized PNGs for modern, Apple touch -->
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon-32.png') }}">
  <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='favicon-16.png') }}">
  <link rel="apple-touch-icon" href="{{ url_for('static', filename='apple-touch-icon.png') }}">
  <title>{% block title %}{% endblock %}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <meta name="csrf-token" content="{{ csrf_token() }}">

    <!-- Auto‑reload on CSRF expiry: any fetch that returns 401 → full page reload -->
    <script>
    (function(){
      const _origFetch = window.fetch;
      window.fetch = function(...args){
        return _origFetch.apply(this,args).then(resp => {
          if (resp.status === 401) {
            // CSRF token expired or invalid → reload to get a fresh one
            window.location.reload();
            return new Promise(()=>{});  // never resolve downstream
          }
          return resp;
        });
      };
    })();
    </script>
{# Auto-refresh only on Wargame dashboards #}
{# auto-refresh for Wargame pages is JS-driven so we can pause while modals are open #}
</head>

<body class="{{ active }}{% if wargame_mode %} wargame{% endif %}">

{# collect all flashes exactly once #}
{% set _all_flashes = get_flashed_messages(with_categories=true) %}

<div id="toast-container">
  {% for category, msg in _all_flashes %}
    {# always show non-debug; show debug only if the admin toggle is on #}
    {% if category != 'debug' or show_debug %}
      <div class="toast {{ category }}">{{ msg }}</div>
    {% endif %}
  {% endfor %}
</div>

{% if active not in ['login','setup'] %}
  <header>
    <nav class="main-nav">
      <a href="{{ url_for('supervisor.supervisor') }}"
         data-tab="supervisor"
         class="{% if active=='supervisor' %}active{% endif %}">Supervisor</a>
      <a href="{{ url_for('core.dashboard') }}"
         data-tab="dashboard"
         class="{% if active=='dashboard' %}active{% endif %}">Dashboard</a>
      <a href="{{ url_for('radio.radio') }}"
         data-tab="radio"
         class="{% if active=='radio' %}active{% endif %}">Radio</a>
      <a href="{{ url_for('ramp.ramp_boss') }}"
         data-tab="ramp_boss"
         class="{% if active=='ramp_boss' %}active{% endif %}">Ramp</a>
      <a href="{{ url_for('ramp.queued_flights') }}"
         data-tab="queued_flights"
         class="{% if active=='queued_flights' %}active{% endif %}">Ramp Queue</a>
      <a href="{{ url_for('inventory.inventory_overview') }}"
         data-tab="inventory"
         class="{% if active=='inventory' %}active{% endif %}">Mat. Handling</a>
      <a href="{{ url_for('preferences.preferences') }}"
         class="{% if active=='preferences' %}active{% endif %}">Preferences</a>
      {% if embedded_name and embedded_url %}
        <a href="{{ url_for('core.embedded') }}"
           class="{% if active=='embedded' %}active{% endif %}">{{ embedded_name }}</a>
      {% endif %}
      {# Show Wargame tab only when training mode is on #}
      {% if wargame_mode %}
        <a href="{{ url_for('wgindex.wargame_index') }}"
           class="{% if active=='wargame' %}active{% endif %}">Wargame</a>
      {% endif %}
      {% if admin_unlocked %}
        <a href="{{ url_for('admin.admin') }}"
           class="{% if active=='admin' %}active{% endif %}">Admin</a>
      {% endif %}
      <!-- Training tab (visibility controlled by hamburger prefs; default OFF) -->
      <a href="{{ url_for('training.training_index') }}"
         data-tab="training"
         class="{% if active=='training' %}active{% endif %}">Training</a>
    </nav>
    <div class="hamburger-container">
      <!-- Hamburger menu for navbar preferences -->
      <button id="nav-hamburger" aria-label="Customize Navbar">☰</button>
      <div id="nav-dropdown">
        <div>Navbar Tabs</div>
        <label><input type="checkbox" data-toggle-tab="supervisor" checked> Supervisor</label><br>
        <label><input type="checkbox" data-toggle-tab="radio" checked> Radio</label><br>
        <label><input type="checkbox" data-toggle-tab="ramp_boss" checked> Ramp</label><br>
        <label><input type="checkbox" data-toggle-tab="queued_flights" checked> Ramp Queue</label><br>
        <label><input type="checkbox" data-toggle-tab="inventory" checked> Mat. Handling</label><br>
        <hr>
        <!-- Training toggle: default UNCHECKED in markup; JS also treats it as default OFF -->
        <label style="margin-top:.25rem;">
          <input type="checkbox" data-toggle-tab="training">
          Training
        </label><br>
        <hr>
        <button id="help-open" class="button button-primary">Help</button>
      </div>
    </div>
  </header>
{% endif %}

<main class="container">
  {% block content %}{% endblock %}
</main>

<footer>
  © {{ current_year }} Kameron Markham (KG7VSN)
</footer>

<!-- ── First-request time probe: log client vs server time (once per session) ── -->
{% if not session.get('time_probe_done') %}
<script>
(function(){
  try {
    var m = document.querySelector('meta[name="csrf-token"]');
    var csrf = m ? m.getAttribute('content') : null;
    // Collect client local epoch, offset (minutes behind UTC), and IANA zone
    var payload = {
      // IMPORTANT: Date.now() is already UTC epoch ms — do NOT offset on server.
      client_epoch_ms: Date.now(),
      // Keep these for logging only (do not use them to re-compute UTC on server).
      tz_offset_min:   new Date().getTimezoneOffset(),  // minutes *behind* UTC
      iana_tz:         (Intl.DateTimeFormat().resolvedOptions().timeZone || "")
    };
    // POST JSON; CSRF header is auto-added by the global fetch wrapper below
    fetch("/__time_probe__", {
      method: "POST",
      headers: {
        "Content-Type":"application/json", "X-Requested-With":"XMLHttpRequest",
        ...(csrf ? {"X-CSRFToken": csrf} : {})
      },
      body: JSON.stringify(payload),
      cache: "no-store",
    }).catch(function(){ /* best-effort: silent */ });
  } catch(e) {}
})();
</script>
{% endif %}

<!-- ── 30 s heartbeat: paint body.red when server unreachable ── -->
<script>
(()=>{               /* IIFE keeps global scope clean */
  const CHECK_EVERY   = 30_000;        // 30 s
  const TIMEOUT_MS    = 5_000;         // abort after 5 s
  const ALLOW_STALE_MS= 35_000;        // don't mark offline until 35 s since last good ping
  let lastOK = Date.now();

  // Flag to avoid false "offline" during navigations / reloads
  window.__NAVIGATING_AWAY = false;
  window.addEventListener('beforeunload', ()=> { window.__NAVIGATING_AWAY = true; });

  async function beat(){
    const ctrl = new AbortController();
    const tid  = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
    try{
      const r = await fetch("{{ url_for('api.ping') }}", { signal: ctrl.signal, cache: "no-store" });

      // success path → clear offline + record lastOK
      if (r.ok) {
        document.body.classList.remove('offline');
        lastOK = Date.now();
      } else {
        // non-OK response: only apply offline after leeway
        if (!window.__NAVIGATING_AWAY && (Date.now() - lastOK) >= ALLOW_STALE_MS) {
          document.body.classList.add('offline');
        }
      }

      // but only auto-redirect stale sessions when *not* on login or setup
      const onAuthPage =
        document.body.classList.contains('login') ||
        document.body.classList.contains('setup');

      if (!onAuthPage && r.redirected) {
        window.location.href = r.url;
        return;
      }
    }catch(err){
      // Fetch aborted (navigation/timeout) → don't flash red unless truly stale
      const aborted = ctrl.signal.aborted || window.__NAVIGATING_AWAY;
      if (!aborted && (Date.now() - lastOK) >= ALLOW_STALE_MS) {
        document.body.classList.add('offline');
      }
    }finally{
      clearTimeout(tid);
    }
  }
  beat();                              // run once at page-load
  setInterval(beat, CHECK_EVERY);      // …then every interval
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  const toasts = Array.from(document.querySelectorAll('.toast'));
  toasts.forEach((toast, i) => {
    // entrance
    requestAnimationFrame(()=> toast.classList.add('show'));
    // schedule hide
    setTimeout(()=> toast.classList.add('hide'), 3000 + i * 200);
    // remove from DOM after transition
    toast.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && toast.classList.contains('hide')) {
        toast.remove();
      }
    });
  });
});
</script>

<!-- on‑demand toast helper (pages may call window.showToast) -->
<script>
if (typeof window.showToast !== 'function') {
  window.showToast = function (msg, type = 'info', ms = 3000) {
    const wrap = document.getElementById('toast-container');
    if (!wrap) { alert(msg); return; }

    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.textContent = msg;
    wrap.appendChild(t);

    requestAnimationFrame(() => t.classList.add('show'));
    setTimeout(() => t.classList.add('hide'), ms);
    t.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && t.classList.contains('hide')) {
        t.remove();
      }
    });
  };
}
</script>

{# NOTE: We intentionally exclude the Inventory Wargame dashboard from the global auto-reload,
   because it uses SSE to refresh precisely on changes. #}
{% if wargame_mode and request.endpoint in [
      'wgradio.wargame_radio_dashboard',
      'wgramp.wargame_ramp_dashboard',
      'wgsuper.wargame_super_dashboard'
    ] %}
<script>
(function(){
  var blocked  = false;
  var pending  = false;
  var INTERVAL = 30000; // 30s

  // Public API for pages/components (e.g., Radio modal)
  window.blockRefresh = function(on){ blocked = !!on; };
  window.requestRefreshIfPending = function(){
    if (pending && !blocked) { pending = false; location.reload(); }
  };

  function wantPause(){
    // Also respect a page setting a global flag (defensive fallback)
    var modalOpen = !!window.__wgModalOpen;
    // Don't reload in background tabs; queue a pending refresh instead.
    var hidden = (document.visibilityState !== 'visible');
    return blocked || modalOpen || hidden;
  }

  function schedule(){
    setTimeout(function(){
      if (wantPause()){
        pending = true;
        schedule();
        return;
      }
      window.__NAVIGATING_AWAY = true;   // prevent heartbeat from painting red during reload
      location.reload();
    }, INTERVAL);
  }

  // When the tab becomes visible, perform the pending refresh (if unblocked).
  document.addEventListener('visibilitychange', function(){
    if (document.visibilityState === 'visible') {
      window.requestRefreshIfPending();
    }
  });

  schedule();
})();
</script>
{% endif %}

<!-- Automatically attach CSRF header to non-GET fetch() calls -->
<script>
(function(){
  const el = document.querySelector('meta[name="csrf-token"]');
  const token = el ? el.getAttribute('content') : null;
  if (!token) return;
  const _fetch = window.fetch;
  window.fetch = function(resource, init) {
    init = init || {};
    const method = (init.method || 'GET').toUpperCase();
    if (method !== 'GET' && method !== 'HEAD') {
      init.headers = new Headers(init.headers || {});
      if (!init.headers.has('X-CSRFToken') && !init.headers.has('X-CSRF-Token')) {
        init.headers.set('X-CSRFToken', token);
      }
    }
    return _fetch(resource, init);
  };
})();
</script>

<script>
  // Auto‐expand all <details> for printing, then collapse afterwards.
  function _togglePrintDetails(open) {
    document.querySelectorAll('details').forEach(d => d.open = open);
  }
  window.matchMedia('print').addEventListener('change', e => {
    _togglePrintDetails(e.matches);
  });
  window.onbeforeprint = () => _togglePrintDetails(true);
  window.onafterprint  = () => _togglePrintDetails(false);
</script>

<script>

// Apply to any <input class="force-upper">  (Ramp-Boss, Edit-Flight, Queue-edit)
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('input.force-upper').forEach(inp => {
    const up = () => { inp.value = inp.value.toUpperCase(); };
    inp.addEventListener('input', up);
    inp.addEventListener('blur',  up);
  });
});

</script>

<script>
// --- Hamburger navbar menu logic (guarded for pages without nav) ---
document.addEventListener('DOMContentLoaded', () => {
  const hamburger  = document.getElementById('nav-hamburger');
  const dropdown   = document.getElementById('nav-dropdown');
  const tabNames   = ['supervisor','radio','ramp_boss','queued_flights','inventory','training'];
  const storageKey = 'navTabPrefs_v1';

  if (!hamburger || !dropdown) {
    return; // no nav on login/setup pages → avoid binding listeners
  }

  // Show/hide dropdown
  hamburger.addEventListener('click', e => {
    dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
    e.stopPropagation();
  });
  document.addEventListener('click', e => {
    if (!dropdown.contains(e.target) && e.target !== hamburger)
      dropdown.style.display = 'none';
  });

  // Load tab prefs from localStorage
  function loadTabPrefs(){
    let prefs = {};
    try { prefs = JSON.parse(localStorage.getItem(storageKey) || '{}'); } catch {}
    tabNames.forEach(tab => {
      // Default behavior:
      //  - All tabs ON by default, EXCEPT 'training' which defaults OFF.
      let checked;
      if (tab === 'training') {
        // explicit true → on; any other/unset → off
        checked = prefs.hasOwnProperty(tab) ? !!prefs[tab] : false;
      } else {
        // explicit false → off; any other/unset → on
        checked = prefs.hasOwnProperty(tab) ? !!prefs[tab] : true;
      }

      // Reflect in hamburger checkbox (if present)
      document.querySelectorAll(`[data-toggle-tab="${tab}"]`).forEach(box => box.checked = checked);
      document.querySelectorAll(`[data-tab="${tab}"]`).forEach(a => a.style.display = checked ? '' : 'none');
    });
  }

  // Save tab prefs to localStorage
  function saveTabPrefs(){
    let prefs = {};
    tabNames.forEach(tab => {
      const toggle = document.querySelector(`[data-toggle-tab="${tab}"]`);
      // If a toggle exists, use its state; otherwise keep prior default semantics:
      // - non-training tabs default true; training defaults false
      let checked;
      if (toggle) {
        checked = !!toggle.checked;
      } else {
        checked = (tab === 'training') ? false : true;
      }
      prefs[tab] = checked;  // persist exact booleans
      document.querySelectorAll(`[data-tab="${tab}"]`).forEach(a => a.style.display = checked ? '' : 'none');
    });
    localStorage.setItem(storageKey, JSON.stringify(prefs));
  }

  // Update on checkbox click
  tabNames.forEach(tab => {
    const box = document.querySelector(`[data-toggle-tab="${tab}"]`);
    if (box) box.addEventListener('change', saveTabPrefs);
  });

  loadTabPrefs();
});
</script>

{% block scripts %}{% endblock %}

<!-- ───────── Help panel (modal/drawer) ───────── -->
<div id="help-backdrop"></div>
<aside id="help-panel" role="dialog" aria-modal="true" aria-labelledby="help-title">
  <header>
    <button id="help-close" class="button-ghost" aria-label="Close">✕</button>
    <h2 id="help-title">Help</h2>
    <div class="help-actions">
      <button id="help-edit-btn"   class="button-ghost"  style="display:none;">Edit</button>
      <button id="help-cancel-btn" class="button-ghost"  style="display:none;">Cancel</button>
      <button id="help-save-btn"   class="button-primary" style="display:none;">Save</button>
    </div>
  </header>
  <div id="help-body"></div>
  <div id="help-edit">
    <label style="display:block;margin-bottom:6px;">
      Title<br>
      <input id="help-title-input" type="text" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:6px;">
    </label>
    <textarea id="help-md-input" placeholder="Write Markdown here..."></textarea>
  </div>
  <div style="padding:0 14px 14px; color:#666; font-size:12px;" id="help-meta"></div>
</aside>
<script src="{{ url_for('static', filename='js/help.js') }}"></script>

  <!-- Help: backdrop + side panel (moved styles to static/style.css) -->
  <div id="help-backdrop"></div>
  <aside id="help-panel" aria-hidden="true">
    <header>
      <h2 id="help-title">Help</h2>
      <div class="help-actions">
        <button id="help-edit-toggle" class="button-ghost" type="button">Edit</button>
        <button id="help-close" class="button-ghost" type="button" aria-label="Close">Close</button>
      </div>
    </header>
    <div id="help-body">
      <!-- Help content injected by backend; rendered with .help-md styles -->
    </div>
    <div id="help-edit" hidden>
      <textarea id="help-editor"></textarea>
      <div class="help-actions">
        <button id="help-save" class="button-primary" type="button">Save</button>
        <button id="help-cancel" class="button-ghost" type="button">Cancel</button>
      </div>
    </div>
  </aside>

  <!-- Minimal JS to wire up the help panel -->
  <script>
  (function () {
    const backdrop = document.getElementById('help-backdrop');
    const panel    = document.getElementById('help-panel');
    const openBtn  = document.getElementById('help-open') || document.getElementById('help-button');
    const closeBtn = document.getElementById('help-close');
    const editTgl  = document.getElementById('help-edit-toggle');
    const editPane = document.getElementById('help-edit');
    const cancelEd = document.getElementById('help-cancel');

    function openHelp() {
      if (backdrop) backdrop.style.display = 'block';
      if (panel) {
        panel.style.display = 'block';
        panel.setAttribute('aria-hidden', 'false');
      }
    }
    function closeHelp() {
      if (backdrop) backdrop.style.display = 'none';
      if (panel) {
        panel.style.display = 'none';
        panel.setAttribute('aria-hidden', 'true');
      }
      if (editPane) editPane.style.display = 'none';
    }
    function toggleEdit() {
      if (!editPane) return;
      editPane.style.display = (editPane.style.display === 'block') ? 'none' : 'block';
    }

    if (openBtn)  openBtn.addEventListener('click', openHelp);
    if (closeBtn) closeBtn.addEventListener('click', closeHelp);
    if (backdrop) backdrop.addEventListener('click', closeHelp);
    if (editTgl)  editTgl.addEventListener('click', toggleEdit);
    if (cancelEd) cancelEd.addEventListener('click', toggleEdit);
  })();
  </script>
</body>
</html>
