<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- prevent mobile auto-zoom & make layout responsive -->
  <meta name="viewport"
        content="width=device-width,
                 initial-scale=1,
                 maximum-scale=1,
                 user-scalable=no">
  <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
  <title>{% block title %}{% endblock %}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <meta name="csrf-token" content="{{ csrf_token() }}">

    <!-- Auto‑reload on CSRF expiry: any fetch that returns 401 → full page reload -->
    <script>
    (function(){
      const _origFetch = window.fetch;
      window.fetch = function(...args){
        return _origFetch.apply(this,args).then(resp => {
          if (resp.status === 401) {
            // CSRF token expired or invalid → reload to get a fresh one
            window.location.reload();
            return new Promise(()=>{});  // never resolve downstream
          }
          return resp;
        });
      };
    })();
    </script>
{# Auto-refresh only on Wargame dashboards #}
{# auto-refresh for Wargame pages is JS-driven so we can pause while modals are open #}
</head>

<body class="{{ active }}{% if wargame_mode %} wargame{% endif %}">

{# collect all flashes exactly once #}
{% set _all_flashes = get_flashed_messages(with_categories=true) %}

<div id="toast-container">
  {% for category, msg in _all_flashes %}
    {# always show non-debug; show debug only if the admin toggle is on #}
    {% if category != 'debug' or show_debug %}
      <div class="toast {{ category }}">{{ msg }}</div>
    {% endif %}
  {% endfor %}
</div>

{% if active not in ['login','setup'] %}
  <header>
    <nav class="main-nav">
      <a href="{{ url_for('supervisor.supervisor') }}"
         data-tab="supervisor"
         class="{% if active=='supervisor' %}active{% endif %}">Airport Ops</a>
      <a href="{{ url_for('core.dashboard') }}"
         data-tab="dashboard"
         class="{% if active=='dashboard' %}active{% endif %}">Dashboard</a>
      <a href="{{ url_for('radio.radio') }}"
         data-tab="radio"
         class="{% if active=='radio' %}active{% endif %}">Radio</a>
      <a href="{{ url_for('ramp.ramp_boss') }}"
         data-tab="ramp_boss"
         class="{% if active=='ramp_boss' %}active{% endif %}">Ramp Boss</a>
      <a href="{{ url_for('ramp.queued_flights') }}"
         data-tab="queued_flights"
         class="{% if active=='queued_flights' %}active{% endif %}">Ramp Ops</a>
      <a href="{{ url_for('inventory.inventory_overview') }}"
         data-tab="inventory"
         class="{% if active=='inventory' %}active{% endif %}">Inventory</a>
      <a href="{{ url_for('preferences.preferences') }}"
         class="{% if active=='preferences' %}active{% endif %}">Preferences</a>
      {% if embedded_name and embedded_url %}
        <a href="{{ url_for('core.embedded') }}"
           class="{% if active=='embedded' %}active{% endif %}">{{ embedded_name }}</a>
      {% endif %}
      {# Show Wargame tab only when training mode is on #}
      {% if wargame_mode %}
        <a href="{{ url_for('wgindex.wargame_index') }}"
           class="{% if active=='wargame' %}active{% endif %}">Wargame</a>
      {% endif %}
      {% if admin_unlocked %}
        <a href="{{ url_for('admin.admin') }}"
           class="{% if active=='admin' %}active{% endif %}">Admin</a>
      {% endif %}
    </nav>
    <div class="hamburger-container">
      <!-- Hamburger menu for navbar preferences -->
      <button id="nav-hamburger" aria-label="Customize Navbar">☰</button>
      <div id="nav-dropdown">
        <div>Navbar Tabs</div>
        <label><input type="checkbox" data-toggle-tab="supervisor" checked> Airport Ops</label><br>
        <label><input type="checkbox" data-toggle-tab="radio" checked> Radio</label><br>
        <label><input type="checkbox" data-toggle-tab="ramp_boss" checked> Ramp Boss</label><br>
        <label><input type="checkbox" data-toggle-tab="queued_flights" checked> Ramp Ops</label><br>
        <label><input type="checkbox" data-toggle-tab="inventory" checked> Inventory</label><br>
      </div>
    </div>
  </header>
{% endif %}

<main class="container">
  {% block content %}{% endblock %}
</main>

<footer>
  © {{ current_year }} Kameron Markham (KG7VSN)
</footer>

<!-- ── 30 s heartbeat: paint body.red when server unreachable ── -->
<script>
(()=>{               /* IIFE keeps global scope clean */
  const CHECK_EVERY   = 30_000;        // 30 s
  const TIMEOUT_MS    = 5_000;         // abort after 5 s
  const ALLOW_STALE_MS= 35_000;        // don't mark offline until 35 s since last good ping
  let lastOK = Date.now();

  // Flag to avoid false "offline" during navigations / reloads
  window.__NAVIGATING_AWAY = false;
  window.addEventListener('beforeunload', ()=> { window.__NAVIGATING_AWAY = true; });

  async function beat(){
    const ctrl = new AbortController();
    const tid  = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
    try{
      const r = await fetch("{{ url_for('api.ping') }}", { signal: ctrl.signal, cache: "no-store" });

      // success path → clear offline + record lastOK
      if (r.ok) {
        document.body.classList.remove('offline');
        lastOK = Date.now();
      } else {
        // non-OK response: only apply offline after leeway
        if (!window.__NAVIGATING_AWAY && (Date.now() - lastOK) >= ALLOW_STALE_MS) {
          document.body.classList.add('offline');
        }
      }

      // but only auto-redirect stale sessions when *not* on login or setup
      const onAuthPage =
        document.body.classList.contains('login') ||
        document.body.classList.contains('setup');

      if (!onAuthPage && r.redirected) {
        window.location.href = r.url;
        return;
      }
    }catch(err){
      // Fetch aborted (navigation/timeout) → don't flash red unless truly stale
      const aborted = ctrl.signal.aborted || window.__NAVIGATING_AWAY;
      if (!aborted && (Date.now() - lastOK) >= ALLOW_STALE_MS) {
        document.body.classList.add('offline');
      }
    }finally{
      clearTimeout(tid);
    }
  }
  beat();                              // run once at page-load
  setInterval(beat, CHECK_EVERY);      // …then every interval
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  const toasts = Array.from(document.querySelectorAll('.toast'));
  toasts.forEach((toast, i) => {
    // entrance
    requestAnimationFrame(()=> toast.classList.add('show'));
    // schedule hide
    setTimeout(()=> toast.classList.add('hide'), 3000 + i * 200);
    // remove from DOM after transition
    toast.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && toast.classList.contains('hide')) {
        toast.remove();
      }
    });
  });
});
</script>

<!-- on‑demand toast helper (pages may call window.showToast) -->
<script>
if (typeof window.showToast !== 'function') {
  window.showToast = function (msg, type = 'info', ms = 3000) {
    const wrap = document.getElementById('toast-container');
    if (!wrap) { alert(msg); return; }

    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.textContent = msg;
    wrap.appendChild(t);

    requestAnimationFrame(() => t.classList.add('show'));
    setTimeout(() => t.classList.add('hide'), ms);
    t.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && t.classList.contains('hide')) {
        t.remove();
      }
    });
  };
}
</script>

{# NOTE: We intentionally exclude the Inventory Wargame dashboard from the global auto-reload,
   because it uses SSE to refresh precisely on changes. #}
{% if wargame_mode and request.endpoint in [
      'wgradio.wargame_radio_dashboard',
      'wgramp.wargame_ramp_dashboard',
      'wgsuper.wargame_super_dashboard'
    ] %}
<script>
(function(){
  var blocked  = false;
  var pending  = false;
  var INTERVAL = 30000; // 30s

  // Public API for pages/components (e.g., Radio modal)
  window.blockRefresh = function(on){ blocked = !!on; };
  window.requestRefreshIfPending = function(){
    if (pending && !blocked) { pending = false; location.reload(); }
  };

  function wantPause(){
    // Also respect a page setting a global flag (defensive fallback)
    var modalOpen = !!window.__wgModalOpen;
    // Don't reload in background tabs; queue a pending refresh instead.
    var hidden = (document.visibilityState !== 'visible');
    return blocked || modalOpen || hidden;
  }

  function schedule(){
    setTimeout(function(){
      if (wantPause()){
        pending = true;
        schedule();
        return;
      }
      window.__NAVIGATING_AWAY = true;   // prevent heartbeat from painting red during reload
      location.reload();
    }, INTERVAL);
  }

  // When the tab becomes visible, perform the pending refresh (if unblocked).
  document.addEventListener('visibilitychange', function(){
    if (document.visibilityState === 'visible') {
      window.requestRefreshIfPending();
    }
  });

  schedule();
})();
</script>
{% endif %}

<!-- Automatically attach CSRF header to non-GET fetch() calls -->
<script>
(function(){
  const el = document.querySelector('meta[name="csrf-token"]');
  const token = el ? el.getAttribute('content') : null;
  if (!token) return;
  const _fetch = window.fetch;
  window.fetch = function(resource, init) {
    init = init || {};
    const method = (init.method || 'GET').toUpperCase();
    if (method !== 'GET' && method !== 'HEAD') {
      init.headers = new Headers(init.headers || {});
      if (!init.headers.has('X-CSRFToken') && !init.headers.has('X-CSRF-Token')) {
        init.headers.set('X-CSRFToken', token);
      }
    }
    return _fetch(resource, init);
  };
})();
</script>

<script>
  // Auto‐expand all <details> for printing, then collapse afterwards.
  function _togglePrintDetails(open) {
    document.querySelectorAll('details').forEach(d => d.open = open);
  }
  window.matchMedia('print').addEventListener('change', e => {
    _togglePrintDetails(e.matches);
  });
  window.onbeforeprint = () => _togglePrintDetails(true);
  window.onafterprint  = () => _togglePrintDetails(false);
</script>

<script>

// Apply to any <input class="force-upper">  (Ramp-Boss, Edit-Flight, Queue-edit)
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('input.force-upper').forEach(inp => {
    const up = () => { inp.value = inp.value.toUpperCase(); };
    inp.addEventListener('input', up);
    inp.addEventListener('blur',  up);
  });
});

</script>

<script>
// --- Hamburger navbar menu logic ---
const hamburger = document.getElementById('nav-hamburger');
const dropdown = document.getElementById('nav-dropdown');
const tabNames = ['supervisor','radio','ramp_boss','queued_flights','inventory'];
const storageKey = 'navTabPrefs_v1';

// Show/hide dropdown
hamburger.addEventListener('click', e => {
  dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
  e.stopPropagation();
});
document.addEventListener('click', e => {
  if (!dropdown.contains(e.target) && e.target !== hamburger)
    dropdown.style.display = 'none';
});

// Load tab prefs from localStorage
function loadTabPrefs(){
  let prefs = {};
  try { prefs = JSON.parse(localStorage.getItem(storageKey) || '{}'); } catch {}
  tabNames.forEach(tab => {
    const checked = prefs[tab] !== false; // default ON
    document.querySelectorAll(`[data-toggle-tab="${tab}"]`).forEach(box => box.checked = checked);
    document.querySelectorAll(`[data-tab="${tab}"]`).forEach(a => a.style.display = checked ? '' : 'none');
  });
}

// Save tab prefs to localStorage
function saveTabPrefs(){
  let prefs = {};
  tabNames.forEach(tab => {
    const checked = document.querySelector(`[data-toggle-tab="${tab}"]`).checked;
    prefs[tab] = checked;
    document.querySelectorAll(`[data-tab="${tab}"]`).forEach(a => a.style.display = checked ? '' : 'none');
  });
  localStorage.setItem(storageKey, JSON.stringify(prefs));
}

// Update on checkbox click
tabNames.forEach(tab => {
  document.querySelector(`[data-toggle-tab="${tab}"]`).addEventListener('change', saveTabPrefs);
});

// Initialize at page load
document.addEventListener('DOMContentLoaded', loadTabPrefs);
</script>

{% block scripts %}{% endblock %}
</body>
</html>
