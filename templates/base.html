<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- prevent mobile auto-zoom & make layout responsive -->
  <meta name="viewport"
        content="width=device-width,
                 initial-scale=1,
                 maximum-scale=1,
                 user-scalable=no">
  <!-- Favicons: lean .ico for legacy probes, sized PNGs for modern, Apple touch -->
  <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon-32.png') }}">
  <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='favicon-16.png') }}">
  <link rel="apple-touch-icon" href="{{ url_for('static', filename='apple-touch-icon.png') }}">
  <title>{% block title %}{% endblock %}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <meta name="csrf-token" content="{{ csrf_token() }}">

  <style>
    /* Weather navbar attention state (kept here; everything else moved to CSS) */
    .main-nav a[data-tab="weather"].alert { background:#b00020; color:#fff; }
  </style>

  <!-- Global CSRF-expiry watcher (inline). Traps any 400 with X-CSRF-Error: 1 and hard-blocks UI until reload. -->
  <script>
  (function () {
    if (window.__CSRF_WATCH_INSTALLED__) return;
    window.__CSRF_WATCH_INSTALLED__ = true;

    function showSessionExpiredOverlay() {
      if (window.__CSRF_EXPIRED_SHOWN__) return;
      window.__CSRF_EXPIRED_SHOWN__ = true;

      var overlay = document.createElement('div');
      overlay.id = 'csrf-expired-overlay';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.background = 'rgba(0,0,0,0.65)';
      overlay.style.zIndex = '2147483647';
      overlay.style.display = 'flex';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.innerHTML =
        '<div style="background:#fff;padding:24px 28px;max-width:520px;width:90%;' +
        'box-shadow:0 10px 30px rgba(0,0,0,.3);border-radius:12px;text-align:center;' +
        'font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;">' +
        '<h2 style="margin:0 0 8px">Session expired</h2>' +
        '<p style="margin:0 0 16px">For security your CSRF token expired. Click OK to reload and continue.</p>' +
        '<button id="csrf-ok" style="padding:10px 18px;border:none;border-radius:8px;background:#0b5cff;color:#fff;font-weight:600;cursor:pointer;">OK</button>' +
        '</div>';

      document.body.appendChild(overlay);

      function hardReload() {
        try { window.__NAVIGATING_AWAY = true; } catch(_) {}
        try { window.location.reload(true); } catch (_) { window.location.href = window.location.href; }
      }
      overlay.querySelector('#csrf-ok').addEventListener('click', hardReload, { once: true });

      // Block interaction with page underneath overlay (but not the OK button)
      overlay.addEventListener('click', function (e) {
        if (e.target === overlay) { e.preventDefault(); e.stopPropagation(); }
      }, { capture: true });
      window.addEventListener('keydown', function (ev) {
        if (ev.key === 'Enter') hardReload();
        ev.preventDefault(); ev.stopPropagation();
      }, { capture: true });
    }

    function isCsrfFailure(status, headersGetter) {
      try {
        if (status !== 400) return false;
        var v = headersGetter && headersGetter('X-CSRF-Error');
        if (v == null) v = headersGetter && headersGetter('x-csrf-error');
        return (v === '1');
      } catch (_) { return false; }
    }

    // Wrap fetch()
    if (window.fetch) {
      const _fetch = window.fetch;
      window.fetch = function () {
        return _fetch.apply(this, arguments).then(function (res) {
          if (isCsrfFailure(res.status, res.headers && res.headers.get.bind(res.headers))) {
            showSessionExpiredOverlay();
          }
          return res;
        });
      };
    }

    // Wrap XMLHttpRequest
    if (window.XMLHttpRequest) {
      const XHR = window.XMLHttpRequest;
      const _open = XHR.prototype.open, _send = XHR.prototype.send;
      XHR.prototype.open = function () { this.__csrf_watch = true; return _open.apply(this, arguments); };
      XHR.prototype.send = function () {
        if (this.__csrf_watch) {
          this.addEventListener('loadend', function () {
            if (isCsrfFailure(this.status, this.getResponseHeader.bind(this))) {
              showSessionExpiredOverlay();
            }
          });
        }
        return _send.apply(this, arguments);
      };
    }
  })();
  </script>
{# Auto-refresh only on Wargame dashboards #}
{# auto-refresh for Wargame pages is JS-driven so we can pause while modals are open #}
</head>

<body class="{{ active }}{% if wargame_mode %} wargame{% endif %}">

{# collect all flashes exactly once #}
{% set _all_flashes = get_flashed_messages(with_categories=true) %}

<div id="toast-container">
  {% for category, msg in _all_flashes %}
    {# always show non-debug; show debug only if the admin toggle is on #}
    {% if category != 'debug' or show_debug %}
      <div class="toast {{ category }}">{{ msg }}</div>
    {% endif %}
  {% endfor %}
</div>

{% if active not in ['login','setup'] %}
  <header>
    <nav class="main-nav">
      <a href="{{ url_for('supervisor.supervisor') }}"
         data-tab="supervisor"
         class="{% if active=='supervisor' %}active{% endif %}">Supervisor</a>
      <a href="{{ url_for('core.dashboard') }}"
         data-tab="dashboard"
         class="{% if active=='dashboard' %}active{% endif %}">Dashboard</a>
      <a href="{{ url_for('radio.radio') }}"
         data-tab="radio"
         class="{% if active=='radio' %}active{% endif %}">Radio</a>
      <a href="{{ url_for('ramp.ramp_boss') }}"
         data-tab="ramp_boss"
         class="{% if active=='ramp_boss' %}active{% endif %}">Ramp</a>
      <a href="{{ url_for('ramp.queued_flights') }}"
         data-tab="queued_flights"
         class="{% if active=='queued_flights' %}active{% endif %}">Ramp Queue</a>
      <a href="{{ url_for('inventory.inventory_overview') }}"
         data-tab="inventory"
         class="{% if active=='inventory' %}active{% endif %}">Mat. Handling</a>
      <a href="{{ url_for('preferences.preferences') }}"
         class="{% if active=='preferences' %}active{% endif %}">Preferences</a>
      <!-- Weather tab (visibility controlled by hamburger prefs; default OFF) -->
      <a href="{{ url_for('weather_page.index') }}"
         data-tab="weather"
         class="{% if active=='weather' %}active{% endif %}">Weather</a>
      {% if embedded_name and embedded_url %}
        <a href="{{ url_for('core.embedded') }}"
           class="{% if active=='embedded' %}active{% endif %}">{{ embedded_name }}</a>
      {% endif %}
      {# Show Wargame tab only when training mode is on #}
      {% if wargame_mode %}
        <a href="{{ url_for('wgindex.wargame_index') }}"
           class="{% if active=='wargame' %}active{% endif %}">Wargame</a>
      {% endif %}
      {% if admin_unlocked %}
        <a href="{{ url_for('admin.admin') }}"
           class="{% if active=='admin' %}active{% endif %}">Admin</a>
      {% endif %}
      <!-- Training tab (visibility controlled by hamburger prefs; default OFF) -->
      <a href="{{ url_for('training.training_index') }}"
         data-tab="training"
         class="{% if active=='training' %}active{% endif %}">Training</a>
    </nav>
    <div class="hamburger-container">
      <!-- Hamburger menu for navbar preferences -->
      <button id="nav-hamburger" aria-label="Customize Navbar">☰</button>
      <div id="nav-dropdown">
        <div>Navbar Tabs</div>
        <label><input type="checkbox" data-toggle-tab="supervisor" checked> Supervisor</label><br>
        <label><input type="checkbox" data-toggle-tab="radio" checked> Radio</label><br>
        <label><input type="checkbox" data-toggle-tab="ramp_boss" checked> Ramp</label><br>
        <label><input type="checkbox" data-toggle-tab="queued_flights" checked> Ramp Queue</label><br>
        <label><input type="checkbox" data-toggle-tab="inventory" checked> Mat. Handling</label><br>
        <hr>
        <!-- Training toggle: default UNCHECKED in markup; JS also treats it as default OFF -->
        <label style="margin-top:.25rem;">
          <input type="checkbox" data-toggle-tab="training">
          Training
        </label><br>
        <!-- Weather toggle: default UNCHECKED in markup; JS also treats it as default OFF -->
        <label style="margin-top:.25rem;">
          <input type="checkbox" data-toggle-tab="weather">
          Weather
        </label><br>
        <hr>
        <button id="help-open" class="button button-primary">Help</button>
      </div>
    </div>
  </header>
{% endif %}

  <main class="container">
    {% block content %}{% endblock %}
    <!-- Modal mount point: ensures modals are bounded between header & footer -->
    <div id="modal-root" aria-live="polite">
      <!-- App-wide modal (used for stockpile, truck cargo, etc.) -->
      <div id="wg-modal" class="backdrop" style="display:none;">
        <div class="card" role="dialog" aria-modal="true" aria-labelledby="wg-modal-msg">
          <div id="wg-modal-msg" class="msg">Message</div>
          <div id="wg-modal-body" class="body"></div>
          <div class="actions">
            <button id="wg-modal-cancel" class="btn">Cancel</button>
            <button id="wg-modal-ok" class="btn btn-primary">OK</button>
          </div>
        </div>
      </div>

      <!-- RampBoss paperwork modal template: only present in Wargame mode -->
      {% if wargame_mode %}
      <template id="wg-rampboss-modal-tpl">
        <div class="wg-screen" role="dialog" aria-modal="true">
          <div class="wg-sticky">
            <div id="wg-rb-title" class="wg-title">RampBoss — Paperwork</div>
            <button id="wg-rb-complete" class="btn btn-primary" style="margin-left:auto">Mark Paperwork Complete</button>
            <button id="wg-rb-close" class="btn">Close</button>
          </div>
          <div class="wg-body">
            <iframe id="wg-rb-iframe" title="RampBoss" src="about:blank"></iframe>
          </div>
        </div>
      </template>
      {% endif %}
    </div>
  </main>

<footer id="app-footer" class="app-footer">
  <span id="inet-left" class="inet-msg">⚠ No internet detected⚠ </span>
  <span class="copy">© {{ current_year }} Kameron Markham (KG7VSN)</span>
  <span id="inet-right" class="inet-msg">⚠ No internet detected⚠ </span>
</footer>

<!-- ── Time probe: always fire (server enforces once-per-BOOT_ID) ── -->
<script>
(function(){
  try {

    var m = document.querySelector('meta[name="csrf-token"]');
    var csrf = m ? m.getAttribute('content') : null;
    // Collect client local epoch, offset (minutes behind UTC), and IANA zone
    var payload = {
      // IMPORTANT: Date.now() is already UTC epoch ms — do NOT offset on server.
      client_epoch_ms: Date.now(),
      // Keep these for logging only (do not use them to re-compute UTC on server).
      tz_offset_min:   new Date().getTimezoneOffset(),  // minutes *behind* UTC
      iana_tz:         (Intl.DateTimeFormat().resolvedOptions().timeZone || ""),
      boot_id:         "{{ BOOT_ID }}"
    };
    // POST JSON; CSRF header is auto-added by the global fetch wrapper below
    fetch("/__time_probe__", {
      method: "POST",
      headers: {
        "Content-Type":"application/json", "X-Requested-With":"XMLHttpRequest",
        ...(csrf ? {"X-CSRFToken": csrf} : {})
      },
      body: JSON.stringify(payload),
      cache: "no-store",
    })
    .catch(function(_e){
      /* best-effort: silent */
    });
  } catch(e) {}
})();
</script>

<!-- ── 30 s heartbeat: paint body.red when server unreachable ── -->
<script>
(()=>{               /* IIFE keeps global scope clean */
  const CHECK_EVERY   = 30_000;        // 30 s
  const TIMEOUT_MS    = 5_000;         // abort after 5 s
  const ALLOW_STALE_MS= 35_000;        // don't mark offline until 35 s since last good ping
  let lastOK = Date.now();

  // Flag to avoid false "offline" during navigations / reloads
  window.__NAVIGATING_AWAY = false;
  window.addEventListener('beforeunload', ()=> { window.__NAVIGATING_AWAY = true; });

  async function beat(){
    const ctrl = new AbortController();
    const tid  = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
    try{
      const r = await fetch("{{ url_for('api.ping') }}", { signal: ctrl.signal, cache: "no-store" });

      // success path → clear offline + record lastOK
      if (r.ok) {
        document.body.classList.remove('offline');
        lastOK = Date.now();
      } else {
        // non-OK response: only apply offline after leeway
        if (!window.__NAVIGATING_AWAY && (Date.now() - lastOK) >= ALLOW_STALE_MS) {
          document.body.classList.add('offline');
        }
      }

      // but only auto-redirect stale sessions when *not* on login or setup
      const onAuthPage =
        document.body.classList.contains('login') ||
        document.body.classList.contains('setup');

      if (!onAuthPage && r.redirected) {
        window.location.href = r.url;
        return;
      }
    }catch(err){
      // Fetch aborted (navigation/timeout) → don't flash red unless truly stale
      const aborted = ctrl.signal.aborted || window.__NAVIGATING_AWAY;
      if (!aborted && (Date.now() - lastOK) >= ALLOW_STALE_MS) {
        document.body.classList.add('offline');
      }
    }finally{
      clearTimeout(tid);
    }
  }
  beat();                              // run once at page-load
  setInterval(beat, CHECK_EVERY);      // …then every interval
})();
</script>

<!-- ── Internet status poller: reflects server→internet status in footer & Radio tab ── -->
<script>
(function(){
  const POLL_MS = 15000;
  const footer    = document.getElementById('app-footer');
  const leftMsg   = document.getElementById('inet-left');
  const rightMsg  = document.getElementById('inet-right');
  const radioLink = document.querySelector('.main-nav [data-tab="radio"]');
  let lastOnline  = null;

  function repaint(on){
    if (lastOnline === on) return;
    lastOnline = on;
    // expose state + broadcast transition so pages can react
    window.__INET_ONLINE = on;
    window.dispatchEvent(new CustomEvent('inet-status', { detail:{ online:on } }));

    if (!on){
      footer?.classList.add('inet-down');
      radioLink?.classList.add('no-inet');
    } else {
      footer?.classList.remove('inet-down');
      radioLink?.classList.remove('no-inet');
    }
  }

  async function check(){
    try{
      const r = await fetch("{{ url_for('winlink.internet_status') }}", { cache:"no-store" });
      const j = await r.json();
      repaint(!!j.online);
    }catch(_e){
      repaint(false);
    }
  }
  check();
  setInterval(check, POLL_MS);
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  const toasts = Array.from(document.querySelectorAll('.toast'));
  toasts.forEach((toast, i) => {
    // entrance
    requestAnimationFrame(()=> toast.classList.add('show'));
    // schedule hide
    setTimeout(()=> toast.classList.add('hide'), 3000 + i * 200);
    // remove from DOM after transition
    toast.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && toast.classList.contains('hide')) {
        toast.remove();
      }
    });
  });
});
</script>

<!-- on‑demand toast helper (pages may call window.showToast) -->
<script>
if (typeof window.showToast !== 'function') {
  window.showToast = function (msg, type = 'info', ms = 3000) {
    const wrap = document.getElementById('toast-container');
    if (!wrap) { alert(msg); return; }

    const t = document.createElement('div');
    t.className = `toast ${type}`;
    t.textContent = msg;
    wrap.appendChild(t);

    requestAnimationFrame(() => t.classList.add('show'));
    setTimeout(() => t.classList.add('hide'), ms);
    t.addEventListener('transitionend', e => {
      if (e.propertyName === 'opacity' && t.classList.contains('hide')) {
        t.remove();
      }
    });
  };
}
</script>

{# NOTE: We intentionally exclude the Inventory Wargame dashboard from the global auto-reload,
   because it uses SSE to refresh precisely on changes. #}
{% if wargame_mode and request.endpoint in [
      'wgradio.wargame_radio_dashboard',
      'wgramp.wargame_ramp_dashboard',
      'wgsuper.wargame_super_dashboard'
    ] %}
<script>
(function(){
  var blocked  = false;
  var pending  = false;
  var INTERVAL = 30000; // 30s

  // Public API for pages/components (e.g., Radio modal)
  window.blockRefresh = function(on){ blocked = !!on; };
  window.requestRefreshIfPending = function(){
    if (pending && !blocked) { pending = false; location.reload(); }
  };

  function wantPause(){
    // Also respect a page setting a global flag (defensive fallback)
    var modalOpen = !!window.__wgModalOpen;
    // Don't reload in background tabs; queue a pending refresh instead.
    var hidden = (document.visibilityState !== 'visible');
    return blocked || modalOpen || hidden;
  }

  function schedule(){
    setTimeout(function(){
      if (wantPause()){
        pending = true;
        schedule();
        return;
      }
      window.__NAVIGATING_AWAY = true;   // prevent heartbeat from painting red during reload
      location.reload();
    }, INTERVAL);
  }

  // When the tab becomes visible, perform the pending refresh (if unblocked).
  document.addEventListener('visibilitychange', function(){
    if (document.visibilityState === 'visible') {
      window.requestRefreshIfPending();
    }
  });

  schedule();
})();
</script>
{% endif %}

<!-- Automatically attach CSRF header to non-GET fetch() calls -->
<script>
(function(){
  const el = document.querySelector('meta[name="csrf-token"]');
  const token = el ? el.getAttribute('content') : null;
  if (!token) return;
  const _fetch = window.fetch;
  window.fetch = function(resource, init) {
    init = init || {};
    const method = (init.method || 'GET').toUpperCase();
    if (method !== 'GET' && method !== 'HEAD') {
      init.headers = new Headers(init.headers || {});
      if (!init.headers.has('X-CSRFToken') && !init.headers.has('X-CSRF-Token')) {
        init.headers.set('X-CSRFToken', token);
      }
    }
    return _fetch(resource, init);
  };
})();
</script>

<script>
  // Auto‐expand all <details> for printing, then collapse afterwards.
  function _togglePrintDetails(open) {
    document.querySelectorAll('details').forEach(d => d.open = open);
  }
  window.matchMedia('print').addEventListener('change', e => {
    _togglePrintDetails(e.matches);
  });
  window.onbeforeprint = () => _togglePrintDetails(true);
  window.onafterprint  = () => _togglePrintDetails(false);
</script>

<script>

// Apply to any <input class="force-upper">  (Ramp-Boss, Edit-Flight, Queue-edit)
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('input.force-upper').forEach(inp => {
    const up = () => { inp.value = inp.value.toUpperCase(); };
    inp.addEventListener('input', up);
    inp.addEventListener('blur',  up);
  });
});

</script>

<script>
// --- Hamburger navbar menu logic (guarded for pages without nav) ---
document.addEventListener('DOMContentLoaded', () => {
  const hamburger  = document.getElementById('nav-hamburger');
  const dropdown   = document.getElementById('nav-dropdown');
  const tabNames   = ['supervisor','radio','ramp_boss','queued_flights','inventory','training','weather'];
  const storageKey = 'navTabPrefs_v1';

  if (!hamburger || !dropdown) {
    return; // no nav on login/setup pages → avoid binding listeners
  }

  // Show/hide dropdown
  hamburger.addEventListener('click', e => {
    dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
    e.stopPropagation();
  });
  document.addEventListener('click', e => {
    if (!dropdown.contains(e.target) && e.target !== hamburger)
      dropdown.style.display = 'none';
  });

  // Load tab prefs from localStorage
  function loadTabPrefs(){
    let prefs = {};
    try { prefs = JSON.parse(localStorage.getItem(storageKey) || '{}'); } catch {}
    tabNames.forEach(tab => {
      // Default behavior:
      //  - All tabs ON by default, EXCEPT 'training' and 'weather' which default OFF.
      let checked;
      if (tab === 'training' || tab === 'weather') {
        // explicit true → on; any other/unset → off
        checked = prefs.hasOwnProperty(tab) ? !!prefs[tab] : false;
      } else {
        // explicit false → off; any other/unset → on
        checked = prefs.hasOwnProperty(tab) ? !!prefs[tab] : true;
      }

      // Reflect in hamburger checkbox (if present)
      document.querySelectorAll(`[data-toggle-tab="${tab}"]`).forEach(box => box.checked = checked);
      document.querySelectorAll(`[data-tab="${tab}"]`).forEach(a => a.style.display = checked ? '' : 'none');
    });
  }

  // Save tab prefs to localStorage
  function saveTabPrefs(){
    let prefs = {};
    tabNames.forEach(tab => {
      const toggle = document.querySelector(`[data-toggle-tab="${tab}"]`);
      // If a toggle exists, use its state; otherwise keep prior default semantics:
      // - non-training tabs default true; training defaults false
      let checked;
      if (toggle) {
        checked = !!toggle.checked;
      } else {
        checked = (tab === 'training' || tab === 'weather') ? false : true;
      }
      prefs[tab] = checked;  // persist exact booleans
      document.querySelectorAll(`[data-tab="${tab}"]`).forEach(a => a.style.display = checked ? '' : 'none');
    });
    localStorage.setItem(storageKey, JSON.stringify(prefs));
  }

  // Update on checkbox click
  tabNames.forEach(tab => {
    const box = document.querySelector(`[data-toggle-tab="${tab}"]`);
    if (box) box.addEventListener('change', saveTabPrefs);
  });

  loadTabPrefs();
});
</script>

<!-- Global SAME alert watcher: turn Weather tab red and ensure visible when unread -->
<script>
(function(){
  const STORAGE_SEEN = 'same_last_seen';
  let lastSeen = localStorage.getItem(STORAGE_SEEN) || '';
  const weatherLink = document.querySelector('.main-nav [data-tab="weather"]');
  const weatherToggleBox = document.querySelector('[data-toggle-tab="weather"]');
  const POLL_MS = 20000;

  async function check(){
    try{
      const r = await fetch("/api/weather/alerts/head", {cache:"no-store"});
      const j = await r.json().catch(()=>({ok:false}));
      if (!j.ok) return;
      const latest = j.latest || '';
      // If Weather page JS marked seen, respect that live value
      if (typeof window.__sameLatest === 'string' && window.__sameLatest > latest){
        // keep navbar consistent with page state
        j.latest = window.__sameLatest;
      }
      const unread = latest && (!lastSeen || latest > lastSeen);
      if (unread){
        if (weatherLink){
          weatherLink.classList.add('alert');
          weatherLink.style.display = '';           // force visible regardless of prefs
        }
        if (weatherToggleBox) weatherToggleBox.checked = true;  // reflect in hamburger
      }
    }catch(_){}
  }

  // Allow pages to mark seen (called by Weather page when panel opens / mark-read)
  window.__sameMarkSeen = function(ts){
    lastSeen = ts || new Date().toISOString();
    localStorage.setItem(STORAGE_SEEN, lastSeen);
    if (weatherLink) weatherLink.classList.remove('alert');
  };

  // If already on Weather, clear alert state (page will manage)
  if (document.body.classList.contains('weather') && weatherLink){
    weatherLink.classList.remove('alert');
  }
  setInterval(check, POLL_MS);
})();
</script>

{% block scripts %}{% endblock %}

<!-- ───────── Help panel (modal/drawer) ───────── -->
<div id="help-backdrop"></div>
<aside id="help-panel" role="dialog" aria-modal="true" aria-labelledby="help-title">
  <header>
    <button id="help-close" class="button-ghost" aria-label="Close">✕</button>
    <h2 id="help-title">Help</h2>
    <div class="help-actions">
      <button id="help-edit-btn"   class="button-ghost"  style="display:none;">Edit</button>
      <button id="help-cancel-btn" class="button-ghost"  style="display:none;">Cancel</button>
      <button id="help-save-btn"   class="button-primary" style="display:none;">Save</button>
    </div>
  </header>
  <div id="help-body"></div>
  <div id="help-edit">
    <label style="display:block;margin-bottom:6px;">
      Title<br>
      <input id="help-title-input" type="text" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:6px;">
    </label>
    <textarea id="help-md-input" placeholder="Write Markdown here..."></textarea>
  </div>
  <div style="padding:0 14px 14px; color:#666; font-size:12px;" id="help-meta"></div>
</aside>
<script src="{{ url_for('static', filename='js/help.js') }}"></script>

  <!-- Help: backdrop + side panel (moved styles to static/style.css) -->
  <div id="help-backdrop"></div>
  <aside id="help-panel" aria-hidden="true">
    <header>
      <h2 id="help-title">Help</h2>
      <div class="help-actions">
        <button id="help-edit-toggle" class="button-ghost" type="button">Edit</button>
        <button id="help-close" class="button-ghost" type="button" aria-label="Close">Close</button>
      </div>
    </header>
    <div id="help-body">
      <!-- Help content injected by backend; rendered with .help-md styles -->
    </div>
    <div id="help-edit" hidden>
      <textarea id="help-editor"></textarea>
      <div class="help-actions">
        <button id="help-save" class="button-primary" type="button">Save</button>
        <button id="help-cancel" class="button-ghost" type="button">Cancel</button>
      </div>
    </div>
  </aside>

  <!-- Minimal JS to wire up the help panel -->
  <script>
  (function () {
    const backdrop = document.getElementById('help-backdrop');
    const panel    = document.getElementById('help-panel');
    const openBtn  = document.getElementById('help-open') || document.getElementById('help-button');
    const closeBtn = document.getElementById('help-close');
    const editTgl  = document.getElementById('help-edit-toggle');
    const editPane = document.getElementById('help-edit');
    const cancelEd = document.getElementById('help-cancel');

    function openHelp() {
      if (backdrop) backdrop.style.display = 'block';
      if (panel) {
        panel.style.display = 'block';
        panel.setAttribute('aria-hidden', 'false');
      }
    }
    function closeHelp() {
      if (backdrop) backdrop.style.display = 'none';
      if (panel) {
        panel.style.display = 'none';
        panel.setAttribute('aria-hidden', 'true');
      }
      if (editPane) editPane.style.display = 'none';
    }
    function toggleEdit() {
      if (!editPane) return;
      editPane.style.display = (editPane.style.display === 'block') ? 'none' : 'block';
    }

    if (openBtn)  openBtn.addEventListener('click', openHelp);
    if (closeBtn) closeBtn.addEventListener('click', closeHelp);
    if (backdrop) backdrop.addEventListener('click', closeHelp);
    if (editTgl)  editTgl.addEventListener('click', toggleEdit);
    if (cancelEd) cancelEd.addEventListener('click', toggleEdit);
  })();
  </script>
</body>
</html>
