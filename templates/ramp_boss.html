{% extends "base.html" %}
{% block title %}Ramp Boss Intake – Aircraft Ops{% endblock %}
{% set scan_enabled = enable_adv_manifest_scan if enable_adv_manifest_scan is defined else True %}
{% set d = draft if draft else {} %}

{% block content %}
  <!-- Expose draft id early so any early-running scripts can read it -->
  <script>window.draftId = {{ (draft.id if draft else none)|tojson }};</script>
  <!-- EARLY RB SHIM v2
       Runs before any other script can cache fetch/XHR.
       If Remove-mode is active (or payload says op=remove), rewrite:
         POST /api/manifest/<mid>/scan  →  POST /api/manifest/<mid>/nudge
       so below-baseline math happens server-side.
       Supports: JSON, urlencoded, FormData, and barcode-only bodies by
       parsing the scanner input field (#rb-scan-input) when needed. -->
  <script>
  (function installRbScanShimEarly(){
    try{
      if (window.__RB_SHIM_INSTALLED) return;
      window.__RB_SHIM_INSTALLED = true;
      try { console.debug('[RB-SHIM] installing early XHR interceptor'); } catch(_){}

      /* ---------------- shared helpers ---------------- */
      function isScanUrl(u){
        const s = String(u||'');
        return /\/api\/manifest\/[^/?#]+\/scan(?:\?.*)?$/.test(s);
      }
      function asJsonHeaders(h){ try{ return (h && typeof h.set === 'function'); }catch(_){ return false; } }
      function getManifestId(){
        const el = document.getElementById('manifest-id');
        return el ? (el.value||'').trim() : '';
      }
      function uiSaysRemove(){
        const b = document.getElementById('rb-scan-mode-remove');
        return !!(b && b.classList.contains('is-active'));
      }
      function bodyToObject(body, contentType){
        if (typeof body === 'string'){
          const ct = String(contentType||'').toLowerCase();
          if (ct.includes('application/json')){
            try { return JSON.parse(body); } catch(_){}
          }
          try{
            const obj = {};
            new URLSearchParams(body).forEach((v,k)=>{ obj[k]=v; });
            if (Object.keys(obj).length) return obj;
          }catch(_){}
          return {};
        }
        if (typeof FormData !== 'undefined' && body instanceof FormData){
          const obj = {}; body.forEach((v,k)=>{ obj[k]=v; });
          return obj;
        }
        if (!body) return {};
        try { return JSON.parse(body); } catch(_){ return {}; }
      }
      const pickName = o => String((o?.sanitized_name ?? o?.name ?? o?.item ?? '')||'').trim();
      const pickWpu  = o => {
        const raw = o?.weight_per_unit ?? o?.size_lb ?? o?.wpu ?? o?.weight ?? null;
        const n = Number(raw);
        return Number.isFinite(n) ? n : 0;
      };
      const pickQty  = o => { const n = Number(o?.qty); return (Number.isFinite(n) && n>0) ? n : 1; };
      // accept either {op:"remove"} or {mode:"remove"} (your scanner uses "mode")
      const bodySaysRemove = o => /^(remove|rm|minus|subtract)$/.test(
        String((o && (o.op ?? o.mode)) || '').toLowerCase()
      );
      function parseScannerFallback(){
        const inp = document.getElementById('rb-scan-input');
        if (!inp) return null;
        const s = String(inp.value||'').trim();
        if (!s) return null;
        // Heuristics: "name|1" | "name,1" | "name 1 lb" | "name 1"
        let name = '', wpu = 0;
        if (s.includes('|') || s.includes(',')){
          const p = s.split(s.includes('|') ? '|' : ',');
          name = String(p[0]||'').trim();
          wpu  = Number(String(p[1]||'').replace(/[^\d.]/g,''));
        } else {
          const m = s.match(/^(.*?)[\s_]+(\d+(?:\.\d+)?)\s*(?:lb|lbs)?$/i);
          if (m){ name = m[1].trim(); wpu = Number(m[2]); }
        }
        if (name && Number.isFinite(wpu) && wpu>0) return { name, wpu };
        return null;
      }
      function makeNudgeBody(name, wpu, qty){
        return JSON.stringify({
          sanitized_name: name,
          weight_per_unit: Number(wpu),
          qty: Number(qty)||1,
          op: 'remove',
          draft_id: (typeof window.draftId === 'number' ? window.draftId : null)
        });
      }

      /* ---------------- fetch interceptor ---------------- */
      const _origFetch = window.fetch;
      window.fetch = function(input, init){
        try{
          const url  = (typeof input === 'string') ? input : (input && input.url) || '';
          const method = (init && init.method) || (input && input.method) || 'GET';
          const isPostScan = String(method||'').toUpperCase()==='POST' && isScanUrl(url);
          if (isPostScan){
            const mid = getManifestId();
            const obj = bodyToObject(init && init.body, (init && init.headers && init.headers['Content-Type']) || '');
            const remove = uiSaysRemove() || bodySaysRemove(obj);
            if (mid && remove){
              let name = pickName(obj);
              let wpu  = pickWpu(obj);
              let qty  = pickQty(obj);
              if (!(name && wpu>0)){
                const fb = parseScannerFallback();
                if (fb){ name = fb.name; wpu = fb.wpu; }
              }
              const headers = (init && init.headers) ? init.headers : {};
              const newUrl  = String(url).replace(/\/scan(\?.*)?$/, '/nudge$1');
              if (asJsonHeaders(headers)) headers.set('Content-Type','application/json');
              else headers['Content-Type'] = 'application/json';
              // A) structured → build full /nudge body
              if (name && wpu>0){
                const newInit = Object.assign({}, init, { method:'POST', body: makeNudgeBody(name,wpu,qty), headers });
                try{ console.debug('[RB-SHIM:f] /scan → /nudge', {name, wpu, qty}); }catch(_){}
                return _origFetch.call(this, newUrl, newInit);
              }
              // B) barcode-only → let backend resolve barcode for /nudge
              if (obj && obj.barcode){
                const bInit = Object.assign({}, init, {
                  method:'POST',
                  headers,
                  body: JSON.stringify({
                    barcode: obj.barcode,
                    op: 'remove',
                    qty: qty || 1,
                    draft_id: (typeof window.draftId === 'number' ? window.draftId : null)
                  })
                });
                try{ console.debug('[RB-SHIM:f] /scan → /nudge (barcode)', { barcode: obj.barcode }); }catch(_){}
                return _origFetch.call(this, newUrl, bInit);
              }
              // C) hard-stop unsafe remove fallthrough (no name/wpu and no barcode)
              if (!(name && wpu>0) && !(obj && obj.barcode)) {
                try { console.warn('[RB-SHIM] blocked unsafe /scan remove (missing name/wpu/barcode)'); } catch(_){}
                return Promise.resolve(new Response(
                  JSON.stringify({ ok:false, error:'remove_requires_barcode_or_struct' }),
                  { status: 400, headers: { 'Content-Type':'application/json' } }
                ));
              }
            }
          }
        }catch(_){}
        return _origFetch.apply(this, arguments);
      };

      /* ---------------- XHR interceptor ---------------- */
      const XHR = window.XMLHttpRequest;
      const origOpen = XHR.prototype.open;
      const origSend = XHR.prototype.send;
      const origSetHeader = XHR.prototype.setRequestHeader;

      XHR.prototype.setRequestHeader = function(name, value){
        this.__rb_headers = this.__rb_headers || [];
        this.__rb_headers.push([name, value]);
        return origSetHeader.call(this, name, value);
      };
      XHR.prototype.open = function(method, url, async, user, password){
        this.__rb_openArgs = Array.from(arguments);
        this.__rb_method   = method;
        this.__rb_url      = url;
        this.__rb_isScan   = (String(method||'').toUpperCase()==='POST') && isScanUrl(url);
        this.__rb_headers  = [];
        return origOpen.apply(this, this.__rb_openArgs);
      };
      XHR.prototype.send = function(body){
        try{
          if (this.__rb_isScan){
            const mid   = getManifestId();
            // find content-type if one was set before send()
            const ct = (this.__rb_headers||[]).find(([n]) => n.toLowerCase()==='content-type');
            const contentType = ct ? String(ct[1]||'') : '';
            const parsed = bodyToObject(body, contentType);
            const remove = uiSaysRemove() || bodySaysRemove(parsed);
            let name   = pickName(parsed);
            let wpu    = pickWpu(parsed);
            let qty    = pickQty(parsed);
            if (!(name && wpu>0)){
              const fb = parseScannerFallback();
              if (fb){ name = fb.name; wpu = fb.wpu; }
            }

            if (mid && remove && ( (name && wpu>0) || parsed.barcode )){
              // rewrite URL to /nudge (keep query string if present)
              const newUrl = String(this.__rb_url).replace(/\/scan(\?.*)?$/, '/nudge$1');
              const openArgs = Array.from(this.__rb_openArgs||[]);
              openArgs[1] = newUrl;
              origOpen.apply(this, openArgs);
              // replay previously set headers
              for (const [hn,hv] of (this.__rb_headers||[])) {
                try { origSetHeader.call(this, hn, hv); } catch(_){}
              }
              try { origSetHeader.call(this, 'Content-Type', 'application/json'); } catch(_){}
              // A) structured
              if (name && wpu>0){
                body = makeNudgeBody(name, wpu, qty);
                try { console.debug('[RB-SHIM:x] /scan → /nudge', {name, wpu, qty}); } catch(_){}
              }
              // B) barcode-only
              else if (parsed && parsed.barcode){
                body = JSON.stringify({
                  barcode: parsed.barcode,
                  op: 'remove',
                  qty: qty || 1,
                  draft_id: (typeof window.draftId === 'number' ? window.draftId : null)
                });
                try { console.debug('[RB-SHIM:x] /scan → /nudge (barcode)', { barcode: parsed.barcode }); } catch(_){}
              }
            }
          }
        } catch(_){ /* fall through if anything goes sideways */ }
        return origSend.call(this, body);
      };

      try { console.debug('[RB-SHIM] installed'); } catch(_){}
    }catch(e){
      try { console.warn('[RB-SHIM] failed to install', e); } catch(_){}
    }
  })();
  </script>

  <div class="ramp-form-container">
    <form id="rb-form" method="POST">
      <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
      <!-- these hidden fields power the Advanced panel -->
      <input type="hidden" id="advanced-mode" name="advanced" value="0">
      <input type="hidden" id="manifest-id"  name="manifest_id" value="{{ d.get('manifest_id','') }}">

      {# ---------------- Prefill helper ---------------- #}
      {% set dir_prefill = d.get('direction','outbound') %}

      <!-- override: always show Origin & Destination (visibility only; requiredness still follows dir) -->
      <!-- Make this a full-width row and align to the right so it doesn't get squeezed like a form label. -->
      <div class="rb-override"
           style="grid-column:1 / -1; display:flex; align-items:center; justify-content:flex-end;
                  gap:.5rem; margin:.25rem 0 .25rem; white-space:nowrap;">
        <input type="checkbox" id="rb-od-override">
        <label for="rb-od-override"
               style="user-select:none; font-size:.95em; opacity:.85; margin:0;">
          Show Origin &amp; Destination
        </label>
      </div>

      <!-- direction -->
      <label for="dir-out">Aircraft Direction*</label>
      <div class="radio-toggle">
        <input type="radio" id="dir-out" name="direction" value="outbound" required
               {% if dir_prefill == 'outbound' %}checked{% endif %}>
        <label for="dir-out">Outbound</label>
        <input type="radio" id="dir-in"  name="direction" value="inbound"
               {% if dir_prefill == 'inbound' %}checked{% endif %}>
        <label for="dir-in">Inbound</label>
      </div>

      <!-- tail number + lookup -->
      <label for="tail">Tail Number*</label>
      <div class="lookup-row" style="gap:.5rem; flex-wrap:wrap">
        <input id="tail" name="tail_number" required style="min-width:10ch" class="force-upper"
               value="{{ d.get('tail_number','') }}">
        <button type="button" id="lookup">Lookup Tail</button>
      </div>

      <!-- Inbound-only Flight Code row (label left, field right) -->
      <label id="lab-flight-code" for="flight_code" style="display:none;">Flight Code</label>
      <div id="flight-code-row" style="display:none; align-items:center; gap:.4rem;">
        <input id="flight_code" name="flight_code" class="force-upper"
               placeholder="OOOMMDDYYDDDHHMM" style="min-width:26ch;">
        <button type="button" id="code-extract" title="Extract origin/dest/HHMM only if blank">Extract</button>
        <div id="code-extract-hint" style="font-size:.9em; color:#a33; display:none;"></div>
      </div>
      <!-- frozen mmddyy+hhmm part (used when OOO/DDD change) -->
      <input type="hidden" id="code-stamp"  name="code_stamp" value="">
      <!-- backend may want explicit takeoff_time even for inbound convert -->
      <input type="hidden" id="takeoff_time" name="takeoff_time" value="">

      <label for="pilot">Pilot Name</label>
      <input id="pilot" name="pilot_name" style="min-width:10ch"
             value="{{ d.get('pilot_name','') }}">

      <label for="pax">PAX #</label>
      <input id="pax" name="pax_count" placeholder="e.g. 3" style="min-width:10ch"
             value="{{ d.get('pax_count','') }}">

      <!-- Origin – hidden when OUTBOUND -->
      <label id="label-origin" for="origin">Origin* (ALW or KALW)</label>
      <input id="origin" name="origin" required style="min-width:10ch" class="force-upper"
             value="{{ d.get('airfield_takeoff','') }}">

      <!-- hidden departure time – server sets this when the record is posted -->
      <input type="hidden" id="dep_time" name="dep_time">

      <!-- Travel-time (outbound only) – single instance -->
      <label id="travel_label" for="travel_h">Travel Time&nbsp;(HH&nbsp;:&nbsp;MM)*</label>
      <div id="travel_row" class="travel-time-row">
      {% set t_h = d.get('travel_time','')[:2] %}
      {% set t_m = d.get('travel_time','')[2:] %}
      <input id="travel_h" name="travel_h" maxlength="2"
             value="{{ t_h }}"
             placeholder="hh" pattern="[0-9]{1,2}" inputmode="numeric">
        <span>:</span>
      <input id="travel_m" name="travel_m" maxlength="2"
             value="{{ t_m }}"
             placeholder="mm" pattern="[0-9]{1,2}" inputmode="numeric">
      </div>

      <!-- Destination – hidden when INBOUND -->
      <label id="label-destination" for="destination">Destination* (BFI or KBFI)</label>
      <input id="destination" name="destination" required style="min-width:10ch" class="force-upper"
             value="{{ d.get('airfield_landing','') }}">

      <label for="cargo_type">Cargo Type</label>
      <input id="cargo_type" name="cargo_type" style="min-width:10ch"
             value="{{ d.get('cargo_type','') }}">

      <label for="cargo_weight">Cargo Weight</label>
      <div class="lookup-row">
      <input id="cargo_weight"
             name="cargo_weight"
             placeholder="e.g. 300"
             style="flex:1; min-width:10ch"
             value="{{ d.get('cargo_weight','') }}">
        <select name="weight_unit" tabindex="-1" style="min-width:10ch">
          <option value="lbs" selected>lbs</option>
          <option value="kg">kg</option>
        </select>
      </div>

      <!-- Cargo / Manifest buttons -->
      {% if draft %}
        <div class="cargo-tools-toggle">
          <button type="button" id="edit-manifest" style="width:100%">
            ✏️ Edit Cargo Manifest
          </button>
        </div>
      {% else %}
        <div class="cargo-tools-toggle">
          <button type="button" id="open-cw-tools" title="Cargo Weight Tools">
            Running Total
          </button>
          <button type="button" id="open-adv" title="Advanced Cargo Entry">
            Adv. Cargo Entry
          </button>
        </div>
      {% endif %}

      <label for="remarks">Remarks</label>
      <input id="remarks" name="remarks" style="min-width:10ch"
             value="{{ d.get('remarks','') }}">

      <div class="form-buttons" style="margin-top:1rem; display:flex; gap:0.5rem;">
        {% if draft %}
          {# ── edit-draft mode (OUTBOUND-only) ── #}
          <!-- Morphing primary: starts as Pilot Ack, becomes SEND NOW after ack -->
          <button id="rb-ack-send" type="button" class="btn-primary" data-mode="ack" aria-live="polite"
                  data-force-hidden="1" hidden aria-hidden="true" disabled style="display:none;">
            Pilot Ack
          </button>
          <button id="queueBtn" type="submit"
             class="btn-secondary is-hidden"
                  name="action" value="queue"
                  formaction="{{ url_for('ramp.edit_queued_flight', qid=d.id) }}">
            SAVE TO QUEUE
          </button>
          <!-- Persistent Print Labels button (enabled once a flight_id is known) -->
          <a id="rb-print-labels"
             href="#"
             target="_blank" rel="noopener"
             class="btn-secondary"
             title="Print cargo labels"
             data-force-hidden="1" hidden aria-hidden="true" aria-disabled="true"
             style="margin-left:auto; display:none; opacity:.5; pointer-events:none;">📦 Print Labels</a>
          {# ───── Pilot Ack gating UI (only in edit-draft mode) ───── #}
          {% set _acked = d.get('pilot_ack_at') %}
          <div id="rb-ack-row"
               data-force-hidden="1"
               hidden aria-hidden="true"
               style="display:none; gap:.5rem; align-items:center;">
            <a id="rb-manifest" class="btn-secondary"
               href="{{ url_for('ramp.view_manifest_pdf', queue_id=d.id) }}"
               target="_blank"
               {% if not _acked %}style="display:none"{% endif %}>View Manifest PDF</a>
            <small class="muted">Ack: <span id="rb-ack-ts">{% if _acked %}{{ _acked }}{% else %}—{% endif %}</span></small>
          </div>
        {% else %}
          {# ── brand-new Ramp-Boss entry ── #}
          <button id="sendBtn" type="submit"
                  class="btn-primary is-hidden"
                  data-force-hidden="1" hidden aria-hidden="true" disabled style="display:none;"
                  name="action" value="send"
                  formaction="{{ url_for('ramp.ramp_boss') }}">
            SEND NOW
          </button>
          <button id="queueBtn" type="submit"
             class="btn-secondary"
                  name="action" value="queue"
                  formaction="{{ url_for('ramp.queue_flight') }}">
            Add To Queue
          </button>
          <!-- Persistent Print Labels button (enabled once a flight_id is known) -->
          <a id="rb-print-labels"
             href="#"
             target="_blank" rel="noopener"
             class="btn-secondary is-hidden"
             title="Print cargo labels"
             data-force-hidden="1" hidden aria-hidden="true" aria-disabled="true"
             style="margin-left:auto; display:none; opacity:.5; pointer-events:none;">📦 Print Labels</a>
        {% endif %}
      </div>
    </form>

    <!-- Cargo Weight Tools Panel -->
    <div
      id="cargo-tools-panel"
      class="cargo-tools-panel"
      style="position:relative; margin-bottom:1rem; text-align:center;"
    >
      <button
        type="button"
        id="cw-back"
        style="position:absolute; left:1rem; background:none; border:none; font-size:1em; cursor:pointer;"
      >
        ← Back
      </button>
      <h4 style="margin:0; font-size:2em;">Running Cargo Total</h4>

      <div id="cw-history"></div>
      <div id="cw-total">Total: 0 lbs</div>

      <div style="display:flex; align-items:center; gap:0.5rem; margin-top:0.5rem;">
        <button type="button" class="cw-button cw-minus" id="cw-minus" disabled>−</button>
        <input type="number" id="cw-change" placeholder="e.g. 20" step="any" min="0" style="min-width:10ch">
        <button type="button" class="cw-button cw-plus"  id="cw-plus">+</button>
      </div>

      <button type="button" id="cw-apply" style="margin-top:0.75rem;">
        Copy to Cargo Weight
      </button>
    </div>

    <!-- Advanced Inventory Take‑over Panel -->
    <div
      id="adv-panel"
      style="display:none; position:relative; text-align:left;"
    >

      <button
        type="button"
        id="adv-back"
        class="back-button"
        style="position:absolute; left:1rem; background:none; border:none; font-size:1em; cursor:pointer;"
      >
        ← Back
      </button>
      <h4 style="margin-top:2rem; margin-bottom:0.5rem;">Advanced Inventory Entry</h4>

      {# ───────── RampBoss Scanner (Advanced Cargo) ───────── #}
      {% if scan_enabled %}
      <div id="rb-scan" style="display:none; margin:0.25rem 0 0.5rem;">
        <div style="display:flex;gap:.5rem;align-items:center;flex-wrap:wrap">
          <strong>Scanner:</strong>
          <button type="button" id="rb-scan-mode-add"    class="rb-scan-mode is-active">Add</button>
          <button type="button" id="rb-scan-mode-remove" class="rb-scan-mode">Remove</button>
          <input id="rb-scan-input" placeholder="Scan barcode…" autocomplete="off" style="min-width:22ch" />
          <span id="rb-scan-feedback" style="opacity:.8"></span>
        </div>
      </div>
      {% endif %}

      <style>
        /* light styling for Add/Remove toggle */
        .rb-scan-mode{
          padding:.2rem .6rem;border:1px solid #ccc;border-radius:.5rem;background:#f6f6f6;cursor:pointer
        }
        .rb-scan-mode.is-active{ background:#e0f0ff;border-color:#7aa7d8 }
        /* feedback colors for scan results */
        #rb-scan-feedback{min-width:14ch}
        #rb-scan-feedback.scan-ok{color:#0a0}
        #rb-scan-feedback.scan-warn{color:#b36b00}
        #rb-scan-feedback.scan-err{color:#b00020}
      </style>
      <style>
        /* Hide Δ chips so the UI shows exactly one visible chip per (name,size).
           We still keep them in the DOM for math/merge logic. */
        #adv-lines .adv-chip[data-delta="1"]{
          display:none !important;
        }
      </style>

      <style>
        /* Step 6: Inventory matchability borders (preview only; no fulfillment) */
        #adv-lines .adv-chip.match-ok {
          border: 2px solid #2e7d32 !important;  /* solid green: enough weight in stock */
          border-radius: 16px;
        }
        #adv-lines .adv-chip.match-partial {
          border: 2px dashed #2e7d32 !important; /* dashed green: some presence but insufficient/unknown weight */
          border-radius: 16px;
        }
      </style>

      <!-- local Inbound / Outbound toggle (mirrors the main one) -->
      <div class="radio-toggle adv-dir-toggle" style="margin-bottom:0.5rem;">
        <input type="radio" id="adv-dir-out" name="adv_direction" value="outbound">
        <label for="adv-dir-out">Outbound</label>
        <input type="radio" id="adv-dir-in"  name="adv_direction" value="inbound">
        <label for="adv-dir-in">Inbound</label>
      </div>

      <div id="adv-line-form" style="display:flex; gap:0.5rem; align-items:center;">
        <select id="adv-category" style="min-width:10ch;">
          <option value="">Category…</option>
        </select>
        <!-- OUTBOUND widgets (pick from stock) -->
        <select id="adv-item"  class="adv-out" disabled style="min-width:10ch;">
          <option value="">Item…</option>
        </select>
        <select id="adv-size"  class="adv-out" disabled style="min-width:10ch;">
          <option value="">Size…</option>
        </select>

        <!-- INBOUND widgets (free entry) -->
        <input  id="adv-name"   class="adv-in"  placeholder="Item name…" style="min-width:10ch; display:none;">
        <input  id="adv-weight" class="adv-in"  type="number" min="0" step="any"
                placeholder="Wt/unit"            style="min-width:10ch; display:none;">
        <select id="adv-wunit"  class="adv-in"  style="min-width:8ch;  display:none;">
          <option value="lbs" selected>lbs</option>
          <option value="kg">kg</option>
        </select>
        <input id="adv-qty"
               type="number"
               min="1"
               disabled
               placeholder="Qty"
               style="min-width:10ch;">
        <button type="button" id="adv-add-line">Add</button>
      </div>

      <div id="adv-lines" style="margin-top:1rem; display:flex; flex-wrap:wrap; gap:0.5rem;">
        <!-- chips appear here -->
      </div>
      <!-- footer row: align Done + pills to the right -->
      <div id="adv-footer-row"
           style="display:flex; align-items:center; flex-wrap:wrap; gap:0.5rem; justify-content:flex-end; margin-top:1rem;">
        <button type="button" id="adv-done" disabled>
          Done
        </button>
        <!-- live units pill (purple) — will be placed to the RIGHT of total-weight pill -->
        <span id="adv-units-pill"
              style="display:inline-block; margin-top:0; padding:.2rem .6rem;
                     border-radius:999px; background:#6a0dad; color:#fff; font-weight:600;">
          Units: 0
        </span>
      </div>
    </div>

    <div id="rb-feedback-container"></div>
  </div>

  <!-- ───────── Cargo Requests FAB + Drawer ───────── -->
  <button id="rb-req-fab"
          class="fab-requests"
          aria-haspopup="dialog"
          aria-controls="rb-req-drawer"
          title="Cargo Requests">
    🧾
    <span id="rb-req-badge" class="badge" aria-label="Outstanding requests">0</span>
  </button>
  <div id="rb-req-overlay" class="req-overlay" hidden></div>
  <aside id="rb-req-drawer" class="req-drawer" aria-hidden="true" aria-label="Cargo Requests">
    <div class="req-drawer-header">
      <h3 style="margin:0;">Cargo Requests</h3>
      <button id="rb-req-close" class="req-close" aria-label="Close">✕</button>
    </div>
    <div id="rb-req-body" class="req-body">
      <div class="req-empty">Loading…</div>
    </div>
  </aside>

  <!-- ───────── Advanced-Manifest Detect Modal ───────── -->
  <div id="adv-detect-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.35);">
    <div style="background:#fff; max-width:700px; margin:8vh auto; padding:1rem; border-radius:10px;">
      <h3 style="margin-top:0;">Manifest detected — apply to inventory?</h3>
      <div id="adv-detect-list" style="display:flex; flex-wrap:wrap; gap:.5rem;"></div>
      <div style="margin-top:.75rem; display:flex; gap:.5rem; justify-content:flex-end;">
        <button type="button" id="adv-detect-cancel">Cancel</button>
        <button type="button" id="adv-detect-apply" class="btn-primary">Apply</button>
      </div>
      <div id="adv-detect-error" style="color:#b00; margin-top:.5rem; display:none;"></div>
    </div>
  </div>

  <!-- ───────── Cargo Requests Drawer JS (polls, renders, delete hooks) ───────── -->
  <script>
  (function cargoRequestsDrawer(){
    // safe esc
    const esc = (s)=> String(s ?? '')
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    // header helper (fallback if global xhrHeaders not ready)
    const localXhrHeaders = (extra={}) => {
      const token = document.querySelector('input[name="csrf_token"]')?.value || '';
      const h = {'X-Requested-With':'XMLHttpRequest'};
      if (token) { h['X-CSRFToken']=token; h['X-CSRF-Token']=token; }
      return Object.assign(h, extra);
    };
    const getHeaders = window.xhrHeaders || localXhrHeaders;
    const fmtLb = (n)=> `${Math.round(Number(n||0))} lb`;
    const sum = (arr, pick) => arr.reduce((a,x)=> a + (Number(pick(x))||0), 0);
    const _norm = s => String(s||'').toLowerCase()
      .replace(/&/g,'and').replace(/[^a-z0-9]+/g,' ').replace(/\s+/g,' ').trim();

    // Hub availability (Advanced inventory data) → total pounds by item name
    function availabilityForNameLb(name){
      const inv = (window.inventoryAdvancedData || {});
      const avail = inv.avail || {};
      const target = _norm(name);
      let availLb = 0, presence = false, unknownWeight = false;
      try{
        for (const cid of Object.keys(avail)){
          const byItem = avail[cid] || {};
          for (const raw of Object.keys(byItem)){
            if (_norm(raw) !== target) continue;
            const sizes = byItem[raw] || {};
            for (const sizeKey of Object.keys(sizes)){
              const qty = Number(sizes[sizeKey] || 0);
              if (qty <= 0) continue;
              presence = true;
              const wpu = Number(sizeKey);
              if (Number.isFinite(wpu)) availLb += (wpu * qty);
              else unknownWeight = true;
            }
          }
        }
      }catch(_){}
      return { availLb, presence, unknownWeight };
    }


    const fab = document.getElementById('rb-req-fab');
    const badge = document.getElementById('rb-req-badge');
    const drawer = document.getElementById('rb-req-drawer');
    const overlay = document.getElementById('rb-req-overlay');
    const body = document.getElementById('rb-req-body');
    const close = document.getElementById('rb-req-close');
    let drawerOpen = false;
    function openDrawer(){ drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false'); overlay.hidden=false; drawerOpen=true; fetchSummary(); }
    function closeDrawer(){ drawer.classList.remove('open'); drawer.setAttribute('aria-hidden','true'); overlay.hidden=true; drawerOpen=false; }
    // FAB now shows *count of distinct requested items* across all airports
    function updateBadgeCount(n){ if (badge) badge.textContent = String(Math.max(0, n|0)); }

    fab?.addEventListener('click', openDrawer);
    close?.addEventListener('click', closeDrawer);
    // overlay click no longer closes the drawer (non-modal behavior)
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && drawerOpen) closeDrawer(); });

    function render(summary){
      const outstandingNames = new Set();
      // remember which airports were open so polling won't auto-collapse them
      const previouslyOpen = new Set(
        Array.from(body.querySelectorAll('details.req-group[open]'))
             .map(el => el.getAttribute('data-ap') || '')
      );
      body.innerHTML = '';
      const groups = summary?.airports || summary?.groups || [];
      if (!Array.isArray(groups) || groups.length === 0){
        body.innerHTML = '<div class="req-empty">No outstanding requests.</div>';
        updateBadgeCount(0);
        return;
      }

      let grandLb = 0;
      let grandCount = 0;
      for (const g of groups){
        const ap = g.airport || g.code || g.id || 'UNKNOWN';
        const items = Array.isArray(g.items) ? g.items : [];
        const groupLb = sum(items, it => it.outstanding_lb ?? it.requested_lb ?? 0);
        const groupCount = items.length;
        grandLb += groupLb;
        grandCount += groupCount;

        const det = document.createElement('details');
        det.className = 'req-group';
        det.setAttribute('data-ap', ap);
        det.innerHTML = `
          <summary class="req-group-h">
            <div class="req-group-left">
              <div class="req-group-title">${esc(ap)}</div>
              <div class="req-group-stats">
                <span class="req-count">${groupCount} items</span>
                <span class="req-weight">· ${esc(fmtLb(groupLb))}</span>
              </div>
            </div>
            <div class="req-group-right">
              <button class="button small" data-action="delete-request-airport" data-airport="${esc(ap)}">Clear Airport</button>
            </div>
          </summary>
          <div class="req-items"></div>
        `;

        // restore open/closed state
        if (previouslyOpen.has(ap)) det.open = true;

        const list = det.querySelector('.req-items');
        if (!items.length){
          list.innerHTML = '<div class="req-empty">No items</div>';
        } else {
          for (const it of items){
            const nm = it.name ?? it.item ?? it.sanitized_name ?? 'Item';
            const out = Number(it.outstanding_lb ?? it.requested_lb ?? 0);
            const req = Number(it.requested_lb ?? out);
            const row = document.createElement('div');
            row.className = 'req-row';
            row.innerHTML = `
              <div class="req-row-main">
                <div class="req-row-name">${esc(nm)}</div>
                <div class="req-row-meta">${esc(fmtLb(out))}${(req && req !== out) ? ` (of ${esc(fmtLb(req))})` : ''}</div>
              </div>
              <div class="req-row-actions">
                <button class="button small" data-action="delete-request-item" data-airport="${esc(ap)}" data-name="${esc(nm)}">Clear Item</button>
              </div>
            `;
            if (out > 0) outstandingNames.add(_norm(nm));
            // Stock match borders: solid = fully satisfiable now, dashed = partial
            const { availLb, presence, unknownWeight } = availabilityForNameLb(nm);
            if (presence){
              if (unknownWeight || availLb < out) row.classList.add('match-partial');
              else if (availLb >= out)            row.classList.add('match-ok');
            }
            list.appendChild(row);
          }
        }
        body.appendChild(det);
      }
      updateBadgeCount(grandCount);
      // Expose names to Advanced panel and refresh chip borders
      window.__REQ_NAMES = outstandingNames;
      if (typeof window.applyMatchingBorders === 'function') window.applyMatchingBorders();
    }

    async function fetchSummary(){
      try{
        const r = await fetch('/inventory/requests/summary', { headers: getHeaders() });
        if (!r.ok) throw new Error('HTTP '+r.status);
        const j = await r.json();
        render(j);
      }catch(_){
        if (drawerOpen) body.innerHTML = '<div class="req-empty">Failed to load requests.</div>';
      }
    }

    body?.addEventListener('click', async (ev)=>{
      const btn = ev.target.closest('button[data-action]');
      if (!btn) return;
      const act = btn.dataset.action;
      try{
        if (act === 'delete-request-airport'){
          const ap = btn.dataset.airport;
          await fetch('/inventory/requests/airport', {
            method:'DELETE',
            headers: getHeaders({'Content-Type':'application/json'}),
            body: JSON.stringify({ airport: ap })
          });
        } else if (act === 'delete-request-item'){
          const ap = btn.dataset.airport, nm = btn.dataset.name;
          await fetch('/inventory/requests/line', {
            method:'DELETE',
            headers: getHeaders({'Content-Type':'application/json'}),
            body: JSON.stringify({ airport: ap, name: nm })
          });
        }
        fetchSummary();
      }catch(err){
        console.warn('Request delete failed', err);
      }
    });

    // initial + poll
    fetchSummary();
    setInterval(fetchSummary, 30000);

    // Advanced panel helper: green border on chips that fulfill a request
    window.applyMatchingBorders = function(){
      const chips = document.querySelectorAll('#adv-lines .adv-chip');
      const set = (window.__REQ_NAMES instanceof Set) ? window.__REQ_NAMES : new Set();
      chips.forEach(ch => {
        const nm = _norm(ch.dataset.sanitized || '');
        if (set.has(nm)) ch.classList.add('fulfill-req');
        else ch.classList.remove('fulfill-req');
      });
    };
  })();
  </script>

  <!-- ───────────────── Ramp‑Boss main JS (validation, lookup, CW‑tools) ───────────────── -->
  <script>
    /* ───────────────── Prefill when editing a queued-flight draft ───────────────── */
    {% if draft %}
    /* server pushed a queued-flight draft ⇒ convert form into edit-mode */
    const draft = {{ draft|tojson }};
    document.addEventListener('DOMContentLoaded',()=> {

      /* populate fields */
      const setVal = (id,val)=>{ if(val) document.getElementById(id).value = val; };
      setVal('tail',       draft.tail_number);
      setVal('pilot',      draft.pilot_name);
      setVal('pax',        draft.pax_count);
      setVal('origin',     draft.airfield_takeoff);
      setVal('destination',draft.airfield_landing);
      setVal('cargo_type', draft.cargo_type);
      setVal('cargo_weight',draft.cargo_weight);
      setVal('remarks',    draft.remarks);
      if(draft.travel_time){
        setVal('travel_h', draft.travel_time.slice(0,2));
        setVal('travel_m', draft.travel_time.slice(2,4));
      }
      /* fix direction-toggle & resulting UI */
      document.querySelector(
        `input[name="direction"][value="${draft.direction}"]`
      ).checked = true;
      applyDirUI();
    });
    {% endif %}


    // Ramp-Boss form validation
    /* ───────── Local-time helpers (client-side; always browser TZ) ───────── */
    function nowHHMM () {
      const d = new Date();
      return d.getHours().toString().padStart(2,'0') +
             d.getMinutes().toString().padStart(2,'0');
    }
    /* addHHMM("1425","0135") → "1600"  (wraps at 24 h) */
    function addHHMM (startHHMM, deltaHHMM) {
      const sh = parseInt(startHHMM.slice(0,2),10);
      const sm = parseInt(startHHMM.slice(2),10);
      const dh = parseInt(deltaHHMM.slice(0,2),10);
      const dm = parseInt(deltaHHMM.slice(2),10);
      const total = (sh*60 + sm + dh*60 + dm) % 1440;
      return (Math.floor(total/60)).toString().padStart(2,'0') +
             (total % 60).toString().padStart(2,'0');
    }
    function validateRampBoss () {
      document.querySelectorAll('#rb-form .form-error').forEach(el => el.remove());
      // Only validate required fields that are enabled and visible
      const invalid = Array.from(document.querySelectorAll('#rb-form [required]'))
                            .filter(f => {
                              if (f.disabled) return false;
                              // skip elements hidden via display:none (offsetParent null)
                              const hidden = (f.offsetParent === null);
                              if (hidden) return false;
                              return !String(f.value || '').trim();
                            });
      if (invalid.length) {
        invalid.forEach(f => f.classList.add('error'));
        const submitBtn = document.querySelector('#rb-form button[type="submit"]');
        const msg = document.createElement('div');
        msg.className = 'form-error';
        msg.textContent = 'Please fill in all required fields.';
        submitBtn.parentNode.insertBefore(msg, submitBtn.nextSibling);
        invalid[0].focus();
        return false;
      }
      return true;
    }
    document.querySelectorAll('#rb-form [required]')
            .forEach(f => f.addEventListener('input', () => f.classList.remove('error')));

    // shortcuts to DOM nodes
    const form          = document.getElementById('rb-form');
    /* Is this page editing an existing draft? (server injects null or ID) */
    const draftId       = (typeof window.draftId !== 'undefined' && window.draftId) ? Number(window.draftId) : null;
    const feedbackBox   = document.getElementById('rb-feedback-container');
    const isEditDraft   = !!draftId;
    const defaultOrigin = "{{ default_origin }}";
    const depField    = document.getElementById('dep_time');   // hidden
    const takeoffTime = document.getElementById('takeoff_time');
    const isDraft     = {{ 'true' if draft else 'false' }};
    const travelHInp  = document.getElementById('travel_h');
    const travelMInp  = document.getElementById('travel_m');
    /* Ensure logs are visible while editing a queued flight.
       Some browsers/devtools hide console.debug by default; in non-draft
       modes keep normal behavior. */
    try {
      if (isDraft && !console.__rb_forceInfo) { console.__rb_forceInfo = true; console.debug = console.log.bind(console); }
    } catch(_) {}
    const travelRow   = document.getElementById('travel_row');
    const travelLabel = document.getElementById('travel_label');
    const originField = document.getElementById('origin');
    const destField   = document.getElementById('destination');
    const dirRadios   = [...document.querySelectorAll('input[name="direction"]')];
    const queueBtn    = document.getElementById('queueBtn');
    const sendBtn     = document.getElementById('sendBtn');          // may not exist (morphing mode)
    const rbAckBtn    = document.getElementById('rb-ack');           // removed in morphing mode
    const rbAckRow    = document.getElementById('rb-ack-row');
    const rbAckTs     = document.getElementById('rb-ack-ts');
    const rbPdfLink   = document.getElementById('rb-manifest');
    const manifestId  = document.getElementById('manifest-id');
    const csrfToken   = document.querySelector('input[name="csrf_token"]').value;
    // Centralized headers for XHR/CSRF (aligns with backend CSRF expectations)
    function xhrHeaders(extra = {}) {
      const h = { 'X-Requested-With': 'XMLHttpRequest' };
      if (csrfToken) {
        h['X-CSRFToken']  = csrfToken;   // Flask-WTF compatible
        h['X-CSRF-Token'] = csrfToken;   // Some middlewares expect this casing
      }
      return Object.assign(h, extra);
    }

    /* ───────── Ack gate SEND when editing a queued draft ─────────
       Only render this block when a draft exists to avoid touching d.id. */

    {% if draft %}
    /* Morphing Pilot Ack → Send Now */
    (function pilotAckGate(){
      const ackSend = document.getElementById('rb-ack-send');
      /* NEW: if we’re intentionally hiding the Pilot Ack/Send control,
         skip all morphing/handlers so nothing gets wired up behind the scenes. */
      if (ackSend && ackSend.dataset && ackSend.dataset.forceHidden === '1') {
        return;
      }
      const pdfLink = document.getElementById('rb-manifest');
      const ackTs   = document.getElementById('rb-ack-ts');
      const sendUrl = "{{ url_for('ramp.send_queued_flight', qid=d.id) }}";
      const acked   = {{ 'true' if (draft and draft.get('pilot_ack_at')) else 'false' }};
      function setAckMode(){
        if (!ackSend) return;
        ackSend.type = 'button';
        ackSend.dataset.mode = 'ack';
        ackSend.textContent = 'Pilot Ack';
        ackSend.onclick = doAck;
      }
      function setSendMode(){
        if (!ackSend) return;
        ackSend.type = 'submit';
        ackSend.name = 'action';
        ackSend.value = 'send';
        ackSend.formAction = sendUrl;
        ackSend.dataset.mode = 'send';
        ackSend.textContent = 'SEND NOW';
        ackSend.onclick = null;
      }
      async function doAck(){
        if (!confirm('Confirm pilot acknowledgement and generate manifest?')) return;
        try{
          const r = await fetch('/ramp/pilot_ack/{{ d.id }}', {
            method:'POST',
            headers: xhrHeaders({ 'Content-Type':'application/json' }),
            body: JSON.stringify({ build_pdf: 'yes' })
          });
          const j = await r.json().catch(()=>({}));
          if (!r.ok) throw new Error(j.message || 'Pilot Ack failed');
          setSendMode();
          if (pdfLink) pdfLink.style.display = '';
          if (ackTs)   ackTs.textContent = j.pilot_ack_at || '(set)';
          try{ window.showToast?.('Pilot acknowledged; manifest ready.','success'); }catch(_){}
        }catch(err){
          console.error(err);
          alert(err.message || 'Pilot Ack failed');
        }
      }
      if (acked){ setSendMode(); if (pdfLink) pdfLink.style.display = ''; }
      else { setAckMode(); if (pdfLink) pdfLink.style.display = 'none'; }
    })();
    {% endif %}

    // Flight code widgets
    const fcInput        = document.getElementById('flight_code');
    const fcStamp        = document.getElementById('code-stamp');
    const fcRow          = document.getElementById('flight-code-row');
    const fcLab          = document.getElementById('lab-flight-code');
    const fcExtractBtn   = document.getElementById('code-extract');
    const fcExtractHint  = document.getElementById('code-extract-hint');

    // Detect-Manifest modal nodes
    const detectModal = document.getElementById('adv-detect-modal');
    const detectList  = document.getElementById('adv-detect-list');
    const detectErr   = document.getElementById('adv-detect-error');
    const detectCancel= document.getElementById('adv-detect-cancel');
    const detectApply = document.getElementById('adv-detect-apply');

    function openDetectModal() { detectErr.style.display='none'; detectModal.style.display='block'; }
    function closeDetectModal(){ detectModal.style.display='none'; detectList.innerHTML=''; }
    if (detectCancel) detectCancel.addEventListener('click', closeDetectModal);

    function applyDirUI () {
      const dir = dirRadios.find(r => r.checked).value;
      const showBoth = !!document.getElementById('rb-od-override')?.checked;
      /* make travel-time inputs required only when outbound */
      travelHInp.required = travelMInp.required = (dir === 'outbound');
      const hhmm = nowHHMM();

      /* ── show / hide Origin & Destination depending on dir ───────── */
      const labOrigin = document.getElementById('label-origin');
      const labDest   = document.getElementById('label-destination');

      if (dir === 'outbound') {          // Origin never changes for Outbound – hide it
        originField.style.display = labOrigin.style.display = showBoth ? '' : 'none';
        destField.style.display   = labDest.style.display   = '';
        depField.value       = hhmm;
        travelRow.style.display   = '';
        travelLabel.style.display = '';
        if (!isDraft) travelHInp.value = travelMInp.value = '';
        if (!originField.value && defaultOrigin) originField.value = defaultOrigin;
        if (!isDraft) destField.value = '';
        // Outbound: hide Flight Code row (we still compute server-side)
        if (fcRow) fcRow.style.display = 'none';
        if (fcLab) fcLab.style.display = 'none';
        // (keep fcStamp for outbound code generation flow below; input stays hidden)
        if (typeof refreshFlightCode === 'function') refreshFlightCode();  // still generates for backend
      } else {
        originField.style.display = labOrigin.style.display = '';
        destField.style.display   = labDest.style.display   = showBoth ? '' : 'none';
        depField.value       = hhmm;
        travelRow.style.display   = 'none';
        travelLabel.style.display = 'none';
        if (!isDraft) travelHInp.value = travelMInp.value = '';
        if (!destField.value && defaultOrigin) destField.value = defaultOrigin;
        if (!isDraft) originField.value = '';
        // Inbound: show Flight Code row; clear preview/stamp
        if (fcRow) fcRow.style.display = 'inline-flex';
        if (fcLab) fcLab.style.display = '';
        if (fcInput)  fcInput.value = '';
        if (fcStamp)  fcStamp.value = '';
      }
      /* requiredness still follows direction even if both are visible */
      originField.required = (dir === 'inbound');
      destField.required   = (dir === 'outbound');

      /* queue button only for outbound */
      const outbound = (dir === 'outbound');
      /* drafts are *always* outbound, but keep logic symmetrical */
      queueBtn.style.display = outbound ? '' : 'none';
      /* Show primary action on INBOUND (Log Arrival); keep hidden on OUTBOUND */
      (function(){
        const primary = document.getElementById('rb-ack-send') || document.getElementById('sendBtn');
        if (!primary) return;
        if (outbound) {
          primary.classList.add('is-hidden');
          primary.setAttribute('hidden', '');
          primary.setAttribute('aria-hidden', 'true');
          primary.disabled = true;
          primary.style.display = 'none';
        } else {
          primary.classList.remove('is-hidden');
          primary.removeAttribute('hidden');
          primary.removeAttribute('aria-hidden');
          primary.disabled = false;
          primary.style.display = '';
        }
      })();
      /* Only change label if primary is currently a submit (send mode) */
      (function(){
        const primary = document.getElementById('rb-ack-send') || document.getElementById('sendBtn');
        if (!primary) return;
        if (primary.dataset.mode === 'send' || primary.type === 'submit') {
          primary.textContent = outbound ? 'SEND NOW' : 'LOG ARRIVAL';
        }
      })();

    }
    dirRadios.forEach(r => r.addEventListener('change', applyDirUI));
    const odOverride = document.getElementById('rb-od-override');
    if (odOverride) odOverride.addEventListener('change', applyDirUI);
    applyDirUI();

    // ───────── Flight Code helpers & events ─────────
    const FLIGHT_CODE_RE = /^[A-Z0-9]{3}\d{6}[A-Z0-9]{3}\d{4}$/;
    function mmddyyLocal(d=new Date()){
      const y = d.getFullYear()%100, m=d.getMonth()+1, day=d.getDate();
      return `${m.toString().padStart(2,'0')}${day.toString().padStart(2,'0')}${y.toString().padStart(2,'0')}`;
    }
    function normHHMM(s){
      const t = String(s||'').trim();
      if(!/^\d{3,4}$/.test(t)) return '';
      const z = t.padStart(4,'0'); const h=+z.slice(0,2), m=+z.slice(2);
      return (h<=23 && m<=59) ? z : '';
    }
    // lightweight client preview for OOO/DDD: KSEA/CSEA → SEA; else first 3
    function toThreePreview(v){
      const s = String(v||'').trim().toUpperCase();
      if(!s) return '';
      if((s.length===4) && (s[0]==='K' || s[0]==='C')) return s.slice(1,4);
      return s.slice(0,3);
    }
    function composeCode(ooo, mmddyy, ddd, hhmm){
      if(ooo.length!==3 || ddd.length!==3 || hhmm.length!==4) return '';
      return `${ooo}${mmddyy}${ddd}${hhmm}`;
    }
    function refreshFlightCode(){
      const dir = dirRadios.find(r=>r.checked).value;
      if (dir !== 'outbound' || !fcInput || !fcStamp) return;
      // Freeze time part once (MMDDYY+HHMM). Use current dep/local date.
      if (!fcStamp.value){
        const hhmm = normHHMM(depField.value || nowHHMM());
        if(!hhmm) return;
        fcStamp.value     = `${mmddyyLocal()}${hhmm}`;
        if (takeoffTime) takeoffTime.value = hhmm;   // mirror to backend field
      }
      const ooo    = toThreePreview(originField.value || defaultOrigin);
      const ddd    = toThreePreview(destField.value);
      const mmddyy = fcStamp.value.slice(0,6);
      const hhmm   = fcStamp.value.slice(6);
      fcInput.value = composeCode(ooo, mmddyy, ddd, hhmm) || '';
    }

    // Recompute when OOO/DDD change (time stays frozen) — outbound only
    originField.addEventListener('input', refreshFlightCode);
    destField  .addEventListener('input', refreshFlightCode);

    // Inbound “Extract”: fill Origin/Dest/Dep HHMM only if blank; never overwrite non-empty
    if (fcExtractBtn){
      fcExtractBtn.addEventListener('click', async () => {
        fcExtractHint.style.display = 'none'; fcExtractHint.textContent='';
        const code = (fcInput?.value||'').trim().toUpperCase();
        if(!FLIGHT_CODE_RE.test(code)){
          fcExtractHint.textContent = 'Invalid format'; fcExtractHint.style.display='block'; return;
        }
        try{
          const r = await fetch(
            `/api/flight_code/convert?code=${encodeURIComponent(code)}`,
            { headers: xhrHeaders() }
          );
          if(!r.ok) throw new Error();
          const j = await r.json();
          if(!j.ok) throw new Error();
          if(j.origin && !originField.value) originField.value = j.origin;
          if(j.dest   && !destField.value)   destField.value   = j.dest;
          if(j.hhmm   && takeoffTime && !takeoffTime.value) takeoffTime.value = j.hhmm;
        }catch(_){
          fcExtractHint.textContent = 'Unknown airport in code or server error';
          fcExtractHint.style.display='block';
        }
      });
    }

    /* ───────── Inbound: Tail lookup → try Advanced-Manifest detection ───────── */
    const tailInp = document.getElementById('tail');
    const lookupBtn = document.getElementById('lookup');
    async function maybeDetectAdvancedManifest() {
      const dir = dirRadios.find(r => r.checked).value;
      if (!{{ 'true' if scan_enabled else 'false' }} || dir !== 'inbound') return;
      const tail = (tailInp.value || '').trim().toUpperCase();
      if (!tail) return;
      try {
        const resp = await fetch(
          `/api/adv_manifest_from_tail/${encodeURIComponent(tail)}`,
          { headers: xhrHeaders() }
        );
        if (!resp.ok) return;
        const data = await resp.json();
        if (!data.items || !data.items.length) return;
        // Build UI: chip + category dropdown (pre-filled when guess exists)
        detectList.innerHTML = '';
        const cats = data.categories || [];
        data.items.forEach((it, idx) => {
          const wrap = document.createElement('div');
          wrap.className = 'adv-chip';
          wrap.style = 'border:1px solid #ccc; border-radius:16px; padding:.5rem .75rem;';
          wrap.dataset.idx = String(idx);
          wrap.dataset.sanitized = it.sanitized_name;
          wrap.dataset.raw = it.raw_name || it.sanitized_name;
          wrap.dataset.size = String(it.size_lb);
          wrap.dataset.qty  = String(it.qty);
          // label
          const label = document.createElement('div');
          label.innerHTML = `<strong>${it.sanitized_name}</strong> &nbsp; ${it.size_lb} lb × ${it.qty}`;
          // category select
          const sel = document.createElement('select');
          sel.style = 'margin-left:.5rem;';
          sel.innerHTML = `<option value="">Category…</option>` +
            cats.map(c => `<option value="${c.id}">${c.display_name}</option>`).join('');
          if (it.category_id) sel.value = String(it.category_id);
          wrap.appendChild(label);
          wrap.appendChild(sel);
          detectList.appendChild(wrap);
        });
        openDetectModal();
        // Only ONE apply handler; do not also auto-close here
        detectApply.onclick = async () => {
          detectErr.style.display = 'none';
          // Safely collect chips; never send an empty payload
          const chips = Array.from(detectList.getElementsByClassName('adv-chip'));
          if (!chips.length) {
            detectErr.textContent = 'No detected items to apply. Try Tail Lookup again.';
            detectErr.style.display = 'block';
            return;
          }
          let bad = false;
          const items = chips.map(ch => {
            const sel = ch.querySelector('select');
            if (!sel || !sel.value) bad = true;
            return {
              sanitized_name: (ch.dataset.sanitized || '').trim(),
              raw_name: (ch.dataset.raw || ch.dataset.sanitized || '').trim(),
              size_lb: Number(ch.dataset.size || 0),
              qty: Number(ch.dataset.qty || 0),
              category_id: sel && sel.value ? Number(sel.value) : null
            };
          });
          if (bad) {
            detectErr.textContent = 'Please choose a category for each item.';
            detectErr.style.display = 'block';
            return;
          }
          if (!items.length) {
            detectErr.textContent = 'Nothing to apply.';
            detectErr.style.display = 'block';
            return;
          }
          // Ensure we have a manifest session id
          if (!manifestId.value) {
            try {
              const r = await fetch('/api/new_manifest_session', {
                headers: xhrHeaders()
              });
              const j = await r.json();
              if (j && j.manifest_id) manifestId.value = j.manifest_id;
            } catch(_) {}
          }
          // Apply to inventory (committed inbound entries)
          const payload = { manifest_id: manifestId.value, items };
          // Helpful console breadcrumb while we’re stabilizing
          try { console.debug('apply_adv_manifest payload', payload); } catch(_) {}
          const ap = await fetch('/api/apply_adv_manifest', {
            method: 'POST',
            headers: {
              ...xhrHeaders({ 'Content-Type':'application/json' })
            },
            body: JSON.stringify(payload)
          });
          if (ap.ok) {
            try {
              const j = await ap.json();
              console.debug('apply_adv_manifest result', j);
            } catch(_){}
            closeDetectModal();
            // small toast
            const ok = document.createElement('div');
            ok.textContent = 'Manifest applied. It will be attached when you log arrival.';
            ok.style = 'margin-top:.5rem; color:#060;';
            feedbackBox.appendChild(ok);
          } else {
            let msg = 'Failed to apply manifest.';
            try { const j = await ap.json(); if (j && j.error) msg = msg + ' ' + j.error; } catch(_){}
            detectErr.textContent = msg;
            detectErr.style.display = 'block';
          }
        };
      } catch(_) {}
    }
    lookupBtn?.addEventListener('click', maybeDetectAdvancedManifest);

    /* —— Chip helpers (UI): locate chip by (sanitized_name,wpu) and set qty ——— */
    function findChipByKey(name, wpu){
      const n = String(name||'').trim().toLowerCase();
      const w = Number(wpu);
      return [...document.querySelectorAll('#adv-lines .adv-chip')].find(ch =>
        (ch.dataset.sanitized||'').trim().toLowerCase() === n &&
        Math.abs(Number(ch.dataset.wpu||0) - w) < 1e-9
      ) || null;
    }

    function findBaselineChip(name, wpu){
      return [...document.querySelectorAll('#adv-lines .adv-chip')].find(ch =>
        ch.dataset.delta!=='1' &&
        (ch.dataset.sanitized||'').trim().toLowerCase() === String(name||'').trim().toLowerCase() &&
        Math.abs(Number(ch.dataset.wpu||0) - Number(wpu)) < 1e-9
      ) || null;
    }
    function findDeltaChip(name, wpu){
      return [...document.querySelectorAll('#adv-lines .adv-chip')].find(ch =>
        ch.dataset.delta==='1' &&
        (ch.dataset.sanitized||'').trim().toLowerCase() === String(name||'').trim().toLowerCase() &&
        Math.abs(Number(ch.dataset.wpu||0) - Number(wpu)) < 1e-9
      ) || null;
    }

    /* Net qty calculator for a (name,wpu) key based on what's on screen.
       Baseline counts positive; Δ chips are signed (Δ+ positive, Δ− negative). */
    function computeNetForKey(name, wpu){
      const nm = String(name||'').trim().toLowerCase();
      const w  = Number(wpu);
      let net = 0;
      const chips = document.querySelectorAll('#adv-lines .adv-chip');
      chips.forEach(ch => {
        const cn = (ch.dataset.sanitized || '').trim().toLowerCase();
        const cw = Number(ch.dataset.wpu || 0);
        if (cn !== nm || Math.abs(cw - w) >= 1e-9) return;
        let q = Number(ch.dataset.effective ?? ch.dataset.qty ?? 0);
        if (ch.dataset.delta === '1') {
          const s = (ch.dataset.deltaSign === '-1') ? -1 : 1;
          q = s * q;
        }
        net += (Number.isFinite(q) ? q : 0);
      });
      return net;
    }

    /* Remove all chips (baseline and any Δ) for a (name,wpu) key. */
    function removeChipsForKey(name, wpu){
      const nm = String(name||'').trim().toLowerCase();
      const w  = Number(wpu);
      [...document.querySelectorAll('#adv-lines .adv-chip')].forEach(ch=>{
        const cn = (ch.dataset.sanitized||'').trim().toLowerCase();
        const cw = Number(ch.dataset.wpu||0);
        if (cn === nm && Math.abs(cw - w) < 1e-9) ch.remove();
      });
      try { if (window.refreshFromDOM) window.refreshFromDOM(); } catch(_){}
    }

    function recalcChipTotal(chip){
      if (!chip) return;
      // Get WPU (prefer dataset; fallback to parsing the label)
      let wpu = Number(chip.dataset.wpu || NaN);
      if (!Number.isFinite(wpu)) {
        const wtxt = chip.querySelector('.chip-wpu')?.textContent || '';
        const m = wtxt.match(/(\d+(?:\.\d+)?)/);
        wpu = m ? Number(m[1]) : 0;
      }
      // Get current qty (prefer effective; fallback to dataset.qty; then parse)
      let qty = Number(chip.dataset.effective ?? chip.dataset.qty ?? NaN);
      if (!Number.isFinite(qty)) {
        const qtxt = chip.querySelector('.chip-qty')?.textContent || '';
        const qm = qtxt.match(/×\s*(\d+)/);
        qty = qm ? Number(qm[1]) : 0;
      }
      const total = Math.round(wpu * qty * 100) / 100;
      chip.dataset.total = String(total);     // store absolute; Δ sign handled in view
      // Ensure WPU label is consistent
      const wpuEl = chip.querySelector('.chip-wpu');
      if (wpuEl) wpuEl.textContent = `${wpu} lb`;
      // Update "= … lb" with sign for Δ− chips only
      const totEl = chip.querySelector('.chip-total');
      if (totEl) {
        const neg = (chip.dataset.delta === '1' && chip.dataset.deltaSign === '-1');
        totEl.textContent = `= ${neg ? '−' : ''}${total} lb`;
      }
    }

    function setChipQtyDisplay(chip, q){
      if (!chip) return;
      const badge = chip.querySelector('.chip-qty,[data-role="qty"]');
      if (badge) { badge.textContent = `×${q}`; }
      else {
        const label = chip.querySelector('.chip-label') || chip;
        label.textContent = (label.textContent||'').replace(/\s*×\d+\s*$/,'') + ` ×${q}`;
      }
      chip.dataset.effective = String(q);
      // Recompute chip total and bubble totals upward
      try { recalcChipTotal(chip); } catch(_){}
      try { if (window.refreshFromDOM) window.refreshFromDOM(); } catch(_){}
      try { applyMatchingBorders(); } catch(_){}
    }

    // NEW: snapshot-safe effective update (never mutates the stored baseline qty)
    function setChipEffectiveOnly(chip, q){
      if (!chip) return;
      const badge = chip.querySelector('.chip-qty,[data-role="qty"]');
      if (badge) { badge.textContent = `×${q}`; }
      else {
        const label = chip.querySelector('.chip-label') || chip;
        label.textContent = (label.textContent||'').replace(/\s*×\d+\s*$/,'') + ` ×${q}`;
      }
      chip.dataset.effective = String(q);
      // Recompute chip total and bubble totals upward
      try { recalcChipTotal(chip); } catch(_){}
      try { if (window.refreshFromDOM) window.refreshFromDOM(); } catch(_){}
      try { applyMatchingBorders(); } catch(_){}
    }

    /* ───────── Intercept /nudge responses to update chips immediately ───────── */
    (function installNudgeInterceptor(){
      const origFetch = window.fetch;
      window.fetch = async function(input, init){
        const res = await origFetch(input, init);
        try{
          const url = (typeof input === 'string') ? input : (input && input.url ? input.url : '');
          const isNudge = /\/api\/manifest\/[^/]+\/nudge\b/.test(url || '');
          if (!isNudge) return res;
          if (!res.ok) { console.error('[nudge] HTTP', res.status, 'at', url); return res; }
          if ((res.headers.get('content-type')||'').includes('json')) {
            // clone so normal callers can still read the body
            const cloned = res.clone();
            const j = await cloned.json();
            if (j && (typeof j.effective_qty !== 'undefined') && (j.sanitized_name || j.name)) {
              const nm = j.sanitized_name || j.name;
              const w  = j.weight_per_unit;
              const chip = findChipByKey(nm, w);
              // A) Baseline chip update/removal
              if (chip) {
                if (j.removed || j.effective_qty === 0) chip.remove();
                else setChipQtyDisplay(chip, j.effective_qty);
              }
              // B) If server reports a new session delta (beyond baseline), spawn/update a Δ chip
              if (j.spawn_delta && j.spawn_delta.qty > 0) {
                const dn = j.spawn_delta.sanitized_name || nm;
                const dw = Number(j.spawn_delta.weight_per_unit || w);
                const isNeg = (j.spawn_delta?.deltaSign === -1 || j.spawn_delta?.sign === -1);
                /* Snapshot edit: we never show Δ−; cap at baseline (0) visually. */
                if (window.__RB_FORCE_SNAPSHOT && isNeg) {
                  try {
                    const d = findDeltaChip(dn, dw);
                    if (d) d.remove();
                    // baseline chip was already updated above from effective_qty
                    console.debug('[nudge] suppressed Δ− in snapshot mode', { dn, dw });
                  } catch(_) {}
                  return res;
                }
                let dchip = findChipByKey(dn, dw);
                // If baseline chip was just removed, a subsequent find may return null; we'll (re)create
                if (!dchip && typeof window._rbUpsertChip === 'function') {
                  window._rbUpsertChip({
                    sanitized_name: dn,
                    weight_per_unit: dw,
                    qty: j.spawn_delta.qty,
                    total: Number(dw) * Number(j.spawn_delta.qty || 0)
                  });
                  dchip = findChipByKey(dn, dw);
                }
                if (!dchip) {
                  // minimal fallback chip if _rbUpsertChip is unavailable
                  const wrap = document.createElement('div');
                  wrap.className = 'adv-chip';
                  wrap.dataset.sanitized = dn;
                  wrap.dataset.wpu = String(dw);
                  wrap.dataset.effective = String(j.spawn_delta.qty);
                  wrap.dataset.pending = '0';
                  wrap.dataset.delta = '1';
                  // always carry a sign for delta chips
                  wrap.dataset.deltaSign = (j.spawn_delta?.deltaSign === -1 || j.spawn_delta?.sign === -1) ? '-1' : '1';
                  wrap.innerHTML = `<span class="chip-label">${dn} ${dw} lb</span><span class="chip-qty">×${j.spawn_delta.qty}</span>`;
                  (document.getElementById('adv-lines') || document.body).appendChild(wrap);
                  dchip = wrap;
                } else {
                  setChipQtyDisplay(dchip, (Number(dchip.dataset.effective || 0) || 0) + Number(j.spawn_delta.qty));
                }
                // tag as delta and always carry a sign
                try { dchip.dataset.deltaSign = (j.spawn_delta?.deltaSign === -1 || j.spawn_delta?.sign === -1) ? '-1' : '1'; } catch(_){}
                dchip.dataset.pending = '0';
                dchip.dataset.delta   = '1';
              }
              // C) If baseline was cleared and we still didn't find a chip to touch, force a repaint
              if ((j.baseline_cleared || j.removed) && !findChipByKey(nm, w)) {
                // In forced-snapshot mode, repainting from /queued_manifest will rehydrate
                // the original baseline (e.g., ×3). Instead, just refresh the session aggregate.
                if (window.__RB_FORCE_SNAPSHOT && typeof window._rbScanRefresh === 'function') {
                  try { await window._rbScanRefresh(); } catch(e) { /* no-op */ }
                } else if (typeof loadExistingManifest === 'function') {
                  try { await loadExistingManifest(); } catch(e) { console.warn('repaint failed', e); }
                }
              }
              // C) Manifest is now dirty → enable Done
              if (typeof advDone !== 'undefined') advDone.disabled = false;
              if (typeof advDirty !== 'undefined') advDirty = true;
            }
          } else {
            // Non-JSON reply; log to console so we stop silently swallowing errors
            const txt = await res.clone().text();
            console.error('[nudge] non-JSON reply', txt.slice(0,300));
          }
        }catch(_){}
        return res;
      };
    })();

    /* ───────────────── Manifest editing helpers ────────────────────────── */
    async function loadExistingManifest () {
      // While editing a queued draft we want exactly one source of truth on screen.
      // If __RB_FORCE_SNAPSHOT is set, *always* render the queued snapshot view,
      // even if a manifest session already exists, to avoid double-painting.
      const mid = manifestId.value;
      if (mid && !window.__RB_FORCE_SNAPSHOT) {
        try {
          // Clear any residue then repaint from authoritative aggregate
          advLines.innerHTML = '';
          if (window._rbScanRefresh) await window._rbScanRefresh();
          // keep header fields (remarks/weight) synced with chips
          if (window.refreshFromDOM) window.refreshFromDOM();
          // enable Done if anything is present
          if (advLines.childElementCount) advDone.disabled = false;
        } catch (_){}
        return;
      }
      // Snapshot path (either no session yet, or we're forcing snapshot-only).
      // Include manifest_id when present so the server can add any committed deltas
      // newer than the snapshot cut-line without us painting live chips separately.
      const url = `/api/queued_manifest/${draftId}${mid ? `?manifest_id=${encodeURIComponent(mid)}` : ''}`;
      // Idempotency: if any baseline (committed/snapshot) chips are already on screen,
      // remove them before repainting the snapshot so we never double-merge visually.
      try {
        advLines.querySelectorAll('.adv-chip[data-pending="0"]').forEach(ch => ch.remove());
      } catch(_) {}
      const resp = await fetch(url, { headers: xhrHeaders() });
      if (!resp.ok) return;
      const rows  = await resp.json();
      // Paint each row. For delta rows (reverse-direction nets), tag visually as Δ.
      for (const r of rows) {
        const name = (r.sanitized || '').trim();
        const wpu  = Number(r.wpu || 0);
        const qty  = Number(r.qty || 0);
        const tot  = Number(r.total || ((Number(r.wpu)||0) * qty));
        if (!name || !wpu || qty <= 0) continue;
        /* Record the original baseline for this session (normalized key) */
        try {
          const k = `${normName(name)}|${Number(wpu)}`;
          (window.__RB_SNAPSHOT_BASE = window.__RB_SNAPSHOT_BASE || new Map()).set(k, Number(qty));
          console.debug?.('[RB-SNAPSHOT:BASE]', { key:k, baseQty: qty });
        } catch(_) {}
        if (typeof window._rbUpsertChip === 'function') {
          window._rbUpsertChip({ sanitized_name: name, weight_per_unit: wpu, qty, total: tot });
        } else {
          const wrap = document.createElement('div');
          wrap.className = 'adv-chip';
          wrap.dataset.sanitized = name;
          wrap.dataset.wpu = String(wpu);
          wrap.dataset.effective = String(qty);
          wrap.dataset.pending = '0';
          wrap.innerHTML = `<span class="chip-label">${name} ${wpu} lb</span><span class="chip-qty">×${qty}</span>`;
          (document.getElementById('adv-lines') || document.body).appendChild(wrap);
        }
        const chip = findChipByKey(name, wpu);
        if (chip) {
          chip.dataset.pending = "0";
          chip.dataset.cat = r.category_name || '';
          /* Treat queued-manifest rows as the baseline surface in snapshot mode.
             Do NOT mark them as Δ — they should be visible as the single baseline chip. */
          try { chip.querySelector('.chip-origin').textContent = ''; } catch(_) {}
          const removeBtn = chip.querySelector('.chip-remove');
          if (removeBtn && !removeBtn.dataset.boundDelete){
            removeBtn.dataset.boundDelete = '1';
            removeBtn.onclick = async (ev) => {
              ev.preventDefault();
              /* Aggregated view → remove the whole (name,wpu) key safely */
              await deleteByKey(name, wpu);
              /* ► mark manifest dirty & enable Done */
              try {
                chip.remove();               /* already gone visually */
                advDirty         = true;
                advDone.disabled = false;
              } catch(_){}
              /* outbound stock may have changed – refresh dropdowns */
              if (document.body.dataset.advDir === 'outbound') {
                try {
                  await fetchInventory();
                  updateSizeOptions(advCat.value, advItem.value);
                } catch(_){}
              }
            };
          }
        } /* chip */
      }   /* rows loop */
      // Just in case: dedupe any stragglers WITHOUT summing (avoid 4+4→8 visuals)
      try { dedupeChipsInDOM(/* merge = */ false); } catch(_) {}

      // Console guard: warn if duplicate keys are still present
      try {
        const seen = new Set();
        [...advLines.querySelectorAll('.adv-chip')].forEach(ch => {
          const key =
            ch.dataset.key ||
            ((ch.dataset.sanitized || '').trim().toLowerCase() + '|' + String(ch.dataset.wpu || ''));
          if (seen.has(key)) {
            console.warn('[ADV] duplicate chip key on screen:', key, ch);
          }
          seen.add(key);
        });
      } catch(_) {}

      refreshFromDOM();
      // snapshot chips are real → user should be able to press “Done”
      if (advLines.childElementCount) advDone.disabled = false;
      // Rebuild remarks live from chips (canonical)
      const rmf = document.getElementById('remarks');
      const chipsNow = [...advLines.querySelectorAll('.adv-chip')];
      rmf.value = buildManifestTextFromChips(chipsNow);
    }

    if (isEditDraft){
      const editManifestBtn = document.getElementById('edit-manifest');
      if (editManifestBtn) editManifestBtn.addEventListener('click', async () => {
        // Ensure there is a manifest session, and adopt this draft's snapshot into it.
        try {
          if (!manifestId.value) {
            const r = await fetch('/api/new_manifest_session', { headers: xhrHeaders() });
            if (r.ok) {
              const j = await r.json();
              if (j && j.manifest_id) {
                manifestId.value = j.manifest_id;
              }
            }
          }
          if (manifestId.value && draft && draft.id) {
            await fetch(`/api/manifest/${encodeURIComponent(manifestId.value)}/adopt_snapshot`, {
              method: 'POST',
              headers: xhrHeaders({ 'Content-Type': 'application/json' }),
              body: JSON.stringify({ draft_id: draft.id })
            });
          }
        } catch (_){}

        // Force snapshot-only initial rendering (no double paint on open).
        window.__RB_FORCE_SNAPSHOT = true;

        // Open the Advanced panel (no paint will occur here)
        startAdvanced();

        // Single, authoritative paint (keeps your merge semantics intact)
        advLines.innerHTML = '';
        await loadExistingManifest();
      });
    }
    else {
      // no-op if not editing

    }

    // Tail-lookup (overwrite with DB values; also set flight_code; no extract)
    document.getElementById('lookup').addEventListener('click', async () => {
      const tail = form.tail_number.value.trim().toUpperCase();
      if (!tail) return showToast('Enter tail number first!', 'error');

      const res = await fetch(
        `/api/lookup_tail/${encodeURIComponent(tail)}`,
        { headers: xhrHeaders() }
      );
      if (!res.ok) return showToast('Lookup failed', 'error');

      const d = await res.json();
      if (!Object.keys(d).length)
        return showToast('No prior record for that tail.', 'error');

      if (d.airfield_takeoff) form.origin.value       = d.airfield_takeoff;
      if (d.airfield_landing) form.destination.value  = d.airfield_landing;
      if (d.pilot_name)       form.pilot_name.value   = d.pilot_name;
      if (d.pax_count)        form.pax_count.value    = d.pax_count;
      if (d.cargo_type)       form.cargo_type.value   = d.cargo_type;
      if (d.cargo_weight)     form.cargo_weight.value = d.cargo_weight;
      if (d.remarks)          form.remarks.value      = d.remarks;
      if (typeof d.flight_code !== 'undefined' && fcInput) fcInput.value = (d.flight_code || '');
    });

   // ────────────────────────────────────────────────────────────────
   //  FORM SUBMIT (SEND NOW  *or*  ADD TO QUEUE)
   // ────────────────────────────────────────────────────────────────

    let rbSubmitting = false;
    function lockButtons(btn){
      try {
        if (btn) {
          btn.dataset.originalText = btn.textContent;
          btn.disabled = true;
          btn.textContent = '⏳ Working…';
        }
        const primaryBtn = document.getElementById('rb-ack-send') || document.getElementById('sendBtn');
        if (primaryBtn && btn !== primaryBtn) primaryBtn.disabled = true;
        if (queueBtn && btn !== queueBtn) queueBtn.disabled = true;
      } catch(_){}
    }
    function unlockButtons(){
      rbSubmitting = false;
      [(document.getElementById('rb-ack-send') || document.getElementById('sendBtn')), queueBtn].forEach(b=>{
        if (!b) return;
        b.disabled = false;
        if (b.dataset.originalText) b.textContent = b.dataset.originalText;
      });
    }
    // ── Labels helpers (enable persistent button + toast) ────────────────
    function labelsURL(opts){
      // Back-compat: if a primitive is passed, assume it's a flight_id
      if (typeof opts === 'string' || typeof opts === 'number') {
        return `/docs/labels/cargo?flight_id=${encodeURIComponent(opts)}&scope=all`;
      }
      const o = opts || {};
      if (o.flightId) return `/docs/labels/cargo?flight_id=${encodeURIComponent(o.flightId)}&scope=all`;
      if (o.queuedId) return `/docs/labels/cargo?queued_id=${encodeURIComponent(o.queuedId)}&scope=all`;
      return '#';
    }
    function enablePrintLabelsButton(opts){
      const a = document.getElementById('rb-print-labels');
      if (!a) return;
      const url = labelsURL(opts);
      if (!url || url === '#') return;
      a.href = url;
      a.style.opacity = '';
      a.style.pointerEvents = '';
      a.removeAttribute('aria-disabled');
    }
    function showLabelsToast(opts){
      const url = labelsURL(opts);
      if (!url || url === '#') return;
      try {
        // Many builds allow simple HTML in toasts — if not, we drop a small inline link below.
        window.showToast(`Labels ready — <a href="${url}" target="_blank" rel="noopener">Print</a>`, 'success');
      } catch(_){}
      // Fallback inline link for environments where toast strips HTML:
      try {
        const box = document.getElementById('rb-feedback-container');
        const div = document.createElement('div');
        div.className = 'muted';
        div.style.marginTop = '.5rem';
        div.innerHTML = `Labels ready — <a href="${url}" target="_blank" rel="noopener">Print</a>`;
        box.appendChild(div);
        setTimeout(()=>{ try{div.remove();}catch(_){} }, 8000);
      } catch(_){}
    }
    form.addEventListener('submit', async e => {
      e.preventDefault();
      if (rbSubmitting) return;
      /* ── Hard-gate: cannot SEND outbound without Destination ─────────── */
      const dirNow  = document.querySelector('input[name="direction"]:checked')?.value || 'outbound';
      const clicked = e.submitter || sendBtn || queueBtn;
      if (clicked?.value === 'send' && dirNow === 'outbound') {
        const destVal = String(destField.value || '').trim();
        if (!destVal) {
          showToast('Destination is required to SEND.', 'error');
          destField.focus();
          return;
        }
      }
      rbSubmitting = true;
      /* lock UI after our early gate so we don’t flash the spinner */
      // NOTE: 'clicked' is already defined above
      lockButtons(clicked);
      // basic required‐field check
      if (!validateRampBoss()){ unlockButtons(); return; }

      /* compute where this form will POST _before_ we touch it anywhere else */
      const targetURL =
            e.submitter?.getAttribute('formaction') || form.action;

      // ── Warn if airport not in our DB (Dest for outbound, Origin for inbound) ──
      const currentDir   = document.querySelector('input[name="direction"]:checked').value;
      const airportField = (currentDir === 'outbound') ? destField : originField;
      const airportVal   = (airportField.value || '').trim().toUpperCase();
      if (airportVal) {
        try {
          const apiResp = await fetch(
            `/api/airport_exists/${encodeURIComponent(airportVal)}`,
            { headers: xhrHeaders() }
          );
          if (apiResp.ok) {
            const { exists } = await apiResp.json();
            if (!exists &&
                !confirm(`"${airportVal}" is not a known airport code. Continue anyway?`)) {
              airportField.focus();
              unlockButtons(); return;
            }
          }
        } catch (err) {
          console.warn('Airport lookup failed', err); /* proceed on network error */
        }
      }

      // now proceed with the existing departure‐time check + POST

      const t = depField.value.trim();
      if (t.length < 3 || t.length > 4 || isNaN(t)) {
        depField.classList.add('error');
        showToast('Time must be 3–4 digits', 'error');
        unlockButtons();
        return;
      }
      depField.classList.remove('error');

      /* ── Time-field / ETA handling ─────────────────────────────────────── */
      const dir     = document.querySelector('input[name="direction"]:checked').value;
      const isQueue = (e.submitter?.value === 'queue');

      if (dir === 'outbound') {
        /* stamp *current* browser time for take-off, *right now* */
        depField.value = nowHHMM();

        // Freeze code stamp (MMDDYY+HHMM) if not set yet; mirror HHMM to backend
        if (typeof mmddyyLocal === 'function' && typeof nowHHMM === 'function' && typeof FLIGHT_CODE_RE !== 'undefined') {
          if (fcStamp && !fcStamp.value){
            fcStamp.value = `${mmddyyLocal()}${depField.value}`;
          }
          if (takeoffTime) takeoffTime.value = depField.value;
        }

        /* ── when we’re inside EDIT-DRAFT mode and targeting
         *    /send_queued_flight/<id>, also send it as `takeoff_time`
         *    so the backend sees local-time immediately              ── */
        if (targetURL.includes('/send_queued_flight')) {
          let tf = form.querySelector('input[name="takeoff_time"]');
          if (!tf) {
            tf = document.createElement('input');
            tf.type  = 'hidden';
            tf.name  = 'takeoff_time';
            form.appendChild(tf);
          }
          tf.value = depField.value;
        }

        /* normalise HH/MM for maths & validation */
        travelHInp.value = travelHInp.value.padStart(2,'0');
        travelMInp.value = travelMInp.value.padStart(2,'0');

        if (isQueue) {                      /* Add to Queue → send travel_time */
        /* ensure hidden <input name="travel_time"> exists *and* is current */
        const tt = `${travelHInp.value}${travelMInp.value}`;
        let hid = form.querySelector('input[name="travel_time"]');
        if (!hid){
          hid = Object.assign(document.createElement('input'),{
            type:'hidden', name:'travel_time'
          });
          form.appendChild(hid);
        }
        hid.value = tt;
        } else {                                  /* Send Now → compute ETA   */
          const etaVal = addHHMM(depField.value,
                                 `${travelHInp.value}${travelMInp.value}`);
          let etaField = form.querySelector('input[name="eta"]');
          if (!etaField) {
            etaField = document.createElement('input');
            etaField.type = 'hidden';
            etaField.name = 'eta';
            form.appendChild(etaField);
          }
          etaField.value = etaVal;
          /* strip any travel_time hidden field so backend never sees it */
          form.querySelectorAll('input[name="travel_time"]').forEach(el => el.remove());
        }

        /* hide visible HH/MM boxes from WTForms */
        travelHInp.disabled = true;
        travelMInp.disabled = true;

      } else {                                          /* inbound – Log Arrival */
        let etaField = form.querySelector('input[name="eta"]');
        if (!etaField) {
          etaField = document.createElement('input');
          etaField.type = 'hidden';
          etaField.name = 'eta';
          form.appendChild(etaField);
        }
        etaField.value = nowHHMM();

        travelHInp.disabled = true;
        travelMInp.disabled = true;
      }

      // 2)  finish the manifest (pending → 0)
      try { await commitManifest(); } catch(_){ unlockButtons(); return; }


      // 3)  post the flight (destination URL depends on which button)

      const resp = await fetch(targetURL, {
        method:  'POST',
        headers: xhrHeaders(),
        body:    new FormData(form)
      });
      // ── always re-enable, even if server replied 400/500 ─────────────
      travelHInp.disabled = false;
      travelMInp.disabled = false;
      if (!resp.ok){ showToast('Save failed', 'error'); unlockButtons(); return; }
      /* endpoints now return JSON for XHR; fall back gracefully */
      let j=null;
      if (resp.headers.get('content-type')?.includes('json')){
          j = await resp.json();
      }

      /* ── If back-end told us where to go, honour it and bail ───────────── */
      if (j?.redirect){
          window.location = j.redirect;
          return;
      }

      /* legacy / non-JSON branch below */
      let f = j;   /* keep old var-name for existing table logic */

      /* ── QUEUE branch: simple toast + hard reset ─────────────────── */
      if (e.submitter?.value === 'queue' && !isEditDraft){
          // If backend returned an id/flight_id, light up labels right away.
          const fidQ = (j && (j.flight_id || j.id)) ? (j.flight_id || j.id) : null;
          if (fidQ){ enablePrintLabelsButton({ queuedId: fidQ }); showLabelsToast({ queuedId: fidQ }); }
          showToast('Flight added to queue','success');
          form.reset();
          applyDirUI();
          travelHInp.value = travelMInp.value = '';
          // Clear running total
          totalCargo = 0;
          cwHistory.innerHTML    = '';
          cwTotalEl.textContent  = 'Total: 0 lbs';
          cwMinus.disabled       = true;
          // Clear advanced cargo chips
          advLines.innerHTML     = '';
          manifestId.value       = '';
          unlockButtons();
          return; /* skip the outbound “success row” build */
      }

      const allBlank = ['tail_number','airfield_takeoff','airfield_landing',
                        'takeoff_time','eta','cargo_type','cargo_weight','remarks']
                       .every(k => !f[k] || f[k] === 'TBD');
      const rowClass = allBlank
        ? 'red-border'
        : (f.action === 'updated' ? 'blue-border' : 'green-border');

      feedbackBox.innerHTML = `
        <table class="full-bleed">
          <thead>
            <tr>
              <th>#</th><th>Code</th><th>Dir</th><th>Tail #</th><th>Pilot</th><th>PAX #</th>
              <th>Origin</th><th>${f.direction==='outbound'?'Dep':'Arr'} HHMM</th>
              <th>Dest</th><th>ETA</th><th>Cargo Type</th><th>Cargo Wt</th><th>Remarks</th>
            </tr>
          </thead>
          <tbody>
            <tr class="${rowClass}">
              <td>${f.id}</td>
              <td>${f.flight_code || 'TBD'}</td>
              <td>${f.direction}</td>
              <td>${f.tail_number}</td>
              <td>${f.pilot_name||'TBD'}</td>
              <td>${f.pax_count||'TBD'}</td>
              <td>${f.airfield_takeoff||'TBD'}</td>
              <td>${f.takeoff_time||''}</td>
              <td>${f.airfield_landing||'TBD'}</td>
              <td>${f.eta||'TBD'}</td>
              <td>${f.cargo_type||'TBD'}</td>
              <td>${f.cargo_weight||'TBD'}</td>
              <td>${f.remarks||''}</td>
            </tr>
          </tbody>
        </table>
      `;

      showToast('Flight sent','success');

      // Enable persistent Print Labels button and toast
      try {
        const fid = (f && (f.flight_id || f.id)) || (j && (j.flight_id || j.id));
        if (fid){ enablePrintLabelsButton(fid); showLabelsToast(fid); }
      } catch(_){}

      // auto-clear success after 5s so it doesn’t stick around
      setTimeout(() => { feedbackBox.innerHTML = ''; }, 5000);

      form.reset();
      applyDirUI();

      // reset running total
      totalCargo = 0;
      cwHistory.innerHTML = '';
      cwTotalEl.textContent = 'Total: 0 lbs';
      cwMinus.disabled = true;

      // chips/manifest cleared – ready for a fresh flight
      advLines.innerHTML = '';
      manifestId.value   = '';
      unlockButtons();
    });



    /* ───────────────── Cargo‑Weight mini‑panel ───────────────── */
    const cwPanel   = document.getElementById('cargo-tools-panel');
    const openCwBtn = document.getElementById('open-cw-tools');
    const cwBack    = document.getElementById('cw-back');
    const cwMinus   = document.getElementById('cw-minus');
    const cwPlus    = document.getElementById('cw-plus');
    const cwChange  = document.getElementById('cw-change');
    const cwHistory = document.getElementById('cw-history');
    const cwTotalEl = document.getElementById('cw-total');
    const cwApply   = document.getElementById('cw-apply');
    let   totalCargo = 0;

    function recordHistory (entry) {
      const div = document.createElement('div');
      div.textContent = entry;
      cwHistory.appendChild(div);
      cwHistory.scrollTop = cwHistory.scrollHeight;
    }

    if (openCwBtn) openCwBtn.addEventListener('click', () => {
      document.body.classList.toggle('cw-active');
      cwMinus.disabled = (totalCargo === 0);
    });
    if (cwBack)   cwBack.addEventListener('click',   () => document.body.classList.remove('cw-active'));
    if (cwApply)  cwApply.addEventListener('click',  () => {
      document.getElementById('cargo_weight').value = totalCargo;
      document.body.classList.remove('cw-active');
    });
    if (cwPlus)   cwPlus.addEventListener('click', () => {
      const val = parseFloat(cwChange.value);
      if (isNaN(val)) return showToast('Enter a valid number', 'error');
      const change = Math.ceil(val);
      if (totalCargo === 0) {
        totalCargo = change;
        recordHistory(`Initial: ${change} lbs`);
      } else {
        const prev = totalCargo;
        totalCargo += change;
        recordHistory(`${prev} + ${change} = ${totalCargo}`);
      }
      cwTotalEl.textContent = `Total: ${totalCargo} lbs`;
      cwMinus.disabled = false;
      cwChange.value = '';
    });
    if (cwMinus)  cwMinus.addEventListener('click', () => {
      const val = parseFloat(cwChange.value);
      if (isNaN(val)) return showToast('Enter a valid number', 'error');
      const change = Math.ceil(val);
      const prev = totalCargo;
      totalCargo = Math.max(0, totalCargo - change);
      recordHistory(`${prev} - ${change} = ${totalCargo}`);
      cwTotalEl.textContent = `Total: ${totalCargo} lbs`;
      cwChange.value = '';
      if (totalCargo === 0) cwMinus.disabled = true;
    });
  </script>

  <!-- initial stock snapshot for Advanced panel -->
  <script>
    let inventoryAdvancedData = {{ advanced_data|tojson }};
  </script>

<!-- ───────────────── Advanced‑panel JS (poll only while open) ───────────────── -->
<script>
// Bind the launcher right now if the node exists, otherwise bind on DOM ready.
(function bindAdvButton(){
  function attach(){
    const advBtn = document.getElementById('open-adv');
    if (advBtn && !advBtn.dataset.bound) {
      advBtn.addEventListener('click', startAdvanced);
      advBtn.dataset.bound = '1';
    }
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attach);
  } else {
    attach();
  }
})();
  const advPanel   = document.getElementById('adv-panel');
  const advBack    = document.getElementById('adv-back');
  const advCat     = document.getElementById('adv-category');
  const advItem    = document.getElementById('adv-item');
  const advSize    = document.getElementById('adv-size');
  const advDirOut  = document.getElementById('adv-dir-out');
  const advDirIn   = document.getElementById('adv-dir-in');
  const advName    = document.getElementById('adv-name');
  const advWeight  = document.getElementById('adv-weight');
  const advWunit   = document.getElementById('adv-wunit');
  const advQty     = document.getElementById('adv-qty');
  const advAdd     = document.getElementById('adv-add-line');
  const advLines   = document.getElementById('adv-lines');
  const advDone    = document.getElementById('adv-done');
  const advMode    = document.getElementById('advanced-mode');
  const advFooterRow = document.getElementById('adv-footer-row');
  const advUnitsPill = document.getElementById('adv-units-pill');

  /* Ensure the Units pill renders to the RIGHT of the total-weight pill.
     If a total-weight pill exists (various ids/classes used across builds),
     move it (and the Units pill) into the footer row in the desired order:
       [Done] [Total-Weight Pill] [Units Pill]                                       */
  function placeUnitsPill(){
    try{
      const footer = document.getElementById('adv-footer-row') || advFooterRow;
      const units  = document.getElementById('adv-units-pill') || advUnitsPill;
      if (!footer || !units) return;
      const done   = document.getElementById('adv-done');
      const weight = document.querySelector('#adv-panel #adv-total-pill, #adv-panel #adv-total, #adv-panel .adv-total-pill, #adv-panel [data-role="adv-total"]');
      if (done   && done.parentNode   !== footer) footer.appendChild(done);
      if (weight && weight.parentNode !== footer) footer.appendChild(weight);
      if (units  && units.parentNode  !== footer) footer.appendChild(units);
    }catch(_){}
  }
  window._rbPlaceUnitsPill = placeUnitsPill;
  // Guard C: in-flight delete lock per (name|wpu) so ❌ can't double-fire
  window.__RB_DELETING = window.__RB_DELETING || new Set();
  const rbForm     = document.getElementById('rb-form');
  // Guard A: keys that reached zero this session (prevents respawn in forced-snapshot)
  window.__RB_ZEROED = window.__RB_ZEROED || new Set();
  // Guard A.1: one-shot clamp for the *first* add after ZERO so UI shows ×1 (no 0→2 jump)
  window.__RB_REHYDRATED_ONCE = window.__RB_REHYDRATED_ONCE || new Set();
  // Guard B: original baseline qty per key from queued snapshot
  //          (prevents “baseline echo” repaint if the chip is momentarily absent)
  window.__RB_SNAPSHOT_BASE = window.__RB_SNAPSHOT_BASE || new Map();
  let   advStarting = false;
  /* Reuse globals declared in the main script block:
   - csrfToken (from the hidden CSRF field)
   - manifestId (the hidden manifest/session id) */
  let   pendingIds = [];
  let   removedIds = [];      /* ids of compensating rows created by deletes */
  let   snapshot   = null;    /* chip HTML + header fields on panel-open    */
  let   advDirty   = false;   /* ⇢ NEW: true as soon as user changes chips  */
  /* Scanner readiness gate: block scans until a fresh inventory snapshot is loaded */
  let SCAN_READY_RESOLVE = null;
  let SCAN_READY = new Promise(res => { SCAN_READY_RESOLVE = res; });
  let RB_DRAFT_SEEDED = false;  /* seed queued snapshot at most once per manifest */

  /* ───── Availability index: (normalized name, numeric size) → total avail ───── */
  let AVAIL_INDEX = new Map();
  // Tracks every (item,size) pair that exists at all, even when avail prunes to 0
  let KNOWN_KEYS  = new Set();
  function normName(s){
    return String(s||'')
      .toLowerCase()
      .replace(/&/g,'and')
      .replace(/[^a-z0-9]+/g,' ')
      .replace(/\s+/g,' ')
      .trim();
  }
  // Global helper to compare chip vs key
  function sameKey(chip, name, wpu){
    const cName = (chip.dataset.sanitized || '').trim().toLowerCase();
    const cWpu  = Number(chip.dataset.wpu || 0);
    return cName === String(name||'').trim().toLowerCase()
           && Math.abs(cWpu - Number(wpu)) < 1e-9;
  }

  // ───── Category helpers for chips (used to drive Cargo Type) ─────
  function _allCategoriesList(){
    return (inventoryAdvancedData?.all_categories
            || inventoryAdvancedData?.categories
            || inventoryAdvancedData?.stock_categories
            || []);
  }
  function _catNameById(cid){
    const cidStr = String(cid);
    const c = _allCategoriesList().find(x => String(x.id) === cidStr);
    return c ? c.display_name : '';
  }
  // Best-effort: find category display name that contains this item
  function _guessCatForItem(itemName){
    const itemsMap = inventoryAdvancedData?.items || {};
    const target   = normName(itemName);
    for (const cid of Object.keys(itemsMap)){
      if ((itemsMap[cid] || []).some(n => normName(n) === target)) return _catNameById(cid);
    }
    return '';
  }

  /* Reverse lookups for category requirements on client-minted compensators */
  function _catIdByName(catName){
    if (!catName) return null;
    const s = String(catName).trim().toLowerCase();
    const list = _allCategoriesList();
    const c = (list||[]).find(x => String(x.display_name||'').trim().toLowerCase() === s);
    return c ? Number(c.id) : null;
  }
  function _catIdForItem(itemName){
    const itemsMap = inventoryAdvancedData?.items || {};
    const target = normName(itemName);
    for (const cid of Object.keys(itemsMap)){
      const arr = itemsMap[cid] || [];
      if (arr.some(n => normName(n) === target)) return Number(cid);
    }
    return null;
  }
  /* Best available category id for a (name,wpu) key. */
  function _resolveCategoryIdForKey(name, wpu){
    // 1) prefer the visible chip’s category name → id
    const ch = (typeof findChipByKey==='function' && findChipByKey(name, wpu))
            || (typeof findBaselineChip==='function' && findBaselineChip(name, wpu))
            || (typeof findDeltaChip==='function' && findDeltaChip(name, wpu)) || null;
    if (ch){
      const byName = _catIdByName(ch.dataset.cat||'');
      if (byName) return byName;
    }
    // 2) items map, 3) last selected, 4) first category as last resort
    return _catIdForItem(name) || _catIdByName(window._lastCatName||'') || Number((_allCategoriesList()||[])[0]?.id ?? NaN);
  }

  // Delete-by-key (client-governed compensators):
  //  • Compute NET from the on-screen chips.
  //  • If NET>0 ⇒ mint one INBOUND compensator (qty=NET) then delete the key (no server auto-comp).
  //  • If NET<0 ⇒ mint one OUTBOUND compensator via /nudge (qty=|NET|) then delete the key (no server auto-comp).
  //  • Remove all chips, refresh totals/remarks/stock.
  async function deleteByKey(name, wpu){
    // Per-key reentry guard (prevents double compensation & double delete)
    const gateKey = `${normName(name)}|${Number(wpu)}`;
    if (window.__RB_DELETING.has(gateKey)) return;
    window.__RB_DELETING.add(gateKey);
    try {
    const mid = manifestId.value;
    if (!mid) return;
    // Clear any UI clamp offset applied to this key
    try {
      if (window.__RB_CLAMP_OFFSETS) {
        window.__RB_CLAMP_OFFSETS.delete(`${normName(name)}|${Number(wpu)}`);
      }
    } catch(_){}

    // Compute NET from on-screen state
    const net = computeNetForKey(name, wpu);

    // ── Snapshot guard: only compensate what happened *this session*.
    // Baseline (from the queued draft) must NOT be compensated.
    const inSnapshot = !!window.__RB_FORCE_SNAPSHOT;
    const baseMap = window.__RB_SNAPSHOT_BASE || new Map();
    const baseQty = Number(baseMap.get(`${normName(name)}|${Number(wpu)}`) || 0);
    // How much should we actually put back INBOUND?
    //  - live mode: everything (net)
    //  - snapshot mode: only the session delta above baseline
    const compInboundQty = Math.max(0, net - (inSnapshot ? baseQty : 0));

    // Fast path: nothing to undo (usually hidden X in this state, but safe)
    // We still delete the key rows to keep the manifest tidy.
    async function postDeleteNoComp(){
      const r = await fetch(`/api/manifest/${encodeURIComponent(mid)}/delete_key`, {
        method: 'POST',
        headers: xhrHeaders({ 'Content-Type':'application/json' }),
        body: JSON.stringify({
          sanitized_name: name,
          weight_per_unit: Number(wpu),
          draft_id: (typeof draftId !== 'undefined' ? draftId : null),
          flight_id: (typeof flightId !== 'undefined' ? flightId : null),
          // explicit: do NOT let server mint compensators
          prefer_compensate: false
        })
      });
      if (!r.ok) throw new Error('delete_key failed');
    }

    // 1) Apply client-minted compensator if needed
    if (compInboundQty > 0){
      // We took `net` out → put it back INBOUND in one shot (requires category), then commit.
      const catId = _resolveCategoryIdForKey(name, wpu);
      if (!(Number.isFinite(catId) && catId > 0)){
        showToast('Delete aborted — need a category for the compensator. Pick a category and retry.', 'error');
        return;
      }
      const params = new URLSearchParams({
        csrf_token:  csrfToken,
        action:      'add',
        manifest_id: mid,
        direction:   'inbound',
        category:    String(catId),
        // inbound: free-entry fields
        name:        name,
        weight:      String(Number(wpu)),
        wunit:       'lbs',
        qty:         String(compInboundQty)
      });
      let ok = false;
      try { console.debug?.('[X-delete] inbound compensator', { name, wpu:Number(wpu), qty:compInboundQty, category_id:catId, baseQty, inSnapshot }); } catch(_){}
      try {
        const addRes = await fetch("{{ url_for('inventory.inventory_advance_line') }}", {
          method: 'POST',
          body:   params
        });
        if (!addRes.ok) throw new Error('inbound compensator add failed');
        // Commit immediately so stock is corrected now
        const commitRes = await fetch("{{ url_for('inventory.inventory_advance_line') }}", {
          method:'POST',
          body: new URLSearchParams({
            csrf_token : csrfToken,
            action     : 'commit',
            manifest_id: mid
          })
        });
        if (!commitRes.ok) throw new Error('inbound compensator commit failed');
        ok = true;
      } catch(_){
        showToast('Delete aborted — failed to apply inbound compensator.', 'error');
        return;
      }
      if (!ok) { showToast('Delete aborted — compensator error.', 'error'); return; }
    }
    else if (net < 0){
      // We brought |net| IN → take it back OUT via /nudge (structured remove).
      const qty = Math.abs(net);
      try { console.debug?.('[X-delete] outbound compensator (nudge)', { name, wpu:Number(wpu), qty }); } catch(_){}
      try{
        const r = await fetch(`/api/manifest/${encodeURIComponent(mid)}/nudge`, {
          method: 'POST',
          headers: xhrHeaders({ 'Content-Type':'application/json' }),
          body: JSON.stringify({
            sanitized_name: name,
            weight_per_unit: Number(wpu),
            qty,
            op: 'remove',
            draft_id: (typeof window.draftId === 'number' ? window.draftId : null)
          })
        });
        if (!r.ok) throw new Error('outbound compensator (nudge) failed');
      } catch(_){
        showToast('Delete aborted — failed to apply outbound compensator.', 'error');
        return;
      }
    }
    // else net === 0 → no compensator

    // 2) Delete the key WITHOUT server-side auto-compensation
    try {
      await postDeleteNoComp();
    } catch(_){
      showToast('Delete failed on server.', 'error');
      return;
    }
    } finally {
      // always release the per-key delete gate
      window.__RB_DELETING.delete(gateKey);
    }

    // Snapshot: mark this key as “zeroed” so it won’t respawn on next refresh
    try {
      if (window.__RB_FORCE_SNAPSHOT) (window.__RB_ZEROED = window.__RB_ZEROED || new Set()).add(gateKey);
    } catch(_){}

    // 3) Remove all matching chips (baseline + any Δ) from the DOM
    removeChipsForKey(name, wpu);
    // Refresh chips/remarks and stock UI without calling scoped functions
    try { if (window._rbScanRefresh) await window._rbScanRefresh(); } catch(_){}
    try { await fetchInventory(); } catch(_){}
    try { if (window.refreshFromDOM) window.refreshFromDOM(); } catch(_){}
    try { advDirty = true; advDone.disabled = false; } catch(_){}
    try { applyMatchingBorders(); } catch(_){}

    // Hint message reflecting what we just did
    try {
      if (net > 0) {
        if (inSnapshot && compInboundQty === 0) {
          showToast(`Removed "${name}" (${wpu} lb). No stock change (baseline only).`, 'info');
        } else {
          showToast(`Removed "${name}" (${wpu} lb) — returned ×${compInboundQty} to stock.`, 'success');
        }
      } else if (net < 0) {
        showToast(`Removed "${name}" (${wpu} lb) — took ×${Math.abs(net)} back out of stock.`, 'success');
      } else {
        showToast(`Removed "${name}" (${wpu} lb). No stock change.`, 'info');
      }
    } catch(_){}
  }
  function rebuildAvailIndex(){
    const idx = new Map();
    const known = new Set();
    try{
      const avail = inventoryAdvancedData?.avail || {};
      for (const cid of Object.keys(avail)){
        const byItem = avail[cid] || {};
        for (const itemName of Object.keys(byItem)){
          const n = normName(itemName);
          const sizes = byItem[itemName] || {};
          for (const szKey of Object.keys(sizes)){
            const num = Number(szKey);              // tolerate "1.50" vs "1.5"
            const base = `${n}|${num}`;
            const val  = Number(sizes[szKey]||0);
            idx.set(base, (idx.get(base)||0) + val);   // sum across cats if duplicated
            // tolerant aliases so minor string/float diffs still match
            idx.set(`${n}|${String(num)}`, idx.get(base));
            idx.set(`${n}|${num.toFixed(3).replace(/0+$/,'').replace(/\.$/,'')}`, idx.get(base));
            // exact raw-string size key from JSON (avoids FP drift like 0.5975)
            idx.set(`${n}|${szKey}`, idx.get(base));
            // remember every variant as "known"
            known.add(base);
            known.add(`${n}|${String(num)}`);
            known.add(`${n}|${num.toFixed(3).replace(/0+$/,'').replace(/\.$/,'')}`);
            known.add(`${n}|${szKey}`);
          }
        }
      }
      // ⬇️ Ensure zero entries exist for every known (item,size) from `sizes`
      const sizesAll = inventoryAdvancedData?.sizes || {};
      for (const cid of Object.keys(sizesAll)){
        const byItem = sizesAll[cid] || {};
        for (const itemName of Object.keys(byItem)){
          const n = normName(itemName);
          const arr = byItem[itemName] || [];
          const sizeKeys = Array.isArray(arr) ? arr : Object.keys(arr); // accept array or object
          for (const szKey of sizeKeys){
            const num = Number(szKey);
            const keys = [
              `${n}|${szKey}`,
              `${n}|${String(num)}`,
              `${n}|${num.toFixed(3).replace(/0+$/,'').replace(/\.$/,'')}`
            ];
            keys.forEach(k => {
              known.add(k); // mark as known even if not currently available
              if (!idx.has(k)) idx.set(k, 0);
            });
          }
        }
      }
    }catch(_){}
    AVAIL_INDEX = idx;
    KNOWN_KEYS  = known;
    try { applyMatchingBorders(); } catch(_){}
  }

  /* ────────────────────────────────────────────────────────────────
   * Step 6 — Inventory Matching Rules (Green / Green Dashed / Plain)
   * For each requested item (by sanitized_name):
   *   • Solid green border   → available_lb ≥ outstanding_lb
   *   • Dashed green border  → some presence but insufficient, OR weight unknown
   *   • No border            → no matching item in current inventory
   * Notes:
   *   • Preview-only indicator — does not perform fulfillment.
   *   • Availability sourced from /inventory/_advance_data (inventoryAdvancedData).
   *   • Outstanding considers the net request on screen (baseline ± Δ).
   * ──────────────────────────────────────────────────────────────── */
  function _norm(s){ return String(s||'').toLowerCase().replace(/&/g,'and').replace(/[^a-z0-9]+/g,' ').replace(/\s+/g,' ').trim(); }

  function _outstandingByNameLbs(){
    const map = new Map();
    const chips = document.querySelectorAll('#adv-lines .adv-chip');
    chips.forEach(ch => {
      const name = (ch.dataset.sanitized || '').trim();
      if (!name) return;
      let wpu = Number(ch.dataset.wpu || NaN);
      if (!Number.isFinite(wpu)) {
        const wtxt = ch.querySelector('.chip-wpu')?.textContent || '';
        const m = wtxt.match(/(\d+(?:\.\d+)?)/);
        wpu = m ? Number(m[1]) : 0;
      }
      let qty = Number(ch.dataset.effective ?? ch.dataset.qty ?? NaN);
      if (!Number.isFinite(qty)) qty = 0;
      if (ch.dataset.delta === '1') {
        const sgn = (ch.dataset.deltaSign === '-1') ? -1 : 1;
        qty = sgn * qty;
      }
      const lbs = wpu * qty;
      const key = _norm(name);
      map.set(key, (map.get(key) || 0) + lbs);
    });
    // Only "requests" matter → clamp negatives to 0 (net inbound doesn't need stock)
    for (const [k,v] of map.entries()){
      map.set(k, Math.max(0, v));
    }
    return map;
  }

  function _availabilityForNameLbs(name){
    // Sum across categories and sizes: qty * weight_per_unit
    let availLb = 0;
    let presence = false;
    let unknownWeight = false;
    try{
      const target = _norm(name);
      const avail = inventoryAdvancedData?.avail || {};
      for (const cid of Object.keys(avail)){
        const byItem = avail[cid] || {};
        for (const rawName of Object.keys(byItem)){
          if (_norm(rawName) !== target) continue;
          const sizes = byItem[rawName] || {};
          for (const sizeKey of Object.keys(sizes)){
            const qty = Number(sizes[sizeKey] || 0);
            if (qty <= 0) continue;
            presence = true;
            const wpu = Number(sizeKey);
            if (Number.isFinite(wpu)) {
              availLb += (wpu * qty);
            } else {
              unknownWeight = true;
            }
          }
        }
      }
    }catch(_){}
    return { availLb, presence, unknownWeight };
  }

  function applyMatchingBorders(){
    // Only meaningful for outbound requests; clear borders otherwise.
    const dirRadio = document.querySelector('input[name="adv_direction"]:checked')
                   || document.getElementById('adv-dir-out');
    const isOutbound = !!(dirRadio && dirRadio.value === 'outbound' && dirRadio.checked);
    const chips = document.querySelectorAll('#adv-lines .adv-chip');
    const clearAll = () => chips.forEach(ch => { ch.classList.remove('match-ok','match-partial'); });
    if (!isOutbound) { clearAll(); return; }

    const need = _outstandingByNameLbs();  // Map(normName → lbs)
    // First, clear everything
    clearAll();
    // For each requested name with > 0 lbs outstanding, decide border class
    for (const [n, outstandingLb] of need.entries()){
      if (outstandingLb <= 0) continue;
      const { availLb, presence, unknownWeight } = _availabilityForNameLbs(n);
      let cls = null;
      if (!presence) {
        cls = null;                        // no border
      } else if (unknownWeight || availLb < outstandingLb) {
        cls = 'match-partial';             // dashed
      } else {
        cls = 'match-ok';                  // solid
      }
      // Apply to all chips of this name (across sizes)
      document.querySelectorAll('#adv-lines .adv-chip').forEach(ch => {
        const cName = _norm(ch.dataset.sanitized || '');
        if (cName !== n) return;
        if (!cls) {
          ch.classList.remove('match-ok','match-partial');
        } else {
          ch.classList.remove('match-ok','match-partial');
          ch.classList.add(cls);
        }
      });
    }
  }

  // Run once on load (initial snapshot), then subsequent calls are triggered by:
  //  • stock refresh → rebuildAvailIndex(), and
  //  • chip edits/scan adds/removes → calls sprinkled above.
  document.addEventListener('DOMContentLoaded', () => {
    try { rebuildAvailIndex(); applyMatchingBorders(); } catch(_){}
  });

  /* ───────── Scanner glue (build/edit outbound manifest) ───────── */
  (function setupScanner(){
    if (!document.getElementById('rb-scan')) return;
    const root    = document.getElementById('rb-scan');
    const inp     = document.getElementById('rb-scan-input');
    if (inp) inp.disabled = true;
    /* Chips are rendered into the unified Advanced chip list (#adv-lines)
       so scanner + classic adds look the same. */
    const chipsRoot = document.getElementById('adv-lines');
    const fb      = document.getElementById('rb-scan-feedback');
    let   fbTimer = null;
    const btnAdd  = document.getElementById('rb-scan-mode-add');
    const btnRem  = document.getElementById('rb-scan-mode-remove');
    let   scanBusy = false;   /* prevent overlapping posts/enforcement */
    let mode = 'add';

    /* NEW: remember last known availability per (name|wpu) for this session */
    const SESSION_AVAIL_CAPS = new Map();
    /* NEW: dedupe identical scans arriving within a tiny window */
    const SCAN_DEDUP_MS = 200;
    let   lastScan = { code:'', t:0 };
    /* Session cache: map barcode → key "sanitized_name|wpu"
       so we can pre-block remove scans at/below zero without hitting the backend. */
    const BARCODE_TO_KEY = window.__RB_BARCODE_MAP || (window.__RB_BARCODE_MAP = new Map());
    const CLAMP_OFFSETS  = window.__RB_CLAMP_OFFSETS || (window.__RB_CLAMP_OFFSETS = new Map());

    function setFB(txt, cls, ttlMs){
      if (!fb) return;
      fb.textContent = txt || '';
      fb.classList.remove('scan-ok','scan-warn','scan-err');
      if (cls) fb.classList.add(cls);
      if (fbTimer) { clearTimeout(fbTimer); fbTimer = null; }
      if (ttlMs) {
        fbTimer = setTimeout(() => setFB('', null), ttlMs);
      }
    }

    function uuid4(){
      return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c/4).toString(16)
      );
    }
    function ensureManifestId(){
      if (!manifestId.value) {
        manifestId.value = uuid4();
        RB_DRAFT_SEEDED = false;  /* new session → allow one seed */
      }
      return manifestId.value;
    }
    function setMode(m){
      mode = (m === 'remove') ? 'remove' : 'add';
      btnAdd.classList.toggle('is-active', mode==='add');
      btnRem.classList.toggle('is-active', mode==='remove');
      inp && inp.focus();
    }
    btnAdd && (btnAdd.onclick = ()=>setMode('add'));
    btnRem && (btnRem.onclick = ()=>setMode('remove'));

    /* key helper for matching chips 1:1 with aggregated items (use same normalization as index) */
    const keyOf = (name,wpu)=> `${normName(name)}|${Number(wpu)}`;
    function findChipByKey(name, wpu){
      const k = keyOf(name, wpu);
      return [...chipsRoot.querySelectorAll('.adv-chip')]
              .find(ch => ch.dataset.key === k) || null;
    }

    /* Aggregate all chips (manual + scanned) by key→qty so we can compare against avail */
    function qtyMapFromChips(){
      const m = new Map();
      chipsRoot.querySelectorAll('.adv-chip').forEach(ch => {
        const name = (ch.dataset.sanitized || '').trim();
        let wpu    = Number(ch.dataset.wpu || NaN);
        if (Number.isNaN(wpu)) {
          const txt = ch.querySelector('.chip-wpu')?.textContent || '';
          const mm  = txt.match(/(\d+(?:\.\d+)?)/);
          wpu = mm ? Number(mm[1]) : 0;
        }
        // Prefer the snapshot-safe effective qty; fall back to legacy data-qty.
        // Do NOT default to 1.
        const qtyStr = (ch.dataset.effective ?? ch.dataset.qty ?? '');
        const qty    = Number(qtyStr);
        if (Number.isNaN(qty)) return; // treat as 0 by omission
        const k    = keyOf(name, wpu);
        m.set(k, (m.get(k) || 0) + qty);
      });
      return m;
    }

    /* Net map (baseline + signed deltas). Δ+ counts positive; Δ− counts negative. */
    function netQtyMapFromChips(){
      const m = new Map();
      chipsRoot.querySelectorAll('.adv-chip').forEach(ch => {
        const name = (ch.dataset.sanitized || '').trim();
        let wpu    = Number(ch.dataset.wpu || NaN);
        if (Number.isNaN(wpu)) {
          const txt = ch.querySelector('.chip-wpu')?.textContent || '';
          const mm  = txt.match(/(\d+(?:\.\d+)?)/);
          wpu = mm ? Number(mm[1]) : 0;
        }
        let qty = Number(ch.dataset.effective ?? ch.dataset.qty ?? '');
        if (Number.isNaN(qty)) return;
        if (ch.dataset.delta === '1') {
          const s = (ch.dataset.deltaSign === '-1') ? -1 : 1;
          qty = s * qty;
        }
        const k = keyOf(name, wpu);
        m.set(k, (m.get(k) || 0) + qty);
      });
      return m;
    }

    /* Find “how many available” for a given key=name|wpu using the normalized index */
    function availForKey(k){
      try{
        const [nameLower, wpuStr] = String(k).split('|');
        const n = normName(nameLower);
        // prefer exact raw string first (e.g., "0.5975")
        const directExact = AVAIL_INDEX.get(`${n}|${wpuStr}`);
        if (typeof directExact === 'number') return directExact;
        // normalised numeric string next
        const s = String(Number(wpuStr));
        const direct = AVAIL_INDEX.get(`${n}|${s}`);
        if (typeof direct === 'number') return direct;
        // float-tolerance fallback (e.g., 1.50 vs 1.5)
        for (const [kk, val] of AVAIL_INDEX.entries()){
          const [nm, sz] = kk.split('|');
          if (nm === n && Math.abs(Number(sz) - Number(s)) < 1e-6) return val;
        }
        // If the size exists in our catalogue (KNOWN_KEYS) but isn't in AVAIL_INDEX,
        // treat it as 0 available instead of "unknown".
        const variants = [
          `${n}|${wpuStr}`,
          `${n}|${String(Number(wpuStr))}`,
          `${n}|${Number(wpuStr).toFixed(3).replace(/0+$/,'').replace(/\.$/,'')}`
        ];
        if (variants.some(v => KNOWN_KEYS.has(v))) return 0;
        // Fallback to any remembered session cap
        for (const v of variants){
          if (SESSION_AVAIL_CAPS.has(v)) return SESSION_AVAIL_CAPS.get(v);
        }
      }catch(_){}
      // FAIL-CLOSED: unknown → treat as 0 available
      return 0;
    }
    /* Which key increased after a scan? (compare before vs after maps) */
    function increasedKey(beforeMap, afterMap){
      for (const [k, afterQty] of afterMap.entries()){
        const beforeQty = beforeMap.get(k) || 0;
        if (afterQty > beforeQty) return k;
      }
      return null;
    }
    /* Which key changed (increased or decreased) after an operation? */
    function changedKey(beforeMap, afterMap){
      const all = new Set([...beforeMap.keys(), ...afterMap.keys()]);
      for (const k of all){
        if ((beforeMap.get(k)||0) !== (afterMap.get(k)||0)) return k;
      }
      return null;
    }

    function setChipOriginByKey(keyOrName, maybeWpu, origin){
      let key = keyOrName;
      if (typeof maybeWpu !== 'undefined' && typeof origin !== 'undefined'){
        key = keyOf(keyOrName, maybeWpu);
      } else {
        origin = maybeWpu;
      }
      const chip = [...chipsRoot.querySelectorAll('.adv-chip')]
        .find(ch => ch.dataset.key === key);
      if (!chip) return;
      chip.dataset.lastOrigin = (origin === 'scanner') ? 'scanner' : 'manual';
      const tag = chip.querySelector('.chip-origin');
      if (tag) tag.textContent = (chip.dataset.lastOrigin === 'scanner') ? '(scanned)' : '';
    }
    /* Remove N units for the same barcode to undo an overage */
    async function undoOverage(barcode, count){
      // Use /nudge so we never mint compensators via /scan removes.
      const mid = encodeURIComponent(ensureManifestId());
      for (let i=0; i<count; i++){
        await fetch(`/api/manifest/${mid}/nudge`, {
          method:'POST',
          headers: xhrHeaders({ 'Content-Type':'application/json' }),
          body: JSON.stringify({
            barcode,
            op: 'remove',
            qty: 1,
            draft_id: (typeof window.draftId === 'number' ? window.draftId : null)
          })
        }).catch(()=>{});
      }
    }
    /* NEW: reverse an over-remove by re-adding units (client clamp to zero) */
    async function undoUnderflow(barcode, count){
      for (let i=0; i<count; i++){
        await fetch(`/api/manifest/${encodeURIComponent(ensureManifestId())}/scan`, {
          method:'POST',
          headers: xhrHeaders({ 'Content-Type':'application/json' }),
          body: JSON.stringify({ barcode, mode:'add' })
        }).catch(()=>{});
      }
    }

    function upsertScanChip(item){
      const name = item.sanitized_name;
      const wpu  = Number(item.weight_per_unit);
      const qty  = Number(item.qty||0);
      const tot  = Math.round(wpu * qty * 100) / 100;
      // Prefer a baseline chip; if only a Δ chip exists, rehydrate it to baseline
      let chip   = (typeof window.findBaselineChip === 'function')
                     ? window.findBaselineChip(name, wpu)
                     : null;
      if (!chip && typeof window.findDeltaChip === 'function') {
        const d = window.findDeltaChip(name, wpu);
        if (d) {
          try {
            // strip delta markers so CSS no longer hides it
            d.removeAttribute('data-delta');
            delete d.dataset.delta;
            delete d.dataset.deltaSign;
          } catch(_){}
          chip = d;
        }
      }
      // Fallback: no chip at all — create a fresh baseline chip
      if (!chip) chip = findChipByKey(name, wpu);
      // Try to carry a category for this chip so Cargo Type can be derived later.
      // Prefer server-provided category_name, else infer from local inventory map.
      const catName = (item.category_name || item.category || _guessCatForItem(name) || '');
      if (!chip){
        chip = document.createElement('div');
        chip.className = 'adv-chip';
        chip.style.minWidth   = '180px';
        chipsRoot.appendChild(chip);
      }
      chip.dataset.key       = keyOf(name, wpu);
      chip.dataset.sanitized = name;
      chip.dataset.wpu       = String(wpu);
      chip.dataset.cat       = catName;
      chip.dataset.qty       = String(qty);
      chip.dataset.total     = String(tot);
      chip.innerHTML = `
        <span class="chip-content">${name}</span>
        <span class="chip-origin" style="margin-left:.35rem;font-size:.85em;opacity:.75;"></span>
        <button class="chip-remove" title="Remove whole line">❌</button><br>
        <span class="chip-wpu">${wpu} lb</span> <span class="chip-qty">×${qty}</span><br>
        <span class="chip-total">= ${tot} lb</span>
      `;
      // Make sure totals stay correct if qty/WPU changes later
      try { recalcChipTotal(chip); } catch(_){}
      // If a lastOrigin is already set on this chip, render the badge accordingly
      const tag = chip.querySelector('.chip-origin');
      if (tag) tag.textContent = (chip.dataset.lastOrigin === 'scanner') ? '(scanned)' : '';
      // Maintain a running set of categories seen this session
      window._rbCategories = window._rbCategories || new Set();
      if (catName) window._rbCategories.add(catName);
      const removeBtn = chip.querySelector('.chip-remove');
      if (removeBtn && !removeBtn.dataset.boundDelete){
        removeBtn.dataset.boundDelete = '1';
        removeBtn.onclick = async (ev) => {
          ev.preventDefault();
          await deleteByKey(name, wpu);   // deletes the entire (name,size) line safely
        };
      }
    }
    // Expose for external callers (e.g., loadExistingManifest)
    window._rbUpsertChip = upsertScanChip;

    // ─── Signed Δ chip (one per key): deltaSign = +1 (adds) or -1 (removes) ───
    function upsertDeltaChip({ sanitized_name, weight_per_unit, qty, category_name, deltaSign }){
      const name = sanitized_name;
      const wpu  = Number(weight_per_unit);
      const qAbs = Math.max(0, Number(qty||0));
      if (!name || !wpu || qAbs === 0) return;
      let chip = findDeltaChip(name, wpu);
      const sign = (deltaSign === -1 || deltaSign === '-1') ? -1 : 1;
      const tot  = Math.round(wpu * qAbs * 100) / 100;
      if (!chip){
        chip = document.createElement('div');
        chip.className = 'adv-chip';
        chip.style.minWidth = '180px';
        chip.dataset.delta   = '1';
        chip.dataset.sanitized = name;
        chip.dataset.wpu       = String(wpu);
        document.getElementById('adv-lines').appendChild(chip);
      }
      chip.dataset.deltaSign = (sign === -1 ? '-1' : '1');
      chip.dataset.cat       = category_name || chip.dataset.cat || '';
      chip.dataset.qty       = String(qAbs);
      chip.dataset.total     = String(tot);              // absolute; sum uses sign
      const badge = (sign === 1 ? 'Δ+' : 'Δ−');
      chip.innerHTML = `
        <span class="chip-content">${name}</span>
        <span class="chip-origin" style="margin-left:.35rem;font-size:.85em;opacity:.9;">${badge}</span>
        <button class="chip-remove" title="Remove whole line">❌</button><br>
        <span class="chip-wpu">${wpu} lb</span> <span class="chip-qty">×${qAbs}</span><br>
        <span class="chip-total">= ${sign === 1 ? '' : '−'}${tot} lb</span>
      `;
      try { recalcChipTotal(chip); } catch(_){}
      const removeBtn = chip.querySelector('.chip-remove');
      if (removeBtn){
        removeBtn.onclick = async (ev) => { ev.preventDefault(); await deleteByKey(name, wpu); };
      }
      return chip;
    }

    function pruneMissingScanChips(seenKeys){
      [...chipsRoot.querySelectorAll('.adv-chip')]
        .forEach(ch => { if (!seenKeys.has(ch.dataset.key)) ch.remove(); });
    }
    function rebuildTotalsAndRemarks(){
      try { if (window.refreshFromDOM) window.refreshFromDOM(); } catch(_){}
      const chips = [...chipsRoot.querySelectorAll('.adv-chip')];
      const total = chips.reduce((s,c)=>{
        const base = Number(c.dataset.total || 0); // absolute stored
        if (c.dataset.delta === '1') {
          const sign = (c.dataset.deltaSign === '-1') ? -1 : 1;
          return s + sign * base;
        }
        return s + base;
      }, 0);
      const cw    = document.getElementById('cargo_weight');
      const rmf   = document.getElementById('remarks');
      if (cw)  cw.value = total;
      if (rmf) rmf.value = buildManifestTextFromChips(chips);

      /* ► NEW: total units pill (net units, signed like weight; clamped ≥0 for display) */
      const units = chips.reduce((s,c)=>{
        let q = Number(c.dataset.effective ?? c.dataset.qty ?? 0);
        if (c.dataset.delta === '1') {
          const sign = (c.dataset.deltaSign === '-1') ? -1 : 1;
          q = sign * q;
        }
        return s + (Number.isFinite(q) ? q : 0);
      }, 0);
      const up = document.getElementById('adv-units-pill');
      if (up) up.textContent = `Units: ${Math.max(0, units)}`;

      /* Keep pill order correct (Done | Total-lbs | Units) */
      try { window._rbPlaceUnitsPill && window._rbPlaceUnitsPill(); } catch(_){}

      // ► Keep Cargo Type in sync with chip categories when available.
      try {
        const cargoField = document.getElementById('cargo_type');
        if (cargoField) {
          const cats = new Set(
            chips.map(c => (c.dataset.cat || '').trim()).filter(Boolean)
          );
          if (cats.size === 1) cargoField.value = [...cats][0];
          else if (cats.size > 1) cargoField.value = 'Mixed';
        }
      } catch(_) {}
      /* user has made a change via scanner → allow Done */
      if (typeof advDone !== 'undefined'){ advDone.disabled = false; }
      try { applyMatchingBorders(); } catch(_){}
    }

    async function refreshChips(){
      if (window._rbScanRefreshing) { return window._rbScanRefreshing; }
      window._rbScanRefreshing = (async () => {
      // session guard shared across blocks
      const ZEROED = (window.__RB_ZEROED = window.__RB_ZEROED || new Set());
      const mid = ensureManifestId();
      const did = (typeof window.draftId !== 'undefined' && window.draftId) ? Number(window.draftId) : null;
      /* Only include draft_id UNTIL we've seeded the queued snapshot once.
         Also omit while in forced-snapshot mode to avoid double counting. */
      const includeDraft = !!(did && !RB_DRAFT_SEEDED && !window.__RB_FORCE_SNAPSHOT);
      const qs  = includeDraft ? `?draft_id=${encodeURIComponent(did)}` : '';
      const url = `/api/manifest/${encodeURIComponent(mid)}/items${qs}`;
      let data;
      try {
        const r = await fetch(url, { headers: xhrHeaders() });
        if (!r.ok) return;
        data = await r.json();
        if (includeDraft) RB_DRAFT_SEEDED = true;
      } catch(_) { return; }
      const seen = new Set();
      const items = (data?.items || []);

      if (window.__RB_FORCE_SNAPSHOT) {
        /* Snapshot mode (baseline already painted by loadExistingManifest).
           Server `/items` returns session totals (seed + scans).
           Show the NET (session) qty on the baseline chip and remove any Δ chip.
           We do NOT create Δ− for removes; scans cap at zero. */
        items.forEach(it => {
          const name = it.sanitized_name;
          const wpu  = Number(it.weight_per_unit);
          const _k   = keyOf(name, wpu);
          seen.add(_k);
          const sessionQty = Number(it.qty || 0);
          // Apply any UI clamp offset so effective qty matches what we showed
          const off = (window.__RB_CLAMP_OFFSETS && window.__RB_CLAMP_OFFSETS.get(_k)) || 0;
          const visQty = Math.max(0, sessionQty - off);
          let baseChip   = findBaselineChip(name, wpu);
          // If the net session qty is zero or below, remove any existing chips,
          // remember as zeroed, and skip creation.
          if (visQty <= 0) {
            if (baseChip) { try { baseChip.remove(); } catch(_) {} }
            const d0 = findDeltaChip(name, wpu);
            if (d0)   { try { d0.remove(); } catch(_) {} }
            try { ZEROED.add(_k); } catch(_){}
            return; // ← do not re-create a chip at zero
          }
          if (!baseChip){
            /* 1) If a hidden Δ chip exists (CSS hides [data-delta="1"]), rehydrate it to a baseline chip
                  BEFORE any ZEROED/echo guards so the user sees the chip again. */
            if (typeof window.findDeltaChip === 'function') {
              const d = window.findDeltaChip(name, wpu);
              if (d){
                try { d.removeAttribute('data-delta'); delete d.dataset.delta; delete d.dataset.deltaSign; } catch(_){}
                baseChip = d;
              }
            }
            if (!baseChip){
              const recentAdd = (Date.now() - (window.__RB_LAST_ADD_TS || 0)) < 2000;
              // 2) If we *recently added* something, allow the first reappearance after zero by
              //    clearing ZEROED for this key and painting the baseline chip.
              if (ZEROED.has(_k)) {
                if (recentAdd) {
                  ZEROED.delete(_k);
                  // Clamp first paint after ZERO to a single step (or server-provided delta)
                  const REH = (window.__RB_REHYDRATED_ONCE = window.__RB_REHYDRATED_ONCE || new Set());
                  const qdelta = Number(it.qty_delta ?? it.delta ?? 1);
                  const basePaint  = (!REH.has(_k) && Number.isFinite(qdelta) && qdelta > 0) ? qdelta : sessionQty;
                  const paint = Math.max(0, basePaint - ((window.__RB_CLAMP_OFFSETS && window.__RB_CLAMP_OFFSETS.get(_k)) || 0));
                  REH.add(_k);
                  upsertScanChip({ ...it, qty: paint, total: Math.round(paint * wpu * 100)/100 });
                  try { console.debug('[RB-SNAPSHOT] rehydrated after recent add (clamped)', { name, wpu, paint, sessionQty }); } catch(_){}
                  return;
                }
                console.warn?.('[RB-SNAPSHOT] suppress respawn after zero', { name, wpu, sessionQty });
                return;
              }
              // 3) One-time “baseline echo” guard (server may briefly replay snapshot)
              try {
                const SNAP = (window.__RB_SNAPSHOT_BASE = window.__RB_SNAPSHOT_BASE || new Map());
                const base0 = SNAP.get(_k);
                if (typeof base0 === 'number' && sessionQty === base0) {
                  console.warn?.('[RB-SNAPSHOT] suppress baseline echo', { name, wpu, sessionQty, base0 });
                  return;
                }
              } catch(_) {}
              // 4) No chip at all → create a visible baseline chip for the net session qty
              upsertScanChip({ ...it, qty: visQty, total: Math.round(visQty * wpu * 100)/100 });
              try { console.debug('[RB-SNAPSHOT] no baseline; painted session chip', { name, wpu, sessionQty }); } catch(_){}
              return;
            } /* !baseChip after Δ rehydrate */
          }   /* !baseChip */
          // Helpful trace: show what we're merging for this key
          try {
            console.debug('[RB-SNAPSHOT] merge', {
              name, wpu,
              baseQty: baseChip ? (baseChip.dataset.qty || '') : '',
              baseEffective: baseChip ? (baseChip.dataset.effective || '') : '',
              sessionQty
            });
          } catch(_){}
          /* Update the visible baseline chip to show NET (session) qty,
             keep baseline immutable, and drop any Δ chip for this key. */
          try {
            setChipEffectiveOnly(baseChip, visQty);
            baseChip.dataset.total = String(Math.round(wpu * visQty * 100) / 100);
          } catch(_) {}
          const d = findDeltaChip(name, wpu);
          if (d) d.remove();
        });
        /* Do NOT prune while in snapshot mode — baseline chips must remain even
           when no new delta exists for a key. */
      } else {
        items.forEach(it => {
          upsertScanChip(it);
          seen.add(keyOf(it.sanitized_name, it.weight_per_unit));
        });
        pruneMissingScanChips(seen);
      }
      rebuildTotalsAndRemarks();
      })();
      try { await window._rbScanRefreshing; } finally { window._rbScanRefreshing = null; }
    }
    async function scan(barcode){
      if (scanBusy) return;
      // NEW: micro de-dup for twitchy scanners
      const now = Date.now();
      if (barcode === lastScan.code && (now - lastScan.t) < SCAN_DEDUP_MS) return;
      lastScan = { code: barcode, t: now };
      // If our probe snapshot is stale, refresh it first so the gate is authoritative.
      if (Date.now() - lastInventoryFetch > 5000) { try { await fetchInventory(); } catch(_){} }
      // Wait until we have at least one fresh inventory snapshot
      try { await SCAN_READY; } catch(_) {}
      scanBusy = true;
      // Before-scan snapshots
      const beforeRaw = qtyMapFromChips();
      const beforeNet = netQtyMapFromChips();
      const mid = ensureManifestId();
      // Decide endpoint and payload:
      //  Always send *removes* to /nudge so backend never mints inbound compensators at/below zero.
      //  Adds continue to use /scan.
      const useNudge = (mode === 'remove');
      // PRECHECK: if we already know which key this barcode maps to and it's at/below 0,
      // short-circuit the remove on the client so nothing reaches the backend.
      if (useNudge) {
        const k = BARCODE_TO_KEY.get(barcode);
        if (k) {
          const net = beforeNet.get(k) || 0;  // net qty BEFORE this scan
          if (net <= 0) {
            setFB('Nothing left to remove', 'scan-warn', 1500);
            scanBusy = false; return;
          }
        }
      }
      if (!useNudge) {
        // Preflight ADDs: if we already know the key and snapshot shows 0 avail, block before hitting backend
        const k = BARCODE_TO_KEY.get(barcode);
        if (k) {
          const availSnap = availForKey(k);
          if (typeof availSnap === 'number' && availSnap < 1) {
            setFB('Out of stock', 'scan-warn', 2000); scanBusy = false; return;
          }
        }
      }
      const endpoint = useNudge ? 'nudge' : 'scan';
      const payload  = (() => {
        if (useNudge) {
          return {
            barcode,
            op: 'remove',
            qty: 1,
            draft_id: (typeof window.draftId === 'number' ? window.draftId : null)
          };
        }
        const p = { barcode, mode };
        // Use draft_id exactly once to seed from queued snapshot.
        if (typeof window.draftId !== 'undefined' && window.draftId && !RB_DRAFT_SEEDED){
          p.draft_id = Number(window.draftId);
          // We'll flip RB_DRAFT_SEEDED below on success (only for /scan path).
        }
        return p;
      })();
      // Mark that an ADD just happened so snapshot refresh can override ZEROED once.
      if (!useNudge && mode === 'add') {
        try { window.__RB_LAST_ADD_TS = Date.now(); } catch(_) {}
      }
      let resp, j=null;
      try{
        resp = await fetch(`/api/manifest/${encodeURIComponent(mid)}/${endpoint}`, {
          method: 'POST',
          headers: xhrHeaders({ 'Content-Type':'application/json' }),
          body: JSON.stringify(payload)
        });
        try { j = await resp.clone().json(); } catch(_){}
        try {
          console.debug(
            useNudge ? '[RB-SCAN→NUDGE]' : '[RB-SCAN]',
            {
              endpoint,
              barcode,
              forceSnapshot: !!window.__RB_FORCE_SNAPSHOT,
              mode
            }
          );
        } catch(_){}
      }catch(_){ /* network error */ }
      if (!resp){
        setFB('Scan failed (network)', 'scan-err', 1500); scanBusy = false;
        return;
      }
      if (resp.status === 409) {
        setFB('Out of stock — reverted', 'scan-warn', 2500);
        scanBusy = false;
        return;
      }
      if (!resp.ok){
        if (j && (j.status === 'unknown' || j.error === 'unknown_barcode' || j.code === 'UNKNOWN_BARCODE')){
          setFB(`Unknown barcode: ${barcode}`, 'scan-warn');
        } else {
          setFB(`Scan error (${resp.status})`, 'scan-err', 2500);
        }
        setTimeout(()=> setFB('', null), 2500);
        scanBusy = false; return;
      }

      // Mark draft seeded once we successfully used it on /scan path
      if (resp.ok && !useNudge && payload && payload.draft_id && !RB_DRAFT_SEEDED) RB_DRAFT_SEEDED = true;
      if (!j) { try { j = await resp.json(); } catch(_){ j = {}; } }
      /* Always refresh to get the authoritative aggregate after the POST */
      await refreshChips();

      // After refresh, compute changed key using NET map (baseline ± deltas)
      let nowQtyNet, changedKNet = null, deltaNet = 0;
      try {
        const afterNet = netQtyMapFromChips();
        changedKNet = changedKey(beforeNet, afterNet);
        if (changedKNet) {
          // mark origin on the changed key
          setChipOriginByKey(changedKNet, 'scanner');
          // Learn the mapping for future prechecks
          try { BARCODE_TO_KEY.set(barcode, changedKNet); } catch(_) {}
          const b = beforeNet.get(changedKNet) || 0;
          const a = afterNet.get(changedKNet)  || 0;
          nowQtyNet = a;
          deltaNet  = a - b;   // +1 add, -1 remove; 0 = no-op
        }
      } catch(_) {}

      // If an ADD “jumped” by >1 (session rehydrated), keep UI at +1 without touching backend.
      if (mode === 'add' && typeof deltaNet === 'number' && deltaNet > 1 && changedKNet){
        try {
          const extra = deltaNet - 1;
          const prevOff = CLAMP_OFFSETS.get(changedKNet) || 0;
          CLAMP_OFFSETS.set(changedKNet, prevOff + extra);
          const desired = (beforeNet.get(changedKNet) || 0) + 1;
          const chip = document.querySelector(`#adv-lines .adv-chip[data-key="${changedKNet}"]`);
          if (chip) {
            setChipEffectiveOnly(chip, desired);
            const wpu = Number(chip.dataset.wpu || 0);
            chip.dataset.total = String(Math.round(wpu * desired * 100)/100);
            rebuildTotalsAndRemarks();
          }
          console.warn?.('[RB-ADD:CLAMP:UI]', { deltaNet, extraClamped: extra, key: changedKNet });
        } catch(_){}
      }

      // If a REMOVE landed exactly at zero, mark this key as ZEROED so snapshot
      // refreshes don’t repaint the original baseline (“baseline echo”).
      if (mode === 'remove' && changedKNet && typeof nowQtyNet === 'number' && nowQtyNet === 0) {
        (window.__RB_ZEROED = window.__RB_ZEROED || new Set()).add(changedKNet);
      }

      // Clamp: if we somehow dipped below zero, immediately revert to zero.
      if (mode === 'remove' && typeof nowQtyNet === 'number' && nowQtyNet < 0) {
        try { console.warn('[RB-UNDERFLOW]', { nowQtyNet, forceSnapshot: !!window.__RB_FORCE_SNAPSHOT }); } catch(_){}
        await undoUnderflow(barcode, Math.abs(nowQtyNet));
        await refreshChips();
        setFB('Nothing left to remove', 'scan-warn', 2000);
        scanBusy = false;
        return;
      }

      // If nothing changed, we're already at zero — further removes are a no-op.
      if (mode === 'remove' && !changedKNet) {
        // Extra visibility when this trips so we can verify maps/source
        try {
          const afterNow = netQtyMapFromChips();
          console.warn('[RB-REMOVE:NOCHANGE]', {
            forceSnapshot: !!window.__RB_FORCE_SNAPSHOT,
            beforeNet: Array.from(beforeNet.entries()),
            afterNet:  Array.from(afterNow.entries())
          });
        } catch(_){}
        setFB('Nothing left to remove', 'scan-warn', 1500);
        scanBusy = false;
        return;
      }

      if (j.status === 'unknown'){
        setFB(`Unknown barcode: ${barcode}`, 'scan-warn', 2500);
      } else {
        const rem = (typeof j.remaining === 'number')
          ? j.remaining
          : (typeof j.effective_qty === 'number')
              ? j.effective_qty
              : (typeof nowQtyNet === 'number' ? nowQtyNet : undefined);
        if (mode === 'add') {
          setFB(`Added ×1${typeof rem==='number' ? ` (now ×${rem})` : ''}`, 'scan-ok', 2500);
        } else {
          // ─── TRACE (remove path): include signed delta ───
          try {
            const remUsed =
              (typeof j.remaining === 'number')     ? 'j.remaining' :
              (typeof j.effective_qty === 'number') ? 'j.effective_qty' :
              (typeof nowQtyNet === 'number')       ? 'nowQtyNet' : 'none';
            console.warn('[RB-REMOVE]', {
              removedFlag: !!j.removed,
              j_remaining: j?.remaining,
              j_effective: j?.effective_qty,
              nowQty: nowQtyNet,
              deltaNet,
              remUsed,
              forceSnapshot: !!window.__RB_FORCE_SNAPSHOT
            });
          } catch(_){}
          // Message semantics:
          //   • deltaNet < 0  → we actually removed 1 (now = rem)
          //   • deltaNet === 0 (already handled above) → no-op
          //   • deltaNet > 0  → would imply Δ− was treated as + (shouldn’t happen with NET map)
          if (deltaNet < 0) {
            const msg = (j.removed || rem === 0)
              ? 'Removed last'
              : `Removed ×1${typeof rem==='number' ? ` (now ×${rem})` : ''}`;
            setFB(msg, 'scan-ok', 2000);
          } else if (deltaNet === 0) {
            setFB('At baseline — nothing to remove', 'scan-warn', 2000);
          } else {
            // Defensive fallback → treat as a no-op at baseline
            try { console.warn('[RB-REMOVE:FALLBACK→NOOP]', { deltaNet, forceSnapshot: !!window.__RB_FORCE_SNAPSHOT }); } catch(_){}
            setFB('Nothing left to remove', 'scan-warn', 2000);
          }
        }
      }

      // If an ADD actually increased a key, allow it to reappear again,
      // and clear the “baseline echo” suppression for that key.
      try {
        if (mode === 'add' && changedKNet && deltaNet > 0) {
          (window.__RB_ZEROED = window.__RB_ZEROED || new Set()).delete(changedKNet);
          // Do NOT delete from __RB_SNAPSHOT_BASE here; it is the echo guard.
          console.debug?.('[RB-GUARDS] cleared ZEROED for add', { key: changedKNet });
        }
      } catch(_) {}

      /* ── Outbound gate: allow the “last one” (pruned-at-zero) exactly once ── */
      try {
        if (document.body.dataset.advDir === 'outbound' && mode === 'add'){
          const after = qtyMapFromChips();
          const k     = increasedKey(beforeRaw, after);  // which item went up?
          if (k){
            // Authoritative pre-scan availability (permits taking the last unit)
            // NOTE: purely cosmetic in the UI; authoritative gate is server-side.
            // We keep this for user feedback only.
            const availSnapshot = Math.max(0, availForKey(k));
            // How much did THIS scan add?
            const beforeQty = beforeRaw.get(k) || 0;
            const afterQty  = after.get(k)  || 0;
            const delta     = Math.max(0, afterQty - beforeQty);  // usually 1
            let   remaining = 0;

            // Fallback gate (UI-only): reject if delta exceeds snapshot; do not touch backend here.
            if (delta > availSnapshot) {
              setFB('Out of stock — ignored', 'scan-warn', 2500);
            } else {
              // Remember remaining cap for the session (handles later prunes cleanly)
              remaining = Math.max(0, availSnapshot - delta);
              SESSION_AVAIL_CAPS.set(k, remaining);
              if (remaining === 0) {
                setFB('That was the last one', 'scan-ok', 2000);
              }
              // Cosmetic refresh so size dropdowns / hints stay current (not used for gating)
              await fetchInventory();
            }
            try {
              console.debug('rb-scan gate', {
                key: k, beforeQty, afterQty, delta, availSnapshot,
                remaining: SESSION_AVAIL_CAPS.get(k)
              });
            } catch (_){}
          }
        }
      } catch(_) {}

      /* mark dirty and enable Done so users can close the panel */
      try { advDone.disabled = false; } catch(_) {}
      try { advDirty = true; } catch(_) {}

      scanBusy = false;
    }
    if (inp){
      inp.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          const code = inp.value.trim();
          inp.value = '';
          if (code) scan(code);
        }
      });
    }

    // Enable the input once inventory is ready
    (async () => { try { await SCAN_READY; } catch(_) {} if (inp) inp.disabled = false; })();

    // expose to other blocks if needed
    window._rbScanRefresh = refreshChips;
    window._rbScanEnsure  = ensureManifestId;
    window._rbScanDo      = scan;
    window._rbSetOrigin   = setChipOriginByKey;
  })();

  const showError = msg => showToast(msg, 'error');

  // Canonical preview string: "Manifest: NAME SIZE lb×QTY; …;"
  function buildManifestTextFromChips(chips) {
    // De-dupe by (sanitized, wpu) and sum net qty: baseline + signed Δ
    const agg = new Map(); // key = name|wpu → {name,wpu,qty}
    (chips || []).forEach(c => {
      const name = (c.dataset.sanitized || '').trim();
      const wpu  = Number(c.dataset.wpu || 0);
      let   qty  = Number(c.dataset.effective ?? c.dataset.qty ?? 0);
      if (c.dataset.delta === '1') {
        const sign = (c.dataset.deltaSign === '-1') ? -1 : 1;
        qty = sign * qty;
      }
      const key  = `${name.toLowerCase()}|${wpu}`;
      const cur  = agg.get(key) || { name, wpu, qty: 0 };
      cur.qty += qty;
      agg.set(key, cur);
    });
    // Only print positive net quantities
    const parts = [...agg.values()]
      .filter(e => e.qty > 0)
      .map(e => `${e.name} ${e.wpu} lb×${e.qty}`);
    return parts.length ? `Manifest: ${parts.join('; ')};` : '';
  }

  const inventoryUrl = "{{ url_for('inventory.inventory_advance_data') }}";
  let invPollTimer = null;

 /* track freshness of the inventory “probe” JSON */
 let lastInventoryFetch = 0;

  function updateSizeOptions(cid, itemName) {
    advSize.disabled = false;
    advSize.innerHTML = '<option value="">Size…</option>' +
      (inventoryAdvancedData.sizes?.[cid]?.[itemName] || [])
        .map(sz => {
          const avail = inventoryAdvancedData.avail?.[cid]?.[itemName]?.[String(sz)] || 0;
          return `<option value="${sz}">${sz} lb (${avail} avail)</option>`;
        })
        .join('');
    advQty.value = '';
    advQty.disabled = true;
  }

  async function fetchInventory() {
    try {
      const fresh = await fetch(inventoryUrl + "?_=" + Date.now(), { headers: xhrHeaders() }).then(r => r.json());
      // Keep BOTH names so whichever the UI asks for is present
      inventoryAdvancedData.categories       = fresh.categories;   // new
      inventoryAdvancedData.stock_categories = fresh.categories;   // unchanged
      inventoryAdvancedData.items            = fresh.items;
      inventoryAdvancedData.sizes            = fresh.sizes;
      inventoryAdvancedData.avail            = fresh.avail;
      rebuildAvailIndex();
      lastInventoryFetch = Date.now();
      if (
        document.body.dataset.advDir === 'outbound' &&
        advCat.value && advItem.value && !advSize.value
      ) {
        updateSizeOptions(advCat.value, advItem.value);
      }
    } catch {}
  }

  function startPolling() {
    if (invPollTimer) return;
    fetchInventory();
    invPollTimer = setInterval(fetchInventory, 15000);
  }
  function stopPolling() {
    if (!invPollTimer) return;
    clearInterval(invPollTimer);
    invPollTimer = null;
  }

  function applyAdvDirUI(dir) {
    const out = dir === 'outbound';
    document.body.dataset.advDir = dir;
    document.querySelectorAll('.adv-out').forEach(el => el.style.display = out ? '' : 'none');
    document.querySelectorAll('.adv-in' ).forEach(el => el.style.display = out ? 'none' : '');
    /* show scanner only for outbound */
    const scanBox = document.getElementById('rb-scan');
    if (scanBox) {
      scanBox.style.display = out ? '' : 'none';
      if (out && document.getElementById('rb-scan-input')) document.getElementById('rb-scan-input').focus();
    }
    if (out) {
      [advItem, advSize, advQty].forEach(el => el.disabled = true);
      advQty.value = '';
    } else {
      [advName, advWeight, advWunit, advQty].forEach(el => el.disabled = false);
      advName.value = '';
      advWeight.value = '';
      advQty.value = '';
    }
  }

  /* Main entry-point – now async so we can fetch inventory once if needed */

  async function startAdvanced () {
    if (advStarting) return;
    if (advPanel && getComputedStyle(advPanel).display !== 'none') return;
    advStarting = true;
    try {
      // Fresh Advanced session → clear guards
      try {
        window.__RB_ZEROED = new Set();
        window.__RB_SNAPSHOT_BASE = new Map();
        // Also reset local clamp offsets & barcode map for a fresh session
        if (window.__RB_CLAMP_OFFSETS) window.__RB_CLAMP_OFFSETS.clear();
        if (window.__RB_BARCODE_MAP)   window.__RB_BARCODE_MAP.clear();
        console.debug?.('[RB-GUARDS] reset on startAdvanced');
      } catch(_) {}
      const dir = document.querySelector('input[name="direction"]:checked')?.value || 'outbound';
      // ── 1) Reuse the session id if we already generated one earlier ──
      if (!manifestId.value) {
        manifestId.value = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,
                         c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c/4)
                           .toString(16));
        /* first open ⇒ brand-new session ⇒ clear local trackers */
        pendingIds.length  = 0;
        removedIds.length  = 0;
        RB_DRAFT_SEEDED = false;  /* allow initial draft seed on first fetch/scan */
      }

      advDirty = false;                 // always reset the dirty flag

      // mark advanced mode active for this session
      if (advMode) advMode.value = '1';

      /* Take a snapshot so “Back” can restore */
      snapshot = {
        cargo_type   : document.getElementById('cargo_type').value,
        cargo_weight : document.getElementById('cargo_weight').value,
        remarks      : document.getElementById('remarks').value,
        chipsHTML    : advLines.innerHTML
      };
      /* panel just opened → nothing changed yet, so keep “Done” off         */
      advDone.disabled = true;
      // Always ensure we have a fresh availability snapshot before allowing scans
      await fetchInventory();
      // use the categories payload from advanced_data; stock_categories may be undefined
      /* Accept either .categories (old) or .all_categories (new) */
      let catList = inventoryAdvancedData.categories ||
                    inventoryAdvancedData.all_categories ||
                    inventoryAdvancedData.stock_categories;   // fallback
      if (!catList) {
        showError('Inventory data not yet loaded.');
        return;
      }
      // Publish readiness so the scanner can enable & proceed
      if (typeof SCAN_READY_RESOLVE === 'function') { SCAN_READY_RESOLVE(); SCAN_READY_RESOLVE = null; }

      const useList = (dir === 'inbound')
        ? catList
        : (inventoryAdvancedData.stock_categories || catList);
      advCat.innerHTML = '<option value="">Category…</option>' +
        useList.map(c => `<option value="${c.id}">${c.display_name}</option>`).join('');
      /* clear “last category” helper at the start of every new manifest */
      window._lastCatName = '';
      advDirOut.checked = (dir === 'outbound');
      advDirIn.checked  = (dir === 'inbound');
      applyAdvDirUI(dir);
      rbForm.style.display   = 'none';
      advPanel.style.display = 'block';
      startPolling();
      /* ensure manifest id exists for scans; load any existing chips */
      try { if (window._rbScanEnsure) window._rbScanEnsure(); } catch(_){}
      try { if (window._rbScanRefresh) await window._rbScanRefresh(); } catch(_){}
      try { window._rbPlaceUnitsPill && window._rbPlaceUnitsPill(); } catch(_){}
    } finally {
      advStarting = false;
    }
  }

  advBack.addEventListener('click', async () => {
    /* ── undo *all* provisional DB rows (adds & deletes) ── */
    /* Back = silent rollback (no compensators) */
    for (const eid of [...pendingIds, ...removedIds]) {
      try {
        await fetch("{{ url_for('inventory.inventory_advance_line') }}", {
          method: 'POST',
          body: new URLSearchParams({
            csrf_token:  csrfToken,
            action:      'delete',
            manifest_id: manifestId.value,
            entry_id:    eid,
            purge:       '1'      /* ← also a hard delete */
          })
        });
      } catch {}
    }
    pendingIds.length = 0;
    removedIds.length = 0;

    /* all chips are now committed, so clear the pending flag */
    advLines.querySelectorAll('.adv-chip[data-pending="1"]')
            .forEach(c => c.dataset.pending = "0");

    /* restore snapshot of header fields + chips */
    if (snapshot){
      document.getElementById('cargo_type').value   = snapshot.cargo_type;
      document.getElementById('cargo_weight').value = snapshot.cargo_weight;
      document.getElementById('remarks').value      = snapshot.remarks;
      advLines.innerHTML = snapshot.chipsHTML;
      refreshFromDOM();
      window.updateAdvTotal(0);
      snapshot = null;
    }
    advMode.value = '0';
    advDirty      = false;
    advDone.disabled = true;          /* clean slate again                  */
    advPanel.style.display = 'none';
    rbForm.style.display   = '';
    if (advMode) advMode.value = '0';
    stopPolling();
    fetchInventory();
  });

  // Helper to restore live refresh after closing Advanced in edit-draft mode
  function __rbRestoreLiveRefreshIfSuppressed(){
    try{
      if (window.__rbScanRefresh_orig){
        window._rbScanRefresh = window.__rbScanRefresh_orig;
        delete window.__rbScanRefresh_orig;
      }
      delete window.__RB_FORCE_SNAPSHOT;
    }catch(_){}
  }

  function syncFromAdvToggle() {
    const dir = advDirOut.checked ? 'outbound' : 'inbound';
    document.querySelector(`input[name="direction"][value="${dir}"]`).checked = true;
    applyDirUI();
    applyAdvDirUI(dir);
    const useList = (dir === 'inbound')
      ? (inventoryAdvancedData.categories ||
         inventoryAdvancedData.all_categories ||
         inventoryAdvancedData.stock_categories)                     // fallback added
      : (inventoryAdvancedData.stock_categories ||
         inventoryAdvancedData.categories       ||
         inventoryAdvancedData.all_categories);
    advCat.innerHTML = '<option value="">Category…</option>' +
      useList.map(c => `<option value="${c.id}">${c.display_name}</option>`).join('');
    /* clear “last category” helper at the start of every new manifest */
    window._lastCatName = '';
  }
  advDirOut.addEventListener('change', syncFromAdvToggle);
  advDirIn .addEventListener('change', syncFromAdvToggle);
  document.querySelectorAll('input[name="direction"]').forEach(radio =>
    radio.addEventListener('change', () => {
      if (advPanel.style.display === 'block') syncFromAdvToggle();
    })
  );

  advCat.addEventListener('change', () => {
    /* remember the pretty label so the next chip can store it */
    window._lastCatName =
      advCat.options[advCat.selectedIndex]?.textContent || '';
    const cid = advCat.value;
    if (document.body.dataset.advDir === 'outbound') {
      advItem.disabled = false;
      advItem.innerHTML = '<option value="">Item…</option>' +
        (inventoryAdvancedData.items?.[cid]||[]).map(i => `<option>${i}</option>`).join('');
      [advSize, advQty].forEach(el => { el.disabled = true; el.value = ''; });
    }
  });

  advItem.addEventListener('change', () => {
    if (document.body.dataset.advDir !== 'outbound') return;
    const item = advItem.value;
    if (!item) {
      advSize.disabled = true;
      advSize.innerHTML = '<option value="">Size…</option>';
      advQty.disabled   = true;
      return;
    }
    updateSizeOptions(advCat.value, item);
  });

  advSize.addEventListener('change', () => {
    if (document.body.dataset.advDir === 'outbound') {
      advQty.disabled = false;
    }
  });

  // ← send each “Add” click up to the server with CSRF
  advAdd.addEventListener('click', async () => {
    const dirNow = advDirOut.checked ? 'outbound' : 'inbound';
    const params = new URLSearchParams({
      csrf_token:  csrfToken,
      action:      'add',
      manifest_id: manifestId.value,
      direction:   dirNow,
      category:    advCat.value,
      item:        dirNow === 'outbound' ? advItem.value   : '',
      size:        dirNow === 'outbound' ? advSize.value   : '',
      name:        dirNow === 'inbound'  ? advName.value   : '',
      weight:      dirNow === 'inbound'  ? advWeight.value : '',
      wunit:       dirNow === 'inbound'  ? advWunit.value  : '',
      qty:         advQty.value
    });

    let resp;
    try {
      resp = await fetch("{{ url_for('inventory.inventory_advance_line') }}", {
        method: 'POST',
        body:   params
      });
    } catch {
      return showError('Network error.');
    }
    const j = await resp.json();
    if (!resp.ok) return showError(j.message || 'Error adding line');

    // ► New behavior: don’t create a separate “manual chip”.
    // Track the pending row, repaint from authoritative aggregate, mark origin as manual.
    pendingIds.push(j.entry_id);
    try { if (window._rbScanRefresh) await window._rbScanRefresh(); } catch(_){}
    try { if (window._rbSetOrigin)   window._rbSetOrigin(j.sanitized, j.wpu, 'manual'); } catch(_){}

    /* ► any add = dirty, so allow Done */
    advDirty        = true;
    advDone.disabled = false;


    // ─── IMMEDIATELY refresh stock & rebuild size dropdown ─────────────────
    if (dirNow === 'outbound') {
      // if you want to debug, uncomment: console.log('advAdd: rebuilding sizes');
      await fetchInventory();
      updateSizeOptions(advCat.value, advItem.value);
    }

    advDone.disabled = false;

    // Totals/remarks are rebuilt by _rbScanRefresh() via rebuildTotalsAndRemarks()

    // auto‑fill Cargo Type
    const catName = (inventoryAdvancedData.all_categories
                     || inventoryAdvancedData.categories
                     || [])
      .find(c => String(c.id) === advCat.value)
      ?.display_name || advCat.value;
    window._rbCategories = window._rbCategories || new Set();
    window._rbCategories.add(catName);
    document.getElementById('cargo_type').value =
      window._rbCategories.size === 1 ? catName : 'Mixed';
    // ─── **NEW** clear inbound free-text on add ─────────────────────────
    if (dirNow === 'inbound') {
      document.getElementById('adv-name').value   = '';
      document.getElementById('adv-weight').value = '';
    }
    advQty.value = '';
  });

  // “Done” simply hides the panel – leave rows pending until Send/Queue
  advDone.addEventListener('click', async () => {
    /* 1️⃣ promote any newly-added rows from pending→committed */
    if (pendingIds.length){
      await fetch("{{ url_for('inventory.inventory_advance_line') }}",{
        method:'POST',
        body: new URLSearchParams({
          csrf_token : csrfToken,
          action     : 'commit',
          manifest_id: manifestId.value
        })
      });
      pendingIds.length = 0;

      /* after we promote rows, every chip in the DOM is now committed */
      advLines.querySelectorAll('.adv-chip[data-pending="1"]')
              .forEach(chip => chip.dataset.pending = "0");
    }

    /* 1 b️⃣  commit all *compensating* delete rows we generated */
    if (removedIds.length){
      await fetch("{{ url_for('inventory.inventory_advance_line') }}",{
        method:'POST',
        body: new URLSearchParams({
          csrf_token : csrfToken,
          action     : 'commit',
          manifest_id: manifestId.value
        })
      });
    }
    removedIds.length = 0;

    /* 2️⃣ rebuild header fields (remarks / cargo_type / weight)
          Use authoritative server aggregate to avoid duplicates. */
    const cargoTypeField = document.getElementById('cargo_type');
    const remarksField   = document.getElementById('remarks');
    const chipsDom       = [...advLines.querySelectorAll('.adv-chip')]; // still used for category summary
    const cats           = new Set(chipsDom.map(c=> c.dataset.cat || ''));

    // Default values from DOM (fallback if API fails)
    let remarksFromDom = buildManifestTextFromChips(chipsDom);
    let totalFromDom   = chipsDom.reduce((s,c)=> s + (+c.dataset.total||0), 0);

    try {
      const q = (typeof window.draftId !== 'undefined' && window.draftId)
                  ? `?draft_id=${encodeURIComponent(window.draftId)}`
                  : '';
      const r = await fetch(
        `/api/manifest/${encodeURIComponent(manifestId.value)}/items${q}`,
        { headers: xhrHeaders() }
      );
      if (r.ok) {
        const j = await r.json();
        if (j && Array.isArray(j.items)) {
          // Build "Manifest: …" from authoritative aggregation.
          const parts = j.items.map(it => {
            const _w = Number(it.weight_per_unit);
            const _q = Number(it.qty);
            return `${it.sanitized_name} ${_w} lb×${_q}`;
          }
          );
          const serverRemarks = parts.length ? `Manifest: ${parts.join('; ')};` : '';
          const serverTotal   = j.items.reduce(
            (s,it)=> s + (Number(it.total) ||
                          (Number(it.weight_per_unit)||0) * (Number(it.qty)||0)), 0);
          remarksField.value = serverRemarks;
          document.getElementById('cargo_weight').value = serverTotal;
        } else {
          // Fallback to DOM snapshot (should still be correct)
          remarksField.value = remarksFromDom;
          document.getElementById('cargo_weight').value = totalFromDom;
        }
      } else {
        remarksField.value = remarksFromDom;
        document.getElementById('cargo_weight').value = totalFromDom;
      }
    } catch (_) {
      remarksField.value = remarksFromDom;
      document.getElementById('cargo_weight').value = totalFromDom;
    }

    // Cargo type summarised from the visible chips (category labels)
    if (chipsDom.length) {
      cargoTypeField.value = (cats.size === 1 ? [...cats][0] : 'Mixed');
    } else {
      cargoTypeField.value = '';
    }

    /* 3️⃣ hide panel */
    snapshot   = null;
    advDirty   = false;
    /* Done has actually saved changes, so disable only if NOTHING left */
    advDone.disabled = !(pendingIds.length || removedIds.length);
    advPanel.style.display = 'none'; // close Advanced
    rbForm.style.display   = '';     // show the main form
    if (advMode) advMode.value = '0';
    __rbRestoreLiveRefreshIfSuppressed();  // re-enable live refresh after edit session
    stopPolling();
    // keep stock fresh after a batch of edits
    try { await fetchInventory(); } catch(_){}
    try { if (window._rbScanRefresh) await window._rbScanRefresh(); } catch(_){}
    /* refresh scanner chips in case user will keep working outbound */
    try { if (window._rbScanRefresh) window._rbScanRefresh(); } catch(_){}
    /* and make sure totals/remarks reflect the merged chip list */
    try { if (window.refreshFromDOM) window.refreshFromDOM(); } catch(_){}
  });

  /* helper: commit all pending rows for this manifest */
  async function commitManifest() {
    if (!pendingIds.length && !removedIds.length) return; /* nothing to do */
    try {
      await fetch("{{ url_for('inventory.inventory_advance_line') }}", {
        method:'POST',
        body: new URLSearchParams({
          csrf_token:  csrfToken,
          action:      'commit',
          manifest_id: manifestId.value
        })
      });
      pendingIds.length = 0;
      removedIds.length = 0;
      advDirty          = false;
    } catch {
      showToast('Network error committing manifest.', 'error');
      throw new Error('commit-failed');
    }
  }

  // Also restore on explicit “Back” (already closes the panel)
  advBack.addEventListener('click', __rbRestoreLiveRefreshIfSuppressed, { once:false });
</script>

<script>
(function installRequestsDeletionUX(){
  if (window.__REQ_DEL_INSTALLED) return;
  window.__REQ_DEL_INSTALLED = true;

  function airportLabel(a){ return String(a||'').trim().toUpperCase(); }
  function lineLabel(n,a){ return `${String(n||'').trim()} at ${airportLabel(a)}`; }

  async function deleteLine(airport, name, rowEl){
    const payload = {
      airport: airport,
      name: String(name||'').trim(),
      sanitized_name: (rowEl?.dataset?.sanitized || '').trim() || String(name||'').trim()
    };
    const res = await fetch('/inventory/requests/line', {
      method: 'DELETE',
      headers: xhrHeaders({'Content-Type':'application/json'}),
      body: JSON.stringify(payload)
    });
    if (!res.ok){
      try { const j = await res.json(); showToast(j?.error || 'Delete failed', 'error'); } catch(_){ showToast('Delete failed','error'); }
      return false;
    }
    // Optimistic UI update: remove only this row
    if (rowEl) rowEl.remove();
    showToast('Request deleted', 'success');
    return true;
  }

  async function deleteAirport(airport){
    const res = await fetch('/inventory/requests/airport', {
      method: 'DELETE',
      headers: xhrHeaders({'Content-Type':'application/json'}),
      body: JSON.stringify({ airport })
    });
    if (!res.ok){
      try { const j = await res.json(); showToast(j?.error || 'Delete failed', 'error'); } catch(_){ showToast('Delete failed','error'); }
      return false;
    }
    // Optimistic UI update: remove all rows for this airport (if the list is on screen)
    const sel = `[data-request-row][data-airport="${airportLabel(airport)}"]`;
    document.querySelectorAll(sel).forEach(el => el.remove());
    showToast(`All requests for ${airportLabel(airport)} deleted`, 'success');
    return true;
  }

  document.addEventListener('click', async (e) => {
    const btnLine = e.target.closest('[data-action="delete-request-line"]');
    if (btnLine){
      e.preventDefault();
      const airport = btnLine.dataset.airport || '';
      const name    = btnLine.dataset.sanitized || btnLine.dataset.name || '';
      if (!airport || !name){ showToast('Missing data for delete', 'error'); return; }
      if (!confirm(`Delete request for ${name} at ${airportLabel(airport)}?`)) return;
      const rowEl = btnLine.closest('[data-request-row]') || null;
      await deleteLine(airport, name, rowEl);
      return;
    }
    const btnAirport = e.target.closest('[data-action="delete-request-airport"]');
    if (btnAirport){
      e.preventDefault();
      const airport = btnAirport.dataset.airport || '';
      if (!airport){ showToast('Missing airport', 'error'); return; }
      if (!confirm(`Delete all requests for ${airportLabel(airport)}?`)) return;
      await deleteAirport(airport);
    }
  });
})();
</script>

<style>
  .travel-time-row{display:flex;gap:4px;align-items:center}
  .travel-time-row input{flex:1 1 0;min-width:3ch;text-align:center}
  .travel-time-row span{font-weight:bold}
</style>

<!-- Make absolutely sure Δ chips remain hidden everywhere in the UI (logic-only). -->
<style>
  #adv-lines .adv-chip[data-delta="1"],
  .adv-chips .adv-chip[data-delta="1"],
  .manifest-chips .adv-chip[data-delta="1"]{
    display:none !important;
  }
</style>

  {{ super() }}
  <style>
    /* Subtle pill that sits next to the Advanced “Done” control */
    .adv-total-pill{
      display:inline-flex; align-items:center; gap:.25rem;
      font-weight:600; font-size:0.95rem;
      padding:.25rem .6rem; white-space:nowrap;
      border:1px solid #e5e7eb; border-radius:9999px;
      background:#f8fafc; margin-left:.5rem;
    }
    @media (prefers-color-scheme: dark){
      .adv-total-pill{ background:#111827; border-color:#374151; }
    }
  </style>
  <script>
  (function(){
    function ensurePill(){
      var pill = document.getElementById('adv-total-pill');
      if (pill) return pill;
      pill = document.createElement('span');
      pill.id = 'adv-total-pill';
      pill.className = 'adv-total-pill';
      pill.title = 'Sum of all Advanced chips for this manifest';
      pill.innerHTML = 'Total: <span class="val">0</span> lbs';
      // Try to place it right after the Advanced “Done” control.
      // include your real #adv-done and panel #adv-panel
      var doneBtn = document.querySelector(
        '#adv-done, ' +
        '#advanced-cargo #adv-done, ' +
        '[data-role="adv-done"], ' +
        '#advanced-cargo button.adv-done'
      );
      if (doneBtn && doneBtn.parentNode) {
        doneBtn.parentNode.insertBefore(pill, doneBtn.nextSibling);
      } else {
        var panel = document.querySelector('#adv-panel') ||
                    document.querySelector('#advanced-cargo, .advanced-panel') ||
                    document.body;
        panel.appendChild(pill);
      }
      return pill;
    }
    function setTotal(val){
      var pill = ensurePill();
      var n = Math.round((+val)||0);
      var slot = pill.querySelector('.val');
      if (slot) slot.textContent = n;
    }
    // De-dupe chips by (sanitized_name, wpu).
    // If merge===true, sum qty/total into the first chip and remove the rest.
    function dedupeChipsInDOM(merge){
      var root = document.querySelector('#adv-lines, #adv-chips, #adv-selected, .adv-chips, .manifest-chips');
      if (!root) return;
      var chips = Array.from(root.querySelectorAll('.adv-chip'));
      var keepByKey = new Map();
      function keyFor(chip){
        var name = (chip.dataset.sanitized ||
                   (chip.querySelector('.chip-content') && chip.querySelector('.chip-content').textContent) ||
                   '').trim().toLowerCase();
        var wpu = chip.dataset.wpu;
        if (!wpu){
          var m = (chip.querySelector('.chip-wpu') && chip.querySelector('.chip-wpu').textContent || '').match(/(\d+(?:\.\d+)?)/);
          wpu = m ? m[1] : '0';
        }
        // Include delta flag + sign so baseline and Δ aren’t deduped together
        var flag = 'B';
        if (chip.dataset.delta === '1') {
          flag = 'Δ' + (chip.dataset.deltaSign === '-1' ? '-1' : '+1');
        }
        return name + '|' + Number(wpu) + '|' + flag;
      }
      chips.forEach(function(chip){
        var key  = keyFor(chip);
        var keep = keepByKey.get(key);
        if (!keep){ keepByKey.set(key, chip); return; }
        // duplicate
        if (merge) {
          var q1 = Number(keep.dataset.qty   || 0),
              q2 = Number(chip.dataset.qty   || 0),
              t1 = Number(keep.dataset.total || 0),
              t2 = Number(chip.dataset.total || 0);
          var sumQ = q1 + q2,
              sumT = t1 + t2;
          keep.dataset.qty   = String(sumQ);
          keep.dataset.total = String(sumT);
          var qtyEl = keep.querySelector('.chip-qty');
          var totEl = keep.querySelector('.chip-total');
          if (qtyEl) qtyEl.textContent = '×' + sumQ;
          if (totEl) totEl.textContent = '= ' + sumT + ' lb';
        }
        if (chip.parentNode) chip.parentNode.removeChild(chip);
      });
    }
    function sumFromDOM(){
      // Normalize duplicates first so totals/remarks don’t double count.
      dedupeChipsInDOM();
      // Prefer explicit data-total values on chips if present…
      var root = document.querySelector('#adv-lines, #adv-chips, #adv-selected, .adv-chips, .manifest-chips');
      if (!root) return 0;
      var sum = 0;
      root.querySelectorAll('[data-total]').forEach(function(n){
        var t = parseFloat(n.getAttribute('data-total')) || 0; // absolute
        if (n.dataset && n.dataset.delta === '1') {
          var sgn = (n.dataset.deltaSign === '-1') ? -1 : 1;
          t = sgn * t;
        }
        sum += t;
      });
      if (sum > 0) return sum;
      // …fallback: parse "25 lb×3" / "25 lbs x 3" patterns from text.
      root.querySelectorAll('*').forEach(function(n){
        var t = (n.textContent || '').toLowerCase();
        var m = t.match(/(\d+(?:\.\d+)?)\s*lb[s]?\s*[×x]\s*(\d+)/i);
        if (m) {
          var val = (parseFloat(m[1]) * parseInt(m[2],10));
          var chip = n.closest && n.closest('.adv-chip');
          if (chip && chip.dataset.delta === '1') {
            val = (chip.dataset.deltaSign === '-1') ? -val : val;
          }
          sum += val;
        }
      });
      return sum;
    }
    function refreshFromDOM(){ setTotal(sumFromDOM()); }

    // Observe Advanced chip list for changes to keep total in sync.
    document.addEventListener('DOMContentLoaded', function(){
      ensurePill();
      refreshFromDOM();
      var root = document.querySelector('#adv-lines, #adv-chips, #adv-selected, .adv-chips, .manifest-chips');
      if (root) {
        var mo = new MutationObserver(function(){ refreshFromDOM(); });
        mo.observe(root, {childList:true, subtree:true, characterData:true});
      }
    });

    // Intercept calls to the Advanced line endpoint to use server-provided totals.
    (function hookFetch(){
      if (!window.fetch) return;
      var orig = window.fetch;
      window.fetch = function(resource, init){
        var isAdv = (typeof resource === 'string' && resource.indexOf('/_advance_line') !== -1);
        return orig.apply(this, arguments).then(function(resp){
          if (isAdv) {
            try {
              resp.clone().json().then(function(data){
                if (data && typeof data.manifest_total !== 'undefined') setTotal(data.manifest_total);
                else refreshFromDOM();
              }).catch(refreshFromDOM);
            } catch(_) {}
          }
          return resp;
        });
      };
    })();
    (function hookJQ(){
      if (!window.jQuery || !jQuery.post) return;
      var orig = jQuery.post;
      jQuery.post = function(url, data, success, dataType){
        var isAdv = (typeof url === 'string' && url.indexOf('/_advance_line') !== -1);
        var cb = function(resp){
          if (isAdv && resp && typeof resp.manifest_total !== 'undefined') setTotal(resp.manifest_total);
          else refreshFromDOM();
          if (typeof success === 'function') success(resp);
        };
        return orig.call(this, url, data, cb, dataType);
      };
    })();

    // Optional global in case other scripts want to push an update explicitly.
    window.updateAdvTotal = setTotal;
    // expose for use in loadExistingManifest()
    window.refreshFromDOM = refreshFromDOM;
  })();
  </script>

<script>
// Prev-max cargo hint (Ramp Boss)
(function(){
  function findTailInput(){
    return document.querySelector('#tail')
        || document.querySelector('#tail_number')
        || document.querySelector('input[name="tail"]')
        || document.querySelector('input[name="tail_number"]');
  }
  function findCargoLabel(){
    let lab = document.querySelector('label[for="cargo_weight"]')
           || document.querySelector('label[for="cargo_weight_real"]');
    if (!lab) {
      const inp = document.querySelector('#cargo_weight')
               || document.querySelector('[name="cargo_weight"]')
               || document.querySelector('[name="cargo_weight_real"]');
      if (inp && inp.id) lab = document.querySelector(`label[for="${inp.id}"]`);
    }
    return lab;
  }
  function ensureHintNode(lab){
    let hint = document.getElementById('prev-max-cargo-hint');
    if (!hint) {
      hint = document.createElement('span');
      hint.id = 'prev-max-cargo-hint';
      hint.style.marginLeft = '.5rem';
      hint.style.fontSize = '.9em';
      hint.style.opacity = '0.8';
      lab.appendChild(hint);
    }
    return hint;
  }
  async function updatePrevMax(){
    const tailInp = findTailInput();
    const lab = findCargoLabel();
    if (!tailInp || !lab) return;
    const hint = ensureHintNode(lab);
    const tail = (tailInp.value || '').trim().toUpperCase();
    if (!tail) { hint.textContent = ''; return; }
    try {
      const res = await fetch(`/api/aircraft/prev_max_cargo?tail=${encodeURIComponent(tail)}`, {
        headers: {'X-Requested-With':'XMLHttpRequest'}
      });
      if (!res.ok) return;
      const j = await res.json();
      if (j && j.prev_max_lbs) {
        const lbs = Number(j.prev_max_lbs).toLocaleString();
        hint.textContent = `Prev max: ${lbs} lb`;
      } else {
        hint.textContent = '';
      }
    } catch (e) { /* no-op */ }
  }
  document.addEventListener('DOMContentLoaded', function(){
    const tail = findTailInput();
    if (!tail) return;
    tail.addEventListener('input',  updatePrevMax);
    tail.addEventListener('change', updatePrevMax);
    tail.addEventListener('blur', updatePrevMax);
    updatePrevMax();
  });
})();
</script>

  <!-- ───────── Ambient scanner capture (PuTTY-calibrated) ───────── -->
  <script>
  (function(){
    // Treat as scanner if gaps are tiny and there's a decent length
    const GAP_MS    = 20;   // your runs: max 5ms → 20ms is a comfy ceiling
    const MIN_CHARS = 6;    // need at least this many before ENTER
    const RESET_MS  = 800;  // abandon partial bursts after idle

    let capturing = false;
    let last = 0, count = 0, timer = null;

    function isEditable(el){
      if (!el) return false;
      if (el.isContentEditable) return true;
      const t = (el.tagName||'').toLowerCase();
      return (t === 'input' || t === 'textarea' || t === 'select');
    }
    function advVisible(){
      const p = document.getElementById('adv-panel');
      return p && getComputedStyle(p).display !== 'none';
    }
    function outSelected(){
      return document.getElementById('adv-dir-out')?.checked ||
             document.body.dataset.advDir === 'outbound';
    }
    function findScanBox(){
      // Prefer the visible scan box in Advanced panel
      return document.querySelector('#adv-panel input[placeholder^="Scan barcode"]')
          || document.querySelector('input[placeholder^="Scan barcode"]');
    }
    function resetBurst(){
      capturing = false; last = 0; count = 0;
      if (timer) { clearTimeout(timer); timer = null; }
    }
    function armTimeout(){
      if (timer) clearTimeout(timer);
      timer = setTimeout(resetBurst, RESET_MS);
    }

    // Redirect the very first fast character into the scan box when nothing else is focused
    document.addEventListener('keydown', (e) => {
      if (!advVisible() || !outSelected()) return;
      if (isEditable(document.activeElement)) return;      // user is typing somewhere on purpose
      if (e.key.length !== 1) return;                      // printable only

      const scan = findScanBox();
      if (!scan) return;

      if (!capturing){
        capturing = true;
        scan.value = e.key;                                // seed first char
        scan.focus();
        last = performance.now();
        count = 1;
        armTimeout();
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);

    // While focused in the Scan box, verify the “scanner-speed” pattern
    document.addEventListener('keydown', (e) => {
      const scan = findScanBox();
      if (!capturing || !scan || document.activeElement !== scan) return;

      if (e.key === 'Enter'){
        const isScanner = (count >= MIN_CHARS);
        resetBurst();
        // Let the input's own handler in setupScanner() perform a single scan.
        if (isScanner) e.preventDefault();
        return;
      }
      if (e.key.length === 1){
        const now = performance.now();
        const gap = now - last;
        last = now; count++;
        if (gap > GAP_MS) resetBurst(); else armTimeout();
      }
    }, true);
  })();
  </script>

{% endblock %}
