<section class="agg-requests-panel" aria-live="polite">
  <h3 class="muted" style="margin:0 0 8px;">Aggregated Requests</h3>
  <div id="agg-requests-airports"></div>
</section>

<script>
/* Self-contained panel (safe to include in drawer or as a page section) */
(function () {
  // prevent double-bootstrapping if this partial appears twice
  const BOOT_KEY = '__AGG_PANEL_BOOTSTRAPPED__';
  if (window[BOOT_KEY]) return;
  window[BOOT_KEY] = true;

  // How often a card's effective priority should be recomputed (ms)
  const EFFECTIVE_TTL_MS = 30_000;

  async function j(url) {
    const r = await fetch(url, {headers: {"X-Requested-With":"XMLHttpRequest"}});
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  function priBadge(code, label){
    const cls = code === 3 ? "badge ls" : (code === 2 ? "badge pp" : "badge is");
    const icon = code === 3 ? "&#9888;" : (code === 2 ? "&#9874;" : "&#9432;");
    return `<span class="${cls}" title="${label}">${icon} ${label}</span>`;
  }

  function style() {
    const css = `
      :root{
        --agg-surface:#fff;
        --agg-border:#dcdcdc;
        --agg-subtle:#6b7280;
        --agg-chip-bg:#f3f4f6;
        --agg-chip-fg:#111827;
      }
      .agg-requests-panel .airport { background:var(--agg-surface); border:1px solid var(--agg-border); border-radius:10px; margin:10px 0; box-shadow:0 1px 2px rgba(0,0,0,.04); }
      .agg-requests-panel .airport header {
        position: static; top:auto; left:auto; right:auto; z-index:auto; /* override global header{position:fixed} */
        background:var(--agg-surface);
        padding:10px 12px;
        display:flex; align-items:center; justify-content:space-between; cursor:pointer;
      }
      .agg-requests-panel .airport header .name { font-weight:600; letter-spacing:.3px; }
      .agg-requests-panel .airport header .chip { font-size:12px; padding:2px 10px; border-radius:999px; background:var(--agg-chip-bg); color:var(--agg-chip-fg); border:1px solid var(--agg-border); }
      .agg-requests-panel .airport .body { display:none; padding:0 12px 10px 12px; }
      .agg-requests-panel .airport.open .body { display:block; }
      .agg-requests-panel table.req { width:100%; border-collapse:collapse; background:var(--agg-surface); }
      .agg-requests-panel table.req th, .agg-requests-panel table.req td { padding:8px 10px; border-bottom:1px solid #eee; }
      .agg-requests-panel table.req thead th { background:transparent; color:inherit; border-bottom:1px solid #e5e7eb; }
      .agg-requests-panel .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; }
      .agg-requests-panel .badge.ls { background:#b30000; color:#fff; }
      .agg-requests-panel .badge.pp { background:#c07a00; color:#fff; }
      .agg-requests-panel .badge.is { background:#6c757d; color:#fff; }
      .agg-requests-panel .outstanding { font-weight:600; }
      .agg-requests-panel .src { font-size:12px; color:var(--agg-subtle); }

      /* Header coloring by highest ACTIVE priority */
      .agg-requests-panel .airport header .name.pri-ls,
      .agg-requests-panel .airport header .chip.pri-ls { color:#b30000; font-weight:600; }
      .agg-requests-panel .airport header .name.pri-pp,
      .agg-requests-panel .airport header .chip.pri-pp { color:#c07a00; font-weight:600; }

      /* De-emphasize fulfilled rows */
      .agg-requests-panel table.req tr.done td { color:var(--agg-subtle); }
    `;
    const s = document.createElement('style'); s.textContent = css; document.head.appendChild(s);
  }

  // ---------- Helpers for "active-only" priority semantics ----------
  function isActive(row){ return (row && (row.outstanding_lb || 0) > 0); }

  function computeEffectiveMeta(rows){
    let maxPri = 0;
    for (const r of rows || []){
      if (!isActive(r)) continue;
      const pc = r.priority_code || 0;
      if (pc > maxPri) maxPri = pc;
    }
    return { effective_pri: maxPri };
  }

  function setPriClass(el, pri){
    if (!el) return;
    el.classList.remove('pri-ls','pri-pp');
    if (pri === 3) el.classList.add('pri-ls');
    else if (pri === 2) el.classList.add('pri-pp');
  }

  function applyActiveDecor(card, eff){
    const pri = eff.effective_pri || 0;
    setPriClass(card.querySelector('header .name'), pri);
    setPriClass(card.querySelector('header .chip'), pri);
    // persist for sort & TTL
    card.dataset.effectivePri = String(pri);
    card.dataset.effTs = String(Date.now());
  }

  function updateCardOutstanding(card, v){
    card.dataset.outstanding = String(v == null ? 0 : +v);
  }

  function airportCard(a){
    const div = document.createElement('div');
    div.className = 'airport';
    div.dataset.airport = a.airport;
    // seed sort fallbacks from META; corrected after detail fetch
    div.dataset.maxPri = String(a.max_pri || 0);
    updateCardOutstanding(div, a.outstanding_lb || 0);

    div.innerHTML = `
      <header>
        <span class="name">${a.airport}</span>
        <span class="chip">
          Outstanding: ${a.outstanding_lb?.toFixed(1) ?? '0.0'} lb
        </span>
      </header>
      <div class="body"><div class="inner">Loading…</div></div>
    `;

    div.querySelector('header').addEventListener('click', async () => {
      div.classList.toggle('open');
      const body = div.querySelector('.body .inner');
      if (div.classList.contains('open')) {
        const rows = await j(`/aggregate/ramp/v2/${encodeURIComponent(a.airport)}`);
        body.innerHTML = renderRows(a.airport, rows);
        const eff = computeEffectiveMeta(rows);
        applyActiveDecor(div, eff);
        resortCards();
      }
    });
    return div;
  }

  async function deleteGroup(airport, priorityCode, need) {
    if (!confirm(`Delete request for "${need}" at ${airport}?`)) return;
    try {
      const url = `/aggregate/ramp/v2/${encodeURIComponent(airport)}/${priorityCode}/${encodeURIComponent(need)}`;
      const r = await fetch(url, {method: 'DELETE', headers: {"X-Requested-With":"XMLHttpRequest"}});
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      // Trigger global refresh + badge update
      if (window.__aggRefreshNow) window.__aggRefreshNow();
      if (window.__updateReqBadge) window.__updateReqBadge();
    } catch(e) {
      alert('Delete failed: ' + e.message);
    }
  }

  async function deleteAirport(airport) {
    if (!confirm(`Delete ALL requests for ${airport}?`)) return;
    try {
      const url = `/aggregate/ramp/v2/${encodeURIComponent(airport)}/all`;
      const r = await fetch(url, {method: 'DELETE', headers: {"X-Requested-With":"XMLHttpRequest"}});
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      // Trigger global refresh + badge update
      if (window.__aggRefreshNow) window.__aggRefreshNow();
      if (window.__updateReqBadge) window.__updateReqBadge();
    } catch(e) {
      alert('Delete failed: ' + e.message);
    }
  }

  function renderRows(airport, rows){
    // Active rows (outstanding>0) first by priority desc; fulfilled afterwards
    const active = (rows||[]).filter(isActive).sort((a,b)=> (b.priority_code||0)-(a.priority_code||0));
    const done   = (rows||[]).filter(r => !isActive(r));
    const ordered = active.concat(done);
    const tr = ordered.map(r => {
      const p = priBadge(r.priority_code, r.priority_label);
      const qty = `${(r.outstanding_lb||0).toFixed(1)} lb` +
                  ` <span class="muted">(${(r.requested_lb||0).toFixed(1)} lb)</span>` +
                  (r.shipped_lb>0 ? ` — shipped ${(r.shipped_lb||0).toFixed(1)} lb` : '');
      const srcs = (r.sources||[]).map(s => {
        const comm = s.comm_id ? ` — <a href="/comms?id=${s.comm_id}" target="_blank" rel="noopener">Comms ${s.comm_id}</a>` : '';
        return `<div class="src">#${s.id}${comm}${s.ref ? ' — '+s.ref : ''}</div>`;
      }).join('');
      const rowCls = isActive(r) ? '' : ' class="done"';
      const delBtn = `<button type="button" class="btn-del-group" data-ap="${airport}" data-pri="${r.priority_code}" data-need="${r.need}" style="font-size:11px;padding:2px 6px;margin-left:4px;cursor:pointer;" title="Delete this request">✕</button>`;
      return `<tr${rowCls}>
        <td>${p}</td>
        <td>${r.need}${delBtn}</td>
        <td>${qty}</td>
        <td>${airport}</td>
      </tr>
      <tr><td colspan="4">${srcs}</td></tr>`;
    }).join('');
    return `<table class="req">
      <thead><tr><th>Priority</th><th>Need</th><th>Qty remaining (original)</th><th>Deliver to</th></tr></thead>
      <tbody>${tr || '<tr><td colspan="4">No open items.</td></tr>'}</tbody>
    </table>`;
  }

  // Delegate click events for delete buttons
  document.getElementById('agg-requests-airports')?.addEventListener('click', (e) => {
    const btn = e.target.closest('.btn-del-group');
    if (btn) {
      e.stopPropagation();
      deleteGroup(btn.dataset.ap, parseInt(btn.dataset.pri), btn.dataset.need);
    }
  });

  // Sort helpers (airports): outstanding>0 first, then EFFECTIVE max priority, then code
  function _keyFromCard(card){
    const zero = (parseFloat(card.dataset.outstanding || '0') || 0) <= 0;
    const pri  = zero ? 0 : (parseInt(card.dataset.effectivePri || card.dataset.maxPri || '0') || 0);
    return {zero, pri, code: String(card.dataset.airport||'')};
  }
  function cmpCards(a,b){
    const ka=_keyFromCard(a), kb=_keyFromCard(b);
    if (ka.zero!==kb.zero) return ka.zero ? 1 : -1;
    if (ka.pri!==kb.pri)   return kb.pri - ka.pri;
    return ka.code.localeCompare(kb.code);
  }
  function resortCards(){
    const root = document.getElementById('agg-requests-airports');
    if (!root) return;
    const cards = Array.from(root.querySelectorAll('.airport'));
    cards.sort(cmpCards).forEach(c => root.appendChild(c));
  }

  // Recompute effective priority for a single card (optionally refresh its table if open)
  async function recomputeEffective(card, {refreshTable=false} = {}){
    const ap = card.dataset.airport;
    const rows = await j(`/aggregate/ramp/v2/${encodeURIComponent(ap)}`);
    if (refreshTable && card.classList.contains('open')) {
      const body = card.querySelector('.body .inner');
      if (body) body.innerHTML = renderRows(ap, rows);
    }
    const eff = computeEffectiveMeta(rows);
    applyActiveDecor(card, eff);
  }

  async function bootstrap(){
    style();
    const root = document.getElementById('agg-requests-airports');
    if (!root) return;

    // Initial list from summary meta (no coloring yet)
    const meta = await j('/aggregate/ramp/v2');
    meta.slice()
        .sort((a,b)=>{
          const az = (a.outstanding_lb || 0) <= 0;
          const bz = (b.outstanding_lb || 0) <= 0;
          if (az !== bz) return az ? 1 : -1;
          // fall back to meta priority only for initial ordering; corrected after first effective pass
          const ap = (a.max_pri || 0), bp = (b.max_pri || 0);
          if (ap !== bp) return bp - ap;
          return String(a.airport || '').localeCompare(String(b.airport || ''));
        })
        .forEach(a => root.appendChild(airportCard(a)));

    // Background pass: compute EFFECTIVE (active-only) priorities for all cards and color them
    await Promise.all(
      Array.from(root.querySelectorAll('.airport')).map(card =>
        recomputeEffective(card, {refreshTable:false}).catch(()=>{})
      )
    );
    resortCards();

    // ---- Auto-refresh: update chips + periodically recompute effective priorities ----
    async function refreshAll({force=false} = {}){
      try{
        const fresh = await j('/aggregate/ramp/v2'); // [{airport, outstanding_lb, max_pri}, ...]
        const byAp = new Map(fresh.map(x => [x.airport, x]));

        for (const card of Array.from(root.querySelectorAll('.airport'))){
          const ap = card.dataset.airport;
          const meta = byAp.get(ap);

          if (meta){
            // Update numeric chip only (no color changes here → avoids "red flash")
            const chip = card.querySelector('.chip');
            if (chip){
              chip.textContent = `Outstanding: ${(meta.outstanding_lb||0).toFixed(1)} lb`;
            }
            updateCardOutstanding(card, meta.outstanding_lb || 0);
            card.dataset.maxPri = String(meta.max_pri || 0);

            const lastTs = parseInt(card.dataset.effTs || '0') || 0;
            const stale = (Date.now() - lastTs) >= EFFECTIVE_TTL_MS;

            // Recompute effective pri if open, forced, or stale
            if (force || card.classList.contains('open') || stale){
              await recomputeEffective(card, {refreshTable: force || card.classList.contains('open')}).catch(()=>{});
            }
          } else {
            // airport disappeared (everything satisfied) → remove the card
            card.remove();
          }
        }

        // Add any new airports that showed up
        for (const a of fresh){
          if (!root.querySelector(`.airport[data-airport="${a.airport}"]`)){
            const card = airportCard(a);
            root.appendChild(card);
            // compute effective for the new card
            recomputeEffective(card, {refreshTable:false}).catch(()=>{});
          }
        }

        // Resort DOM using EFFECTIVE priorities
        resortCards();
      }catch(_e){ /* silent; next tick will catch up */ }
    }

    // Run periodically + when tab regains focus
    setInterval(() => refreshAll(), 15000);
    window.addEventListener('focus', () => refreshAll());

    // Expose a global hook so other code can trigger an immediate refresh:
    window.__aggRefreshNow = () => refreshAll({force:true});
  }

  bootstrap().catch(err => {
    const root = document.getElementById('agg-requests-airports');
    if (root) root.textContent = 'Failed to load: ' + err;
  });
})();
</script>
